<!doctype html><html lang=en dir=auto><head><script src="/blog/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=blog/livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Prime Sieves | cwHsueh</title>
<meta name=keywords content="DSA"><meta name=description content="How to find all primes under n?
Sieve of Eratosthenes
This algorithm is a very intuitive way to find all primes under n. We first create a list of numbers from 2 to n and then iterate over the list. For each number i, we mark all its multiples as non-prime. At the end, all numbers that are not marked are prime.


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13


vector<int> find_primes(int n) {
    vector<int> primes;
    vector<bool> is_prime(n + 1, true);
    for (int i = 2; i * i <= n; i++) {
        if (is_prime[i]) {
            primes.push_back(i);
            for (int j = i * i; j <= n; j += i) {
                is_prime[j] = false;
            }
        }
    }
    return primes;
}


Let&rsquo;s analyze the time complexity. For each prime number p, we will iterate from p * p to n. Which means that the time complexity is $\sum_{p \text{ is prime}}^{p \leq n} \frac{n}{p} = n\sum_{p \text{ is prime}}^{p \leq n} \frac{1}{p} = n\log\log n$ (prime harmonic series)."><meta name=author content="cwHsueh"><link rel=canonical href=http://localhost:1313/blog/posts/prime_sieves/><link crossorigin=anonymous href=/blog/assets/css/stylesheet.45e028aa8ce0961349adf411b013ee39406be2c0bc80d4ea3fc04555f7f4611a.css integrity="sha256-ReAoqozglhNJrfQRsBPuOUBr4sC8gNTqP8BFVff0YRo=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/favicon-32x32.png><link rel=apple-touch-icon href=http://localhost:1313/apple-touch-icon.png><link rel=mask-icon href=http://localhost:1313/blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:1313/blog/posts/prime_sieves/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.css integrity=sha384-zh0CIslj+VczCZtlzBcjt5ppRcsAmDnRem7ESsYwWwg3m/OaJ2l4x7YBZl9Kxxib crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.js integrity=sha384-Rma6DA2IPUwhNxmrB/7S3Tno0YY7sFu9WSYMCuulLhIqYSGZ2gKCJWIqhBWqMQfh crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/contrib/auto-render.min.js integrity=sha384-hCXGrW6PitJEwbkoStFjeJxv+fSOOQKOPbJxSfM6G5sWZjAyWhXiTIIAmQqnlLlh crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script><meta property="og:url" content="http://localhost:1313/blog/posts/prime_sieves/"><meta property="og:site_name" content="cwHsueh"><meta property="og:title" content="Prime Sieves"><meta property="og:description" content="How to find all primes under n? Sieve of Eratosthenes This algorithm is a very intuitive way to find all primes under n. We first create a list of numbers from 2 to n and then iterate over the list. For each number i, we mark all its multiples as non-prime. At the end, all numbers that are not marked are prime.
1 2 3 4 5 6 7 8 9 10 11 12 13 vector<int> find_primes(int n) { vector<int> primes; vector<bool> is_prime(n + 1, true); for (int i = 2; i * i <= n; i++) { if (is_prime[i]) { primes.push_back(i); for (int j = i * i; j <= n; j += i) { is_prime[j] = false; } } } return primes; } Let’s analyze the time complexity. For each prime number p, we will iterate from p * p to n. Which means that the time complexity is $\sum_{p \text{ is prime}}^{p \leq n} \frac{n}{p} = n\sum_{p \text{ is prime}}^{p \leq n} \frac{1}{p} = n\log\log n$ (prime harmonic series)."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-02-18T00:00:00-07:00"><meta property="article:modified_time" content="2025-02-18T00:00:00-07:00"><meta property="article:tag" content="DSA"><meta name=twitter:card content="summary"><meta name=twitter:title content="Prime Sieves"><meta name=twitter:description content="How to find all primes under n?
Sieve of Eratosthenes
This algorithm is a very intuitive way to find all primes under n. We first create a list of numbers from 2 to n and then iterate over the list. For each number i, we mark all its multiples as non-prime. At the end, all numbers that are not marked are prime.


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13


vector<int> find_primes(int n) {
    vector<int> primes;
    vector<bool> is_prime(n + 1, true);
    for (int i = 2; i * i <= n; i++) {
        if (is_prime[i]) {
            primes.push_back(i);
            for (int j = i * i; j <= n; j += i) {
                is_prime[j] = false;
            }
        }
    }
    return primes;
}


Let&rsquo;s analyze the time complexity. For each prime number p, we will iterate from p * p to n. Which means that the time complexity is $\sum_{p \text{ is prime}}^{p \leq n} \frac{n}{p} = n\sum_{p \text{ is prime}}^{p \leq n} \frac{1}{p} = n\log\log n$ (prime harmonic series)."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:1313/blog/posts/"},{"@type":"ListItem","position":2,"name":"Prime Sieves","item":"http://localhost:1313/blog/posts/prime_sieves/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Prime Sieves","name":"Prime Sieves","description":"How to find all primes under n? Sieve of Eratosthenes This algorithm is a very intuitive way to find all primes under n. We first create a list of numbers from 2 to n and then iterate over the list. For each number i, we mark all its multiples as non-prime. At the end, all numbers that are not marked are prime.\n1 2 3 4 5 6 7 8 9 10 11 12 13 vector\u0026lt;int\u0026gt; find_primes(int n) { vector\u0026lt;int\u0026gt; primes; vector\u0026lt;bool\u0026gt; is_prime(n + 1, true); for (int i = 2; i * i \u0026lt;= n; i++) { if (is_prime[i]) { primes.push_back(i); for (int j = i * i; j \u0026lt;= n; j += i) { is_prime[j] = false; } } } return primes; } Let\u0026rsquo;s analyze the time complexity. For each prime number p, we will iterate from p * p to n. Which means that the time complexity is $\\sum_{p \\text{ is prime}}^{p \\leq n} \\frac{n}{p} = n\\sum_{p \\text{ is prime}}^{p \\leq n} \\frac{1}{p} = n\\log\\log n$ (prime harmonic series).\n","keywords":["DSA"],"articleBody":"How to find all primes under n? Sieve of Eratosthenes This algorithm is a very intuitive way to find all primes under n. We first create a list of numbers from 2 to n and then iterate over the list. For each number i, we mark all its multiples as non-prime. At the end, all numbers that are not marked are prime.\n1 2 3 4 5 6 7 8 9 10 11 12 13 vector\u003cint\u003e find_primes(int n) { vector\u003cint\u003e primes; vector\u003cbool\u003e is_prime(n + 1, true); for (int i = 2; i * i \u003c= n; i++) { if (is_prime[i]) { primes.push_back(i); for (int j = i * i; j \u003c= n; j += i) { is_prime[j] = false; } } } return primes; } Let’s analyze the time complexity. For each prime number p, we will iterate from p * p to n. Which means that the time complexity is $\\sum_{p \\text{ is prime}}^{p \\leq n} \\frac{n}{p} = n\\sum_{p \\text{ is prime}}^{p \\leq n} \\frac{1}{p} = n\\log\\log n$ (prime harmonic series).\nOf course, the actual time complexity should be better than $n\\log\\log n$. Since we only need to iterate over prime numbers that is smaller or equal to sqrt(n) (for (int i = 2; i * i \u003c= n; i++)). This is sufficient to find all primes under n, since every composite number must have a prime factor that is smaller or equal to sqrt(n). And for each prime number, we actaully start from p * p instead of 2 * p (for (int j = i * i; j \u003c= n; j += i)).\nCan we do better? In this algorithm, for each composite number c, we ran is_prime[c] = false multiple times. Take 12 as an example, is_prime[12] is set to false when i is 2, 3. Is it possible to set is_prime[12] to false only once?\nEuler’s Sieve In Euler’s sieve, every composite number is marked to false by its greatest proper factor (more accurately, we would mark it to false when it is smallest prime factor * greatest proper factor). Proper factor means the factor that is not the number itself.\nTake 12 as an example. is_prime[12] should be marked as false when the number we are iterating (the first for loop in Sieve of Eratosthenes) is 6, the greatest proper factor of 12. Let’s take a look how can we accomplish this.\nLet’s say the number we are iterating is c, a composite number. Our goal is to find every prime p such that the product p * c can be expressed as smallest prime factor * greatest proper factor, then mark is_prime[p * c] as false. Remember, the reason why we are doing this is because for each composite number, we only want to mark it as false once.\nWe could write c = p * q, where p is the smallest prime factor of c, and q is the greatest proper factor of c. If we have another prime number k that is greater than p, then k * c will not be in the form of smallest prime factor * greatest proper factor, since we could write the product as p * (k * q). If k is smaller or equal to p, then k * c will be in the form of smallest prime factor * greatest proper factor, we can mark k * c as non prime. It is not that trivial, you might need to think about it for a while.\nBasically, for each number i we are iterating, we find the product of i with all prime numbers smaller than the smallest prime factor of i.\nLet’s run the algorithm with an example. In the following example, n is 12.\nnumbers = [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]\rprimes = [] We start from i = 2. Since 2 is prime, we add it to primes. Then we iterate from 2 * 2 to 2 * 2, since 2 is the largest prime that is \u003c= 2. In this round of iteration, we mark 4 as non-prime. I use a asterisk to mark numbers as non-prime.\nnumbers = [2, 3, *4, 5, 6, 7, 8, 9, 10, 11, 12]\rprimes = [2] Next, we start from i = 3. Since 3 is prime, we add it to primes. Then we iterate from 3 * 2 to 3 * 3. In this round of iteration, we mark 6, 9 as non-prime.\nnumbers = [2, 3, *4, 5, *6, 7, 8, *9, 10, 11, 12]\rprimes = [2, 3] Next, we start from i = 4. Since 4 is not prime, we will not add it to primes. We iterate from 4 * 2 to 4 * 2. In this round of iteration, we mark 8 as non-prime.\nnumbers = [2, 3, *4, 5, *6, 7, *8, *9, 10, 11, 12]\rprimes = [2, 3] Next, we start from i = 5. Since 5 is prime, we add it to primes. Then we iterate from 5 * 2 to 5 * 5. In this round of iteration, we mark 10 as non-prime.\nnumbers = [2, 3, *4, 5, *6, 7, *8, *9, *10, 11, 12]\rprimes = [2, 3, 5] Next, we start from i = 6. Since 6 is not prime, we will not add it to primes. We iterate from 6 * 2 to 6 * 2. In this round of iteration, we mark 12 as non-prime.\nnumbers = 2, 3, *4, 5, *6, 7, *8, *9, *10, 11, *12\rprimes = [2, 3, 5] We just do the same thing over and over. For each number, we will only mark it as non-prime once.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 vector\u003cint\u003e find_primes(int n) { vector\u003cint\u003e primes; vector\u003cbool\u003e is_prime(n + 1, true); for (int i = 2; i \u003c= n; i++) { // i is greatest proper factor if (is_prime[i]) { primes.push_back(i); } for (int prime: primes) { if (i * prime \u003e n) { break; } is_prime[i * prime] = false; if (i % prime == 0) { // prime is the smallest prime factor of i break; } } } return primes; } The time complexity of Euler’s sieve is $O(n)$ since we marked each number as non-prime only once. The interesting thing about Euler’s sieve is that it is called Euler’s sieve instead of sieve of Euler.\n","wordCount":"1081","inLanguage":"en","datePublished":"2025-02-18T00:00:00-07:00","dateModified":"2025-02-18T00:00:00-07:00","author":{"@type":"Person","name":"cwHsueh"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/blog/posts/prime_sieves/"},"publisher":{"@type":"Organization","name":"cwHsueh","logo":{"@type":"ImageObject","url":"http://localhost:1313/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/blog/ accesskey=h title="cwHsueh (Alt + H)">cwHsueh</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://cwhsueh.com title=about><span>about</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li><li><a href=http://localhost:1313/blog/leetcode/ title=leetcode><span>leetcode</span></a></li><li><a href=http://localhost:1313/blog/tags/ title=tags><span>tags</span></a></li><li><a href=http://localhost:1313/blog/archives/ title=archive><span>archive</span></a></li><li><a href=http://localhost:1313/blog/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://localhost:1313/blog/>Home</a>&nbsp;»&nbsp;<a href=http://localhost:1313/blog/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Prime Sieves</h1><div class=post-meta><span title='2025-02-18 00:00:00 -0700 -0700'>February 18, 2025</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;1081 words&nbsp;·&nbsp;cwHsueh</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#how-to-find-all-primes-under-n aria-label="How to find all primes under n?">How to find all primes under n?</a><ul><li><a href=#sieve-of-eratosthenes aria-label="Sieve of Eratosthenes">Sieve of Eratosthenes</a></li><li><a href=#eulers-sieve aria-label="Euler&rsquo;s Sieve">Euler&rsquo;s Sieve</a></li></ul></li></ul></div></details></div><div class=post-content><h1 id=how-to-find-all-primes-under-n>How to find all primes under <code>n</code>?<a hidden class=anchor aria-hidden=true href=#how-to-find-all-primes-under-n>#</a></h1><h2 id=sieve-of-eratosthenes>Sieve of Eratosthenes<a hidden class=anchor aria-hidden=true href=#sieve-of-eratosthenes>#</a></h2><p>This algorithm is a very intuitive way to find all primes under <code>n</code>. We first create a list of numbers from 2 to <code>n</code> and then iterate over the list. For each number <code>i</code>, we mark all its multiples as non-prime. At the end, all numbers that are not marked are prime.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>find_primes</span><span class=p>(</span><span class=kt>int</span> <span class=n>n</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>primes</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>vector</span><span class=o>&lt;</span><span class=kt>bool</span><span class=o>&gt;</span> <span class=n>is_prime</span><span class=p>(</span><span class=n>n</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=nb>true</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span> <span class=n>i</span> <span class=o>*</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=n>n</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>is_prime</span><span class=p>[</span><span class=n>i</span><span class=p>])</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>primes</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>i</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=n>i</span> <span class=o>*</span> <span class=n>i</span><span class=p>;</span> <span class=n>j</span> <span class=o>&lt;=</span> <span class=n>n</span><span class=p>;</span> <span class=n>j</span> <span class=o>+=</span> <span class=n>i</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>is_prime</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>primes</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>Let&rsquo;s analyze the time complexity. For each prime number <code>p</code>, we will iterate from <code>p * p</code> to <code>n</code>. Which means that the time complexity is $\sum_{p \text{ is prime}}^{p \leq n} \frac{n}{p} = n\sum_{p \text{ is prime}}^{p \leq n} \frac{1}{p} = n\log\log n$ (prime harmonic series).</p><p>Of course, the actual time complexity should be better than $n\log\log n$. Since we only need to iterate over prime numbers that is smaller or equal to sqrt(n) (<code>for (int i = 2; i * i &lt;= n; i++)</code>). This is sufficient to find all primes under <code>n</code>, since every composite number must have a prime factor that is smaller or equal to sqrt(n). And for each prime number, we actaully start from <code>p * p</code> instead of <code>2 * p</code> (<code>for (int j = i * i; j &lt;= n; j += i)</code>).</p><p>Can we do better? In this algorithm, for each composite number <code>c</code>, we ran <code>is_prime[c] = false</code> multiple times. Take <code>12</code> as an example, <code>is_prime[12]</code> is set to false when <code>i</code> is <code>2, 3</code>. Is it possible to set <code>is_prime[12]</code> to false only once?</p><h2 id=eulers-sieve>Euler&rsquo;s Sieve<a hidden class=anchor aria-hidden=true href=#eulers-sieve>#</a></h2><p>In Euler&rsquo;s sieve, every composite number is marked to false by its greatest proper factor (more accurately, we would mark it to false when it is <code>smallest prime factor * greatest proper factor</code>). Proper factor means the factor that is not the number itself.</p><p>Take <code>12</code> as an example. <code>is_prime[12]</code> should be marked as false when the number we are iterating (the first for loop in Sieve of Eratosthenes) is <code>6</code>, the greatest proper factor of <code>12</code>. Let&rsquo;s take a look how can we accomplish this.</p><p>Let&rsquo;s say the number we are iterating is <code>c</code>, a composite number. Our goal is to find every prime <code>p</code> such that the product <code>p * c</code> can be expressed as <code>smallest prime factor * greatest proper factor</code>, then mark <code>is_prime[p * c]</code> as false. Remember, the reason why we are doing this is because for each composite number, we only want to mark it as false once.</p><p>We could write <code>c = p * q</code>, where <code>p</code> is the smallest prime factor of <code>c</code>, and <code>q</code> is the greatest proper factor of <code>c</code>. If we have another prime number <code>k</code> that is greater than <code>p</code>, then <code>k * c</code> will not be in the form of <code>smallest prime factor * greatest proper factor</code>, since we could write the product as <code>p * (k * q)</code>. If <code>k</code> is smaller or equal to <code>p</code>, then <code>k * c</code> will be in the form of <code>smallest prime factor * greatest proper factor</code>, we can mark <code>k * c</code> as non prime. It is not that trivial, you might need to think about it for a while.</p><p>Basically, for each number <code>i</code> we are iterating, we find the product of <code>i</code> with all prime numbers smaller than the smallest prime factor of <code>i</code>.</p><p>Let&rsquo;s run the algorithm with an example. In the following example, <code>n</code> is <code>12</code>.</p><pre tabindex=0><code>numbers = [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]
primes = []
</code></pre><p>We start from <code>i = 2</code>. Since <code>2</code> is prime, we add it to <code>primes</code>. Then we iterate from <code>2 * 2</code> to <code>2 * 2</code>, since <code>2</code> is the largest prime that is <code>&lt;= 2</code>. In this round of iteration, we mark <code>4</code> as non-prime. I use a asterisk to mark numbers as non-prime.</p><pre tabindex=0><code>numbers = [2, 3, *4, 5, 6, 7, 8, 9, 10, 11, 12]
primes = [2]
</code></pre><p>Next, we start from <code>i = 3</code>. Since <code>3</code> is prime, we add it to <code>primes</code>. Then we iterate from <code>3 * 2</code> to <code>3 * 3</code>. In this round of iteration, we mark <code>6, 9</code> as non-prime.</p><pre tabindex=0><code>numbers = [2, 3, *4, 5, *6, 7, 8, *9, 10, 11, 12]
primes = [2, 3]
</code></pre><p>Next, we start from <code>i = 4</code>. Since <code>4</code> is not prime, we will not add it to <code>primes</code>. We iterate from <code>4 * 2</code> to <code>4 * 2</code>. In this round of iteration, we mark <code>8</code> as non-prime.</p><pre tabindex=0><code>numbers = [2, 3, *4, 5, *6, 7, *8, *9, 10, 11, 12]
primes = [2, 3]
</code></pre><p>Next, we start from <code>i = 5</code>. Since <code>5</code> is prime, we add it to <code>primes</code>. Then we iterate from <code>5 * 2</code> to <code>5 * 5</code>. In this round of iteration, we mark <code>10</code> as non-prime.</p><pre tabindex=0><code>numbers = [2, 3, *4, 5, *6, 7, *8, *9, *10, 11, 12]
primes = [2, 3, 5]
</code></pre><p>Next, we start from <code>i = 6</code>. Since <code>6</code> is not prime, we will not add it to <code>primes</code>. We iterate from <code>6 * 2</code> to <code>6 * 2</code>. In this round of iteration, we mark <code>12</code> as non-prime.</p><pre tabindex=0><code>numbers = 2, 3, *4, 5, *6, 7, *8, *9, *10, 11, *12
primes = [2, 3, 5]
</code></pre><p>We just do the same thing over and over. For each number, we will only mark it as non-prime once.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>find_primes</span><span class=p>(</span><span class=kt>int</span> <span class=n>n</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>primes</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>vector</span><span class=o>&lt;</span><span class=kt>bool</span><span class=o>&gt;</span> <span class=n>is_prime</span><span class=p>(</span><span class=n>n</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=nb>true</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=n>n</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span> <span class=c1>// i is greatest proper factor
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=p>(</span><span class=n>is_prime</span><span class=p>[</span><span class=n>i</span><span class=p>])</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>primes</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>i</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=nl>prime</span><span class=p>:</span> <span class=n>primes</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>i</span> <span class=o>*</span> <span class=n>prime</span> <span class=o>&gt;</span> <span class=n>n</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=n>is_prime</span><span class=p>[</span><span class=n>i</span> <span class=o>*</span> <span class=n>prime</span><span class=p>]</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>i</span> <span class=o>%</span> <span class=n>prime</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span> <span class=c1>// prime is the smallest prime factor of i
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>primes</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>The time complexity of Euler&rsquo;s sieve is $O(n)$ since we marked each number as non-prime only once. The interesting thing about Euler’s sieve is that it is called Euler’s sieve instead of sieve of Euler.</p></div><footer class=post-footer><ul class=post-tags><li><a href=http://localhost:1313/blog/tags/dsa/>DSA</a></li></ul><nav class=paginav><a class=next href=http://localhost:1313/blog/posts/consistent_hashing/><span class=title>Next »</span><br><span>Consistent Hashing</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=http://localhost:1313/blog/>cwHsueh</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>