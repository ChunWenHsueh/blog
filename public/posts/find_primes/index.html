<!doctype html><html lang=en dir=auto><head><script src="/blog/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=blog/livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>cwHsueh</title>
<meta name=keywords content><meta name=description content="How to find all primes numbers under n?
Sieve of Eratosthenes
This algorithm is a very intuitive way to find all primes under n. We first create a list of numbers from 2 to n and then iterate over the list. For each number, we mark all its multiples as non-prime. At the end, all numbers that are not marked are prime.
vector<int> find_primes(int n) {
    vector<int> primes;
    vector<bool> is_prime(n + 1, true);
    for (int i = 2; i * i <= n; i++) {
        if (is_prime[i]) {
            primes.push_back(i);
            for (int j = i * i; j <= n; j += i) {
                is_prime[j] = false;
            }
        }
    }
    return primes;
}
Let&rsquo;s analyze the time complexity. For each prime number p, we will iterate from p * p to n. Which means that the time complexity is $\sum_{p \text{ is prime}}^{p \leq n} \frac{n}{p} = n\sum_{p \text{ is prime}}^{p \leq n} \frac{1}{p} = n\log\log n$ (prime harmonic series)."><meta name=author content="cwHsueh"><link rel=canonical href=http://localhost:1313/blog/posts/find_primes/><link crossorigin=anonymous href=/blog/assets/css/stylesheet.45e028aa8ce0961349adf411b013ee39406be2c0bc80d4ea3fc04555f7f4611a.css integrity="sha256-ReAoqozglhNJrfQRsBPuOUBr4sC8gNTqP8BFVff0YRo=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/favicon-32x32.png><link rel=apple-touch-icon href=http://localhost:1313/apple-touch-icon.png><link rel=mask-icon href=http://localhost:1313/blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:1313/blog/posts/find_primes/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.css integrity=sha384-zh0CIslj+VczCZtlzBcjt5ppRcsAmDnRem7ESsYwWwg3m/OaJ2l4x7YBZl9Kxxib crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.js integrity=sha384-Rma6DA2IPUwhNxmrB/7S3Tno0YY7sFu9WSYMCuulLhIqYSGZ2gKCJWIqhBWqMQfh crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/contrib/auto-render.min.js integrity=sha384-hCXGrW6PitJEwbkoStFjeJxv+fSOOQKOPbJxSfM6G5sWZjAyWhXiTIIAmQqnlLlh crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script><meta property="og:url" content="http://localhost:1313/blog/posts/find_primes/"><meta property="og:site_name" content="cwHsueh"><meta property="og:title" content="cwHsueh"><meta property="og:description" content="How to find all primes numbers under n? Sieve of Eratosthenes This algorithm is a very intuitive way to find all primes under n. We first create a list of numbers from 2 to n and then iterate over the list. For each number, we mark all its multiples as non-prime. At the end, all numbers that are not marked are prime.
vector<int> find_primes(int n) { vector<int> primes; vector<bool> is_prime(n + 1, true); for (int i = 2; i * i <= n; i++) { if (is_prime[i]) { primes.push_back(i); for (int j = i * i; j <= n; j += i) { is_prime[j] = false; } } } return primes; } Let’s analyze the time complexity. For each prime number p, we will iterate from p * p to n. Which means that the time complexity is $\sum_{p \text{ is prime}}^{p \leq n} \frac{n}{p} = n\sum_{p \text{ is prime}}^{p \leq n} \frac{1}{p} = n\log\log n$ (prime harmonic series)."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta name=twitter:card content="summary"><meta name=twitter:title content><meta name=twitter:description content="How to find all primes numbers under n?
Sieve of Eratosthenes
This algorithm is a very intuitive way to find all primes under n. We first create a list of numbers from 2 to n and then iterate over the list. For each number, we mark all its multiples as non-prime. At the end, all numbers that are not marked are prime.
vector<int> find_primes(int n) {
    vector<int> primes;
    vector<bool> is_prime(n + 1, true);
    for (int i = 2; i * i <= n; i++) {
        if (is_prime[i]) {
            primes.push_back(i);
            for (int j = i * i; j <= n; j += i) {
                is_prime[j] = false;
            }
        }
    }
    return primes;
}
Let&rsquo;s analyze the time complexity. For each prime number p, we will iterate from p * p to n. Which means that the time complexity is $\sum_{p \text{ is prime}}^{p \leq n} \frac{n}{p} = n\sum_{p \text{ is prime}}^{p \leq n} \frac{1}{p} = n\log\log n$ (prime harmonic series)."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:1313/blog/posts/"},{"@type":"ListItem","position":2,"name":"","item":"http://localhost:1313/blog/posts/find_primes/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"","name":"","description":"How to find all primes numbers under n? Sieve of Eratosthenes This algorithm is a very intuitive way to find all primes under n. We first create a list of numbers from 2 to n and then iterate over the list. For each number, we mark all its multiples as non-prime. At the end, all numbers that are not marked are prime.\nvector\u0026lt;int\u0026gt; find_primes(int n) { vector\u0026lt;int\u0026gt; primes; vector\u0026lt;bool\u0026gt; is_prime(n + 1, true); for (int i = 2; i * i \u0026lt;= n; i++) { if (is_prime[i]) { primes.push_back(i); for (int j = i * i; j \u0026lt;= n; j += i) { is_prime[j] = false; } } } return primes; } Let\u0026rsquo;s analyze the time complexity. For each prime number p, we will iterate from p * p to n. Which means that the time complexity is $\\sum_{p \\text{ is prime}}^{p \\leq n} \\frac{n}{p} = n\\sum_{p \\text{ is prime}}^{p \\leq n} \\frac{1}{p} = n\\log\\log n$ (prime harmonic series).\n","keywords":[],"articleBody":"How to find all primes numbers under n? Sieve of Eratosthenes This algorithm is a very intuitive way to find all primes under n. We first create a list of numbers from 2 to n and then iterate over the list. For each number, we mark all its multiples as non-prime. At the end, all numbers that are not marked are prime.\nvector\u003cint\u003e find_primes(int n) { vector\u003cint\u003e primes; vector\u003cbool\u003e is_prime(n + 1, true); for (int i = 2; i * i \u003c= n; i++) { if (is_prime[i]) { primes.push_back(i); for (int j = i * i; j \u003c= n; j += i) { is_prime[j] = false; } } } return primes; } Let’s analyze the time complexity. For each prime number p, we will iterate from p * p to n. Which means that the time complexity is $\\sum_{p \\text{ is prime}}^{p \\leq n} \\frac{n}{p} = n\\sum_{p \\text{ is prime}}^{p \\leq n} \\frac{1}{p} = n\\log\\log n$ (prime harmonic series).\nOf course, the actal time complexity should be better than $n\\log\\log n$. Since we only need to iterate over prime numbers that is smaller or equal to sqrt(n) (for (int i = 2; i * i \u003c= n; i++)). This is sufficient to find all primes under n, since every composite number must have a prime factor that is smaller or equal to sqrt(n). And for each prime number, we actaully start from p * p instead of 2 * p (for (int j = i * i; j \u003c= n; j += i)).\nCan we do better? In this algorithm, for each composite number c, we ran is_prime[c] = false multiple times. Take 12 as an example, is_prime[12] is set to false when i is 2, 3. Is it possible to set is_prime[12] to false only once?\nEuler’s sieve In Euler’s sieve, every composite number is marked to false by its largest proper factor (more accurately, we would mark it to false when it is smallest prime factor * largest proper factor). Proper factor means the factor that is not the number itself. Let’s take a look how can we accomplish this.\nIf we start from k (k can be prime or composite). Instead of iterating from k * k, adding k until it is greater n, we only iterate k * (primes that is \u003c= k). Let’s take a look at an example to understand this.\nIn the following example, n is 12.\nnumbers = 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12\nprimes = []\nWe start from k = 2. Since 2 is prime, we add it to primes. Then we iterate from 2 * 2 to 2 * 2, since 2 is the largest prime that is \u003c= 2. In this round of iteration, we mark 4 as non-prime.\nnumbers = 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12\nprimes = [2]\nNext, we start from k = 3. Since 3 is prime, we add it to primes. Then we iterate from 3 * 2 to 3 * 3. In this round of iteration, we mark 6, 9 as non-prime. The smallest prime factor of 6 is 2 (largest proper factor is 3), and the smallest prime factor of 9 is 3 (largest proper factor is 3).\nnumbers = 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12\nprimes = [2, 3]\nNext, we start from k = 4. Since 4 is not prime, we will not add it to primes. We iterate from 4 * 2 to 4 * 3. In this round of iteration, we mark 8, 12 as non-prime.\nWait! The smallest prime factor of 12 is 2 (largest proper factor is 6), so we should mark 12 as non-prime in the iteration of k = 6. What’s going on here? Since 4 itself is a composite number, this number 4 * 3 (the prime number that is greater than the smallest prime factor of 4) will not be in the form of smallest prime factor * largest proper factor.\nFor a composite number c, let’s say c = p * q, where p is the smallest prime factor of c, and q is the largest proper factor of c. If we have another prime number k that is greater than p, then c * k will not be in the form of smallest prime factor * largest proper factor. If k is smaller or equal to p, then c * k will be in the form of smallest prime factor * largest proper factor, we can mark c * k as non prime. It is not that trivial, you might need to think about it for a while.\nNow, we can modify the way that we iterate. Instead of iterating k * (primes that is \u003c= k), we should iterate k * (primes that is \u003c= smallest prime factor of k).\nIn the round of k = 4, we should only mark 8 as non-prime.\nnumbers = 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12\nprimes = [2, 3]\nNext, we start from k = 5. Since 5 is prime, we add it to primes. Then we iterate from 5 * 2 to 5 * 5. In this round of iteration, we mark 10 as non-prime.\nnumbers = 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12\nprimes = [2, 3, 5]\nNext, we start from k = 6. Since 6 is not prime, we will not add it to primes. We iterate from 6 * 2 to 6 * 2 (since 3 \u003e= 2, the smallest prime factor of 6). In this round of iteration, we mark 12 as non-prime.\nnumbers = 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12\nprimes = [2, 3, 5]\nWe just do the same thing over and over. For each number, we will only mark it as non-prime once.\nvector\u003cint\u003e find_primes(int n) { vector\u003cint\u003e primes; vector\u003cbool\u003e is_prime(n + 1, true); for (int i = 2; i \u003c= n; i++) { // i is largest proper factor if (is_prime[i]) { primes.push_back(i); } for (int prime: primes) { if (i * prime \u003e n) { break; } is_prime[i * prime] = false; if (i % prime == 0) { // prime is the smallest prime factor of i break; } } } return primes; } The time complexity of Euler’s sieve is $O(n)$ since we marked each number as non-prime only once.\n","wordCount":"1081","inLanguage":"en","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","author":{"@type":"Person","name":"cwHsueh"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/blog/posts/find_primes/"},"publisher":{"@type":"Organization","name":"cwHsueh","logo":{"@type":"ImageObject","url":"http://localhost:1313/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/blog/ accesskey=h title="cwHsueh (Alt + H)">cwHsueh</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://cwhsueh.com title=about><span>about</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li><li><a href=http://localhost:1313/blog/leetcode/ title=leetcode><span>leetcode</span></a></li><li><a href=http://localhost:1313/blog/categories/ title=categories><span>categories</span></a></li><li><a href=http://localhost:1313/blog/archives/ title=archive><span>archive</span></a></li><li><a href=http://localhost:1313/blog/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://localhost:1313/blog/>Home</a>&nbsp;»&nbsp;<a href=http://localhost:1313/blog/posts/>Posts</a></div><h1 class="post-title entry-hint-parent"></h1><div class=post-meta>6 min&nbsp;·&nbsp;1081 words&nbsp;·&nbsp;cwHsueh</div></header><div class=post-content><h1 id=how-to-find-all-primes-numbers-under-n>How to find all primes numbers under <code>n</code>?<a hidden class=anchor aria-hidden=true href=#how-to-find-all-primes-numbers-under-n>#</a></h1><h2 id=sieve-of-eratosthenes>Sieve of Eratosthenes<a hidden class=anchor aria-hidden=true href=#sieve-of-eratosthenes>#</a></h2><p>This algorithm is a very intuitive way to find all primes under <code>n</code>. We first create a list of numbers from 2 to <code>n</code> and then iterate over the list. For each number, we mark all its multiples as non-prime. At the end, all numbers that are not marked are prime.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>find_primes</span><span class=p>(</span><span class=kt>int</span> <span class=n>n</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>primes</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>vector</span><span class=o>&lt;</span><span class=kt>bool</span><span class=o>&gt;</span> <span class=n>is_prime</span><span class=p>(</span><span class=n>n</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=nb>true</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span> <span class=n>i</span> <span class=o>*</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=n>n</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>is_prime</span><span class=p>[</span><span class=n>i</span><span class=p>])</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>primes</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>i</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=n>i</span> <span class=o>*</span> <span class=n>i</span><span class=p>;</span> <span class=n>j</span> <span class=o>&lt;=</span> <span class=n>n</span><span class=p>;</span> <span class=n>j</span> <span class=o>+=</span> <span class=n>i</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>is_prime</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>primes</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Let&rsquo;s analyze the time complexity. For each prime number <code>p</code>, we will iterate from <code>p * p</code> to <code>n</code>. Which means that the time complexity is $\sum_{p \text{ is prime}}^{p \leq n} \frac{n}{p} = n\sum_{p \text{ is prime}}^{p \leq n} \frac{1}{p} = n\log\log n$ (prime harmonic series).</p><p>Of course, the actal time complexity should be better than $n\log\log n$. Since we only need to iterate over prime numbers that is smaller or equal to sqrt(n) (<code>for (int i = 2; i * i &lt;= n; i++)</code>). This is sufficient to find all primes under <code>n</code>, since every composite number must have a prime factor that is smaller or equal to sqrt(n). And for each prime number, we actaully start from <code>p * p</code> instead of <code>2 * p</code> (<code>for (int j = i * i; j &lt;= n; j += i)</code>).</p><p>Can we do better? In this algorithm, for each composite number <code>c</code>, we ran <code>is_prime[c] = false</code> multiple times. Take <code>12</code> as an example, <code>is_prime[12]</code> is set to false when <code>i</code> is <code>2, 3</code>. Is it possible to set <code>is_prime[12]</code> to false only once?</p><h2 id=eulers-sieve>Euler&rsquo;s sieve<a hidden class=anchor aria-hidden=true href=#eulers-sieve>#</a></h2><p>In Euler&rsquo;s sieve, every composite number is marked to false by its largest proper factor (more accurately, we would mark it to false when it is <code>smallest prime factor * largest proper factor</code>). Proper factor means the factor that is not the number itself. Let&rsquo;s take a look how can we accomplish this.</p><p>If we start from <code>k</code> (<code>k</code> can be prime or composite). Instead of iterating from <code>k * k</code>, adding <code>k</code> until it is greater <code>n</code>, we only iterate <code>k * (primes that is &lt;= k)</code>. Let&rsquo;s take a look at an example to understand this.</p><p>In the following example, <code>n</code> is <code>12</code>.</p><p>numbers = 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12</p><p>primes = []</p><p>We start from <code>k = 2</code>. Since <code>2</code> is prime, we add it to <code>primes</code>. Then we iterate from <code>2 * 2</code> to <code>2 * 2</code>, since <code>2</code> is the largest prime that is &lt;= <code>2</code>. In this round of iteration, we mark <code>4</code> as non-prime.</p><p>numbers = 2, 3, <del>4</del>, 5, 6, 7, 8, 9, 10, 11, 12</p><p>primes = [2]</p><p>Next, we start from <code>k = 3</code>. Since <code>3</code> is prime, we add it to <code>primes</code>. Then we iterate from <code>3 * 2</code> to <code>3 * 3</code>. In this round of iteration, we mark <code>6, 9</code> as non-prime. The smallest prime factor of <code>6</code> is <code>2</code> (largest proper factor is <code>3</code>), and the smallest prime factor of <code>9</code> is <code>3</code> (largest proper factor is <code>3</code>).</p><p>numbers = 2, 3, <del>4</del>, 5, <del>6</del>, 7, 8, <del>9</del>, 10, 11, 12</p><p>primes = [2, 3]</p><p>Next, we start from <code>k = 4</code>. Since <code>4</code> is not prime, we will not add it to <code>primes</code>. We iterate from <code>4 * 2</code> to <code>4 * 3</code>. In this round of iteration, we mark <code>8, 12</code> as non-prime.</p><p>Wait! The smallest prime factor of <code>12</code> is <code>2</code> (largest proper factor is <code>6</code>), so we should mark <code>12</code> as non-prime in the iteration of <code>k = 6</code>. What&rsquo;s going on here? Since <code>4</code> itself is a composite number, this number <code>4 * 3 (the prime number that is greater than the smallest prime factor of 4)</code> will not be in the form of <code>smallest prime factor * largest proper factor</code>.</p><p>For a composite number <code>c</code>, let&rsquo;s say <code>c = p * q</code>, where <code>p</code> is the smallest prime factor of <code>c</code>, and <code>q</code> is the largest proper factor of <code>c</code>. If we have another prime number <code>k</code> that is greater than <code>p</code>, then <code>c * k</code> will not be in the form of <code>smallest prime factor * largest proper factor</code>. If <code>k</code> is smaller or equal to <code>p</code>, then <code>c * k</code> will be in the form of <code>smallest prime factor * largest proper factor</code>, we can mark <code>c * k</code> as non prime. It is not that trivial, you might need to think about it for a while.</p><p>Now, we can modify the way that we iterate. Instead of iterating <code>k * (primes that is &lt;= k)</code>, we should iterate <code>k * (primes that is &lt;= smallest prime factor of k)</code>.</p><p>In the round of <code>k = 4</code>, we should only mark <code>8</code> as non-prime.</p><p>numbers = 2, 3, <del>4</del>, 5, <del>6</del>, 7, <del>8</del>, <del>9</del>, 10, 11, 12</p><p>primes = [2, 3]</p><p>Next, we start from <code>k = 5</code>. Since <code>5</code> is prime, we add it to <code>primes</code>. Then we iterate from <code>5 * 2</code> to <code>5 * 5</code>. In this round of iteration, we mark <code>10</code> as non-prime.</p><p>numbers = 2, 3, <del>4</del>, 5, <del>6</del>, 7, <del>8</del>, <del>9</del>, <del>10</del>, 11, 12</p><p>primes = [2, 3, 5]</p><p>Next, we start from <code>k = 6</code>. Since <code>6</code> is not prime, we will not add it to <code>primes</code>. We iterate from <code>6 * 2</code> to <code>6 * 2</code> (since <code>3 >= 2</code>, the smallest prime factor of <code>6</code>). In this round of iteration, we mark <code>12</code> as non-prime.</p><p>numbers = 2, 3, <del>4</del>, 5, <del>6</del>, 7, <del>8</del>, <del>9</del>, <del>10</del>, 11, <del>12</del></p><p>primes = [2, 3, 5]</p><p>We just do the same thing over and over. For each number, we will only mark it as non-prime once.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>find_primes</span><span class=p>(</span><span class=kt>int</span> <span class=n>n</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>primes</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>vector</span><span class=o>&lt;</span><span class=kt>bool</span><span class=o>&gt;</span> <span class=n>is_prime</span><span class=p>(</span><span class=n>n</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=nb>true</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=n>n</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span> <span class=c1>// i is largest proper factor
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=p>(</span><span class=n>is_prime</span><span class=p>[</span><span class=n>i</span><span class=p>])</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>primes</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>i</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=nl>prime</span><span class=p>:</span> <span class=n>primes</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>i</span> <span class=o>*</span> <span class=n>prime</span> <span class=o>&gt;</span> <span class=n>n</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=n>is_prime</span><span class=p>[</span><span class=n>i</span> <span class=o>*</span> <span class=n>prime</span><span class=p>]</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>i</span> <span class=o>%</span> <span class=n>prime</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span> <span class=c1>// prime is the smallest prime factor of i
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>primes</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The time complexity of Euler&rsquo;s sieve is $O(n)$ since we marked each number as non-prime only once.</p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=http://localhost:1313/blog/posts/c++-set-erase/><span class=title>« Prev</span><br><span>C++ 中遍歷 set 的同時刪除元素</span>
</a><a class=next href=http://localhost:1313/blog/posts/consistent_hashing/consistent_hashing/><span class=title>Next »</span><br><span>Consistent Hashing</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=http://localhost:1313/blog/>cwHsueh</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>