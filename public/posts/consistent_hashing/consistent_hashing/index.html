<!doctype html><html lang=en dir=auto><head><script src="/blog/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=blog/livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Consistent Hashing | cwHsueh</title>
<meta name=keywords content="distributed systems"><meta name=description content="This is a note of this paragraph.
Problem Statement
Given a set of servers, we need to distribute the load among them. The load can be anything like requests, data, etc. The goal is to minimize the number of reassignments when a server is added or removed. Also notice that the data on each server might not be the same.
First intuition
One way to distribute the load is to use a hash function to map the load to a server. The hash function can be as simple as taking the modulo of the hash of the load with the number of servers. This approach works well when the number of servers is fixed."><meta name=author content="cwHsueh"><link rel=canonical href=http://localhost:1313/blog/posts/consistent_hashing/consistent_hashing/><link crossorigin=anonymous href=/blog/assets/css/stylesheet.45e028aa8ce0961349adf411b013ee39406be2c0bc80d4ea3fc04555f7f4611a.css integrity="sha256-ReAoqozglhNJrfQRsBPuOUBr4sC8gNTqP8BFVff0YRo=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/favicon-32x32.png><link rel=apple-touch-icon href=http://localhost:1313/apple-touch-icon.png><link rel=mask-icon href=http://localhost:1313/blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:1313/blog/posts/consistent_hashing/consistent_hashing/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.css integrity=sha384-zh0CIslj+VczCZtlzBcjt5ppRcsAmDnRem7ESsYwWwg3m/OaJ2l4x7YBZl9Kxxib crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.js integrity=sha384-Rma6DA2IPUwhNxmrB/7S3Tno0YY7sFu9WSYMCuulLhIqYSGZ2gKCJWIqhBWqMQfh crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/contrib/auto-render.min.js integrity=sha384-hCXGrW6PitJEwbkoStFjeJxv+fSOOQKOPbJxSfM6G5sWZjAyWhXiTIIAmQqnlLlh crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script><meta property="og:url" content="http://localhost:1313/blog/posts/consistent_hashing/consistent_hashing/"><meta property="og:site_name" content="cwHsueh"><meta property="og:title" content="Consistent Hashing"><meta property="og:description" content="This is a note of this paragraph.
Problem Statement Given a set of servers, we need to distribute the load among them. The load can be anything like requests, data, etc. The goal is to minimize the number of reassignments when a server is added or removed. Also notice that the data on each server might not be the same.
First intuition One way to distribute the load is to use a hash function to map the load to a server. The hash function can be as simple as taking the modulo of the hash of the load with the number of servers. This approach works well when the number of servers is fixed."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:tag" content="Distributed Systems"><meta name=twitter:card content="summary"><meta name=twitter:title content="Consistent Hashing"><meta name=twitter:description content="This is a note of this paragraph.
Problem Statement
Given a set of servers, we need to distribute the load among them. The load can be anything like requests, data, etc. The goal is to minimize the number of reassignments when a server is added or removed. Also notice that the data on each server might not be the same.
First intuition
One way to distribute the load is to use a hash function to map the load to a server. The hash function can be as simple as taking the modulo of the hash of the load with the number of servers. This approach works well when the number of servers is fixed."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:1313/blog/posts/"},{"@type":"ListItem","position":2,"name":"Consistent Hashing","item":"http://localhost:1313/blog/posts/consistent_hashing/consistent_hashing/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Consistent Hashing","name":"Consistent Hashing","description":"This is a note of this paragraph.\nProblem Statement Given a set of servers, we need to distribute the load among them. The load can be anything like requests, data, etc. The goal is to minimize the number of reassignments when a server is added or removed. Also notice that the data on each server might not be the same.\nFirst intuition One way to distribute the load is to use a hash function to map the load to a server. The hash function can be as simple as taking the modulo of the hash of the load with the number of servers. This approach works well when the number of servers is fixed.\n","keywords":["distributed systems"],"articleBody":"This is a note of this paragraph.\nProblem Statement Given a set of servers, we need to distribute the load among them. The load can be anything like requests, data, etc. The goal is to minimize the number of reassignments when a server is added or removed. Also notice that the data on each server might not be the same.\nFirst intuition One way to distribute the load is to use a hash function to map the load to a server. The hash function can be as simple as taking the modulo of the hash of the load with the number of servers. This approach works well when the number of servers is fixed.\nFor example, if we have 3 servers numbered from 0 to 2 and 3 requests with hash value 1, 2, and 3, we can assign the requests to servers 1 (1 % 3), 2 (2 % 3), and 0 (3 % 3)respectively.\nHowever, when a server is added or removed, the data needs to be reassigned to different servers. This is not ideal since it can lead to a lot of reassignments.\nFor example, if we added a server, now the same 3 requests will be assigned to servers 1 (1 % 4), 2 (2 % 4), and 3 (3 % 4) respectively. The first two requests are assigned to the same servers as before, but the third request is assigned to a different server. This means the data needs to be moved from server 0 to server 3.\nWhat is Consistent Hashing? In our first intuition, we used a hash function to map the load to a server. Consistent hashing is a technique that uses a hash function to map the load and the server to a circle. The circle is represented by a ring where the servers are placed at different points on the ring. The load is then mapped to the server that is closest to it in the clockwise direction.\nThere are 2^32 points on the ring. We map servers and requests to points on the ring using a hash function. In the above example, we have 3 servers and 3 requests. The requests r0 and r1 will we mapped to server s1, and request r2 will be mapped to server s0.\nHowever, this design still has problems.\nThe servers are not uniformly distributed on the ring. This can lead to hotspots where a lot of requests are assigned to the same server. In the above example, the requests that are mapped between s2 and s1 will all go to s2. Which means server s1 will have more requests than s0 and s2, since there are more points between s2 and s1.\nEven if the servers are uniformly distributed, when we add or remove a server, it still might cause some servers to handle significantly more requests than others. Letâ€™s say servers are uniformly distributed clockwise on the ring, when we remove one of the server, the next server that is closest to the removed server will take all the requests that were assigned to the removed server. Making it accept twice as many requests as the other servers.\nVirtual Nodes We can fix this with virtula nodes. Create multiple virtual nodes for each server and place them on the ring. This way, the servers are more uniformly distributed on the ring.\nIn the above example, we create three virtual nodes for each server. The request that mapped to s0-0, s0-1, or s0-2 will we remapped to the true server s0. This way, the requests are more evenly distributed among the servers, and even if we add or remove a server, the load will be evenly distributed to other servers.\n","wordCount":"618","inLanguage":"en","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","author":{"@type":"Person","name":"cwHsueh"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/blog/posts/consistent_hashing/consistent_hashing/"},"publisher":{"@type":"Organization","name":"cwHsueh","logo":{"@type":"ImageObject","url":"http://localhost:1313/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/blog/ accesskey=h title="cwHsueh (Alt + H)">cwHsueh</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://cwhsueh.com title=about><span>about</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li><li><a href=http://localhost:1313/blog/leetcode/ title=leetcode><span>leetcode</span></a></li><li><a href=http://localhost:1313/blog/categories/ title=categories><span>categories</span></a></li><li><a href=http://localhost:1313/blog/archives/ title=archive><span>archive</span></a></li><li><a href=http://localhost:1313/blog/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://localhost:1313/blog/>Home</a>&nbsp;Â»&nbsp;<a href=http://localhost:1313/blog/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Consistent Hashing</h1><div class=post-meta>3 min&nbsp;Â·&nbsp;618 words&nbsp;Â·&nbsp;cwHsueh</div></header><div class=post-content><p>This is a note of this <a href=https://xiaolincoding.com/os/8_network_system/hash.html>paragraph</a>.</p><h1 id=problem-statement>Problem Statement<a hidden class=anchor aria-hidden=true href=#problem-statement>#</a></h1><p>Given a set of servers, we need to distribute the load among them. The load can be anything like requests, data, etc. The goal is to minimize the number of reassignments when a server is added or removed. Also notice that the data on each server might not be the same.</p><h1 id=first-intuition>First intuition<a hidden class=anchor aria-hidden=true href=#first-intuition>#</a></h1><p>One way to distribute the load is to use a hash function to map the load to a server. The hash function can be as simple as taking the modulo of the hash of the load with the number of servers. This approach works well when the number of servers is fixed.</p><p>For example, if we have 3 servers numbered from 0 to 2 and 3 requests with hash value 1, 2, and 3, we can assign the requests to servers 1 (1 % 3), 2 (2 % 3), and 0 (3 % 3)respectively.</p><p>However, when a server is added or removed, the data needs to be reassigned to different servers. This is not ideal since it can lead to a lot of reassignments.</p><p>For example, if we added a server, now the same 3 requests will be assigned to servers 1 (1 % 4), 2 (2 % 4), and 3 (3 % 4) respectively. The first two requests are assigned to the same servers as before, but the third request is assigned to a different server. This means the data needs to be moved from server 0 to server 3.</p><h1 id=what-is-consistent-hashing>What is Consistent Hashing?<a hidden class=anchor aria-hidden=true href=#what-is-consistent-hashing>#</a></h1><p>In our first intuition, we used a hash function to map the load to a server. Consistent hashing is a technique that uses a hash function to map the load and the server to a circle. The circle is represented by a ring where the servers are placed at different points on the ring. The load is then mapped to the server that is closest to it in the clockwise direction.</p><p><img alt=Ring loading=lazy src=/Consistent_hashing/ring01.svg></p><p>There are 2^32 points on the ring. We map servers and requests to points on the ring using a hash function. In the above example, we have 3 servers and 3 requests. The requests <code>r0</code> and <code>r1</code> will we mapped to server <code>s1</code>, and request <code>r2</code> will be mapped to server <code>s0</code>.</p><p>However, this design still has problems.</p><ol><li>The servers are not uniformly distributed on the ring. This can lead to hotspots where a lot of requests are assigned to the same server.</li></ol><p>In the above example, the requests that are mapped between <code>s2</code> and <code>s1</code> will all go to <code>s2</code>. Which means server <code>s1</code> will have more requests than <code>s0</code> and <code>s2</code>, since there are more points between <code>s2</code> and <code>s1</code>.</p><ol start=2><li>Even if the servers are uniformly distributed, when we add or remove a server, it still might cause some servers to handle significantly more requests than others.</li></ol><p>Let&rsquo;s say servers are uniformly distributed clockwise on the ring, when we remove one of the server, the next server that is closest to the removed server will take all the requests that were assigned to the removed server. Making it accept twice as many requests as the other servers.</p><h1 id=virtual-nodes>Virtual Nodes<a hidden class=anchor aria-hidden=true href=#virtual-nodes>#</a></h1><p>We can fix this with virtula nodes. Create multiple virtual nodes for each server and place them on the ring. This way, the servers are more uniformly distributed on the ring.</p><p><img alt=Ring loading=lazy src=/Consistent_hashing/ring02.svg></p><p>In the above example, we create three virtual nodes for each server. The request that mapped to <code>s0-0</code>, <code>s0-1</code>, or <code>s0-2</code> will we remapped to the true server <code>s0</code>. This way, the requests are more evenly distributed among the servers, and even if we add or remove a server, the load will be evenly distributed to other servers.</p></div><footer class=post-footer><ul class=post-tags><li><a href=http://localhost:1313/blog/tags/distributed-systems/>Distributed Systems</a></li></ul><nav class=paginav><a class=prev href=http://localhost:1313/blog/posts/find_primes/find_primes/><span class=title>Â« Prev</span><br><span></span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=http://localhost:1313/blog/>cwHsueh</a></span> Â·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>