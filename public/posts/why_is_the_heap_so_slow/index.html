<!doctype html><html lang=en dir=auto><head><script src="/blog/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=blog/livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Why is the heap so slow? | cwHsueh</title>
<meta name=keywords content="OS"><meta name=description content="This is a note from WHY IS THE HEAP SO SLOW?
System Calls
System calls are the apis provided by the operating system and we use them to request some service which only the operating system can do. System calls can be expensive in terms of performance.
When a program is executed, it receives a new name, a process. A process has its own state stored in CPU through register.
"><meta name=author content="cwHsueh"><link rel=canonical href=http://localhost:1313/blog/posts/why_is_the_heap_so_slow/><link crossorigin=anonymous href=/blog/assets/css/stylesheet.45e028aa8ce0961349adf411b013ee39406be2c0bc80d4ea3fc04555f7f4611a.css integrity="sha256-ReAoqozglhNJrfQRsBPuOUBr4sC8gNTqP8BFVff0YRo=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/favicon-32x32.png><link rel=apple-touch-icon href=http://localhost:1313/apple-touch-icon.png><link rel=mask-icon href=http://localhost:1313/blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:1313/blog/posts/why_is_the_heap_so_slow/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.css integrity=sha384-zh0CIslj+VczCZtlzBcjt5ppRcsAmDnRem7ESsYwWwg3m/OaJ2l4x7YBZl9Kxxib crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.js integrity=sha384-Rma6DA2IPUwhNxmrB/7S3Tno0YY7sFu9WSYMCuulLhIqYSGZ2gKCJWIqhBWqMQfh crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/contrib/auto-render.min.js integrity=sha384-hCXGrW6PitJEwbkoStFjeJxv+fSOOQKOPbJxSfM6G5sWZjAyWhXiTIIAmQqnlLlh crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script><meta property="og:url" content="http://localhost:1313/blog/posts/why_is_the_heap_so_slow/"><meta property="og:site_name" content="cwHsueh"><meta property="og:title" content="Why is the heap so slow?"><meta property="og:description" content="This is a note from WHY IS THE HEAP SO SLOW?
System Calls System calls are the apis provided by the operating system and we use them to request some service which only the operating system can do. System calls can be expensive in terms of performance.
When a program is executed, it receives a new name, a process. A process has its own state stored in CPU through register."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-10-30T23:58:55-07:00"><meta property="article:modified_time" content="2024-10-30T23:58:55-07:00"><meta property="article:tag" content="OS"><meta name=twitter:card content="summary"><meta name=twitter:title content="Why is the heap so slow?"><meta name=twitter:description content="This is a note from WHY IS THE HEAP SO SLOW?
System Calls
System calls are the apis provided by the operating system and we use them to request some service which only the operating system can do. System calls can be expensive in terms of performance.
When a program is executed, it receives a new name, a process. A process has its own state stored in CPU through register.
"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:1313/blog/posts/"},{"@type":"ListItem","position":2,"name":"Why is the heap so slow?","item":"http://localhost:1313/blog/posts/why_is_the_heap_so_slow/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Why is the heap so slow?","name":"Why is the heap so slow?","description":"This is a note from WHY IS THE HEAP SO SLOW?\nSystem Calls System calls are the apis provided by the operating system and we use them to request some service which only the operating system can do. System calls can be expensive in terms of performance.\nWhen a program is executed, it receives a new name, a process. A process has its own state stored in CPU through register.\n","keywords":["OS"],"articleBody":"This is a note from WHY IS THE HEAP SO SLOW?\nSystem Calls System calls are the apis provided by the operating system and we use them to request some service which only the operating system can do. System calls can be expensive in terms of performance.\nWhen a program is executed, it receives a new name, a process. A process has its own state stored in CPU through register.\nWhen the process makes a system call, the OS needs to use the CPU to serve the request. However, it cannot use the CPU directly, since it has the state of our process. OS will take a snapshot of the state and put it into the memory. Then restore it after execution of the request. Such behavior is called context switch, and context switch takes time and resources.\nMemory Layout The issue with the heap is that its hard to avoid memory fragmentation, and when memory fragmentation occurs, we need system calls to request for another chunk of memory.\nFor example, a server that can receive images from users and return black and white filter of the image to the users, and it is designed to handle multiple clients concurrently.\nWhen the server receives images, it spawns threads for each image. Smaller images are processed more quickly, and as soon as these smaller images are processed, the memory for these images are no longer needed, causing fragmentation on the heap.\nWhen we need to store more data in the heap, to avoid system calls, there are different ways to utilize the heap.\nFirst fit: choose the first hole that is large enough to accommodate our value Best fit: choose the smallest hole that is still large enough for our value Worst fit: choose the largest available hole where our value can fit Conclusion Pros\nDynamic size Large memory allocations Fast accessing times if used correctly Cons\nPerformance penalties Allocations require searching available sub-regions within the heap Allocation may require a System Call Runtime errors Memory leaks Null pointers dereferences Dangling pointers The heap itself is actually not slow, we say its slow because of the whole process of allocatiing memory is slow. If heap is allocated properly, it is as fast as stack, since they are both in the ram.\n","wordCount":"380","inLanguage":"en","datePublished":"2024-10-30T23:58:55-07:00","dateModified":"2024-10-30T23:58:55-07:00","author":{"@type":"Person","name":"cwHsueh"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/blog/posts/why_is_the_heap_so_slow/"},"publisher":{"@type":"Organization","name":"cwHsueh","logo":{"@type":"ImageObject","url":"http://localhost:1313/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/blog/ accesskey=h title="cwHsueh (Alt + H)">cwHsueh</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://cwhsueh.com title=about><span>about</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li><li><a href=http://localhost:1313/blog/leetcode/ title=leetcode><span>leetcode</span></a></li><li><a href=http://localhost:1313/blog/tags/ title=tags><span>tags</span></a></li><li><a href=http://localhost:1313/blog/archives/ title=archive><span>archive</span></a></li><li><a href=http://localhost:1313/blog/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://localhost:1313/blog/>Home</a>&nbsp;»&nbsp;<a href=http://localhost:1313/blog/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Why is the heap so slow?</h1><div class=post-meta><span title='2024-10-30 23:58:55 -0700 PDT'>October 30, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;380 words&nbsp;·&nbsp;cwHsueh</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#system-calls aria-label="System Calls">System Calls</a></li><li><a href=#memory-layout aria-label="Memory Layout">Memory Layout</a></li><li><a href=#conclusion aria-label=Conclusion>Conclusion</a></li></ul></div></details></div><div class=post-content><p>This is a note from <a href=https://youtu.be/ioJkA7Mw2-U>WHY IS THE HEAP SO SLOW?</a></p><h2 id=system-calls>System Calls<a hidden class=anchor aria-hidden=true href=#system-calls>#</a></h2><p>System calls are the apis provided by the operating system and we use them to request some service which only the operating system can do. System calls can be expensive in terms of performance.</p><p>When a program is executed, it receives a new name, a process. A process has its own state stored in CPU through register.</p><p><img alt=register loading=lazy src=/blog/posts/why_is_the_heap_so_slow/3-36.png></p><p>When the process makes a system call, the OS needs to use the CPU to serve the request. However, it cannot use the CPU directly, since it has the state of our process. OS will take a snapshot of the state and put it into the memory. Then restore it after execution of the request. Such behavior is called context switch, and context switch takes time and resources.</p><p><img alt="context switch" loading=lazy src=/blog/posts/why_is_the_heap_so_slow/4-41.png></p><h2 id=memory-layout>Memory Layout<a hidden class=anchor aria-hidden=true href=#memory-layout>#</a></h2><p>The issue with the heap is that its hard to avoid memory fragmentation, and when memory fragmentation occurs, we need system calls to request for another chunk of memory.</p><p>For example, a server that can receive images from users and return black and white filter of the image to the users, and it is designed to handle multiple clients concurrently.</p><p>When the server receives images, it spawns threads for each image. Smaller images are processed more quickly, and as soon as these smaller images are processed, the memory for these images are no longer needed, causing fragmentation on the heap.</p><p><img alt=server loading=lazy src=/blog/posts/why_is_the_heap_so_slow/11-9.png></p><p>When we need to store more data in the heap, to avoid system calls, there are different ways to utilize the heap.</p><p><img alt=fitting loading=lazy src=/blog/posts/why_is_the_heap_so_slow/12-13.png></p><ul><li>First fit: choose the first hole that is large enough to accommodate our value</li><li>Best fit: choose the smallest hole that is still large enough for our value</li><li>Worst fit: choose the largest available hole where our
value can fit</li></ul><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><ul><li><p>Pros</p><ul><li>Dynamic size</li><li>Large memory allocations</li><li>Fast accessing times if used correctly</li></ul></li><li><p>Cons</p><ul><li>Performance penalties<ul><li>Allocations require searching available sub-regions within the heap</li><li>Allocation may require a System Call</li></ul></li><li>Runtime errors<ul><li>Memory leaks</li><li>Null pointers dereferences</li><li>Dangling pointers</li></ul></li></ul></li></ul><p>The heap itself is actually not slow, we say its slow because of the whole process of allocatiing memory is slow. If heap is allocated properly, it is as fast as stack, since they are both in the ram.</p></div><footer class=post-footer><ul class=post-tags><li><a href=http://localhost:1313/blog/tags/os/>OS</a></li></ul><nav class=paginav><a class=prev href=http://localhost:1313/blog/posts/makefile/><span class=title>« Prev</span><br><span>Introduction to Makefile</span>
</a><a class=next href=http://localhost:1313/blog/posts/c++-primer-plus/><span class=title>Next »</span><br><span>C++ Primer Plus notes</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=http://localhost:1313/blog/>cwHsueh</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>