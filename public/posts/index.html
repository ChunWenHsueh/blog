<!doctype html><html lang=en dir=auto><head><script src="/blog/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=blog/livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | cwHsueh</title>
<meta name=keywords content><meta name=description content="Posts - cwHsueh"><meta name=author content="cwHsueh"><link rel=canonical href=http://localhost:1313/blog/posts/><link crossorigin=anonymous href=/blog/assets/css/stylesheet.45e028aa8ce0961349adf411b013ee39406be2c0bc80d4ea3fc04555f7f4611a.css integrity="sha256-ReAoqozglhNJrfQRsBPuOUBr4sC8gNTqP8BFVff0YRo=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/favicon-32x32.png><link rel=apple-touch-icon href=http://localhost:1313/apple-touch-icon.png><link rel=mask-icon href=http://localhost:1313/blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=http://localhost:1313/blog/posts/index.xml><link rel=alternate hreflang=en href=http://localhost:1313/blog/posts/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.css integrity=sha384-zh0CIslj+VczCZtlzBcjt5ppRcsAmDnRem7ESsYwWwg3m/OaJ2l4x7YBZl9Kxxib crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.js integrity=sha384-Rma6DA2IPUwhNxmrB/7S3Tno0YY7sFu9WSYMCuulLhIqYSGZ2gKCJWIqhBWqMQfh crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/contrib/auto-render.min.js integrity=sha384-hCXGrW6PitJEwbkoStFjeJxv+fSOOQKOPbJxSfM6G5sWZjAyWhXiTIIAmQqnlLlh crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script><meta property="og:url" content="http://localhost:1313/blog/posts/"><meta property="og:site_name" content="cwHsueh"><meta property="og:title" content="Posts"><meta property="og:description" content="cwHsueh's blog"><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="Posts"><meta name=twitter:description content="cwHsueh's blog"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:1313/blog/posts/"}]}</script></head><body class="list dark" id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/blog/ accesskey=h title="cwHsueh (Alt + H)">cwHsueh</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://cwhsueh.com title=about><span>about</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li><li><a href=http://localhost:1313/blog/leetcode/ title=leetcode><span>leetcode</span></a></li><li><a href=http://localhost:1313/blog/tags/ title=tags><span>tags</span></a></li><li><a href=http://localhost:1313/blog/archives/ title=archive><span>archive</span></a></li><li><a href=http://localhost:1313/blog/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=http://localhost:1313/blog/>Home</a></div><h1>Posts</h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Prime Sieves</h2></header><div class=entry-content><p>How to find all primes under n? Sieve of Eratosthenes This algorithm is a very intuitive way to find all primes under n. We first create a list of numbers from 2 to n and then iterate over the list. For each number i, we mark all its multiples as non-prime. At the end, all numbers that are not marked are prime.
1 2 3 4 5 6 7 8 9 10 11 12 13 vector&lt;int> find_primes(int n) { vector&lt;int> primes; vector&lt;bool> is_prime(n + 1, true); for (int i = 2; i * i &lt;= n; i++) { if (is_prime[i]) { primes.push_back(i); for (int j = i * i; j &lt;= n; j += i) { is_prime[j] = false; } } } return primes; } Let’s analyze the time complexity. For each prime number p, we will iterate from p * p to n. Which means that the time complexity is $\sum_{p \text{ is prime}}^{p \leq n} \frac{n}{p} = n\sum_{p \text{ is prime}}^{p \leq n} \frac{1}{p} = n\log\log n$ (prime harmonic series).
...</p></div><footer class=entry-footer><span title='2025-02-18 00:00:00 -0700 -0700'>February 18, 2025</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;1081 words&nbsp;·&nbsp;cwHsueh</footer><a class=entry-link aria-label="post link to Prime Sieves" href=http://localhost:1313/blog/posts/prime_sieves/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Consistent Hashing</h2></header><div class=entry-content><p>This is a note of this paragraph.
Problem Statement Given a set of servers, we need to distribute the load among them. The load can be anything like requests, data, etc. The goal is to minimize the number of reassignments when a server is added or removed. Also notice that the data on each server might not be the same.
First intuition One way to distribute the load is to use a hash function to map the load to a server.
...</p></div><footer class=entry-footer><span title='2025-02-05 00:00:00 -0700 -0700'>February 5, 2025</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;605 words&nbsp;·&nbsp;cwHsueh</footer><a class=entry-link aria-label="post link to Consistent Hashing" href=http://localhost:1313/blog/posts/consistent_hashing/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Introduction to Makefile</h2></header><div class=entry-content><p>Why make? Make is a build automation tool that automatically builds executable programs and libraries from source code by reading files called Makefiles, which specify how to derive the target program. It avoids the need to manually type everything out every time you want to compile your code.
Syntax Make has the following syntax:
target: dependencies command For example, if you have a file called hello.c and you want to compile it into an executable called hello, you can write a Makefile like this:
...</p></div><footer class=entry-footer><span title='2025-02-04 23:58:55 -0700 -0700'>February 4, 2025</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;545 words&nbsp;·&nbsp;cwHsueh</footer><a class=entry-link aria-label="post link to Introduction to Makefile" href=http://localhost:1313/blog/posts/makefile/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Why is the heap so slow?</h2></header><div class=entry-content><p>This is a note from WHY IS THE HEAP SO SLOW?
System Calls System calls are the apis provided by the operating system and we use them to request some service which only the operating system can do. System calls can be expensive in terms of performance.
When a program is executed, it receives a new name, a process. A process has its own state stored in CPU through register.
...</p></div><footer class=entry-footer><span title='2024-10-30 23:58:55 -0700 PDT'>October 30, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;380 words&nbsp;·&nbsp;cwHsueh</footer><a class=entry-link aria-label="post link to Why is the heap so slow?" href=http://localhost:1313/blog/posts/why_is_the_heap_so_slow/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>C++ Primer Plus notes</h2></header><div class=entry-content><p>Chapter 4 Union union is a data structure that can store different types of data, but it can only store one type of data at a time. The size of union is the size of its largest data.
union one4all { int int_val; long long_val; double double_val; }; one4all pail; pail.int_val = 15; // store an int cout &lt;&lt; pail.int_val; pail.double_val = 1.38; // store a double, int value is lost cout &lt;&lt; pail.double_val; Enumerations enum spectrum {red, orange, yellow, green, blue, violet, indigo, ultraviolet}; spectrum band; // band a variable of type spectrum band = blue; // valid, blue is an enumerator band = 2000; // invalid, 2000 not an enumerator Enumarators are integer type, and can be converted to int, but not reversely.
...</p></div><footer class=entry-footer><span title='2024-01-05 12:00:00 +0800 +0800'>January 5, 2024</span>&nbsp;·&nbsp;54 min&nbsp;·&nbsp;11385 words&nbsp;·&nbsp;cwHsueh</footer><a class=entry-link aria-label="post link to C++ Primer Plus notes" href=http://localhost:1313/blog/posts/c++-primer-plus/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>C++ notes</h2></header><div class=entry-content><p>這篇文章主要是給自己看的，因此寫的方法是以自己看懂為主，一些自己已經會的東西就不會寫得太詳細。
Source Code to Machine Code source code to machine code 分成四個步驟：
preprocessing 處理 #，例如 #include 把 header file 複製到當前的檔案裡面 compiling turn code into assembly assembling turn assembly into machine code, 0s and 1s linking 把不同檔案的 machine code 接在一起 雖然說有四個步驟，但是其實會把這四個步驟叫做 compiling。
Command Line Arguments int main(int argc, char *argv[]){ } int main(int argc, char **argv){ } 如果有一個 binary file 叫做 greet，並且在 terminal 輸入 ./greet Hello，此時 argc = 2, argv[0] = "./greet", argv[1] = "Hello"。
echo $? 會回傳來自 main funciton 的 int，也就是 error code。
...</p></div><footer class=entry-footer><span title='2023-12-25 20:00:00 +0800 +0800'>December 25, 2023</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;768 words&nbsp;·&nbsp;cwHsueh</footer><a class=entry-link aria-label="post link to C++ notes" href=http://localhost:1313/blog/posts/c++-notes/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Majority Voting Algorithm 多數投票算法</h2></header><div class=entry-content><p>問題描述
給定一個大小為 n 的整數陣列，如何找到出現頻率大於（必須嚴格大於）n/2 的元素？
例如：arr = [1, 1, 2]，那麼 1 就是出現頻率大於 n/2 的元素。
如果 arr = [1, 1, 3, 4]，那麼不存在這樣的元素。
Boyer–Moore majority vote algorithm
一個很直覺的方法就是用一個 hash map 計算所有數字出現的頻率，然後找出出現最多次的元素。需要 O(n) 的空間複雜度以及 O(n) 的時間複雜度。但是用 Boyer-Moore algorithm，只要 O(1) 的空間複雜度即可。來看看這個演算法是如何辦到的。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 int majorityElement(vector&lt;int>& nums) { int candidate = 0; int freq = 0; for (int i = 0; i &lt; nums.size(); i++){ if (candidate == nums[i]){ freq++; } else if (freq == 0){ candidate = nums[i]; freq = 1; } else { freq--; } } return candidate; } candidate 是答案的候選人，而 freq 則是 candidate 出現的頻率。
...</p></div><footer class=entry-footer><span title='2023-11-07 12:00:00 +0800 +0800'>November 7, 2023</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;443 words&nbsp;·&nbsp;cwHsueh</footer><a class=entry-link aria-label="post link to Majority Voting Algorithm 多數投票算法" href=http://localhost:1313/blog/posts/majority-voting-algorithm/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Tree traversal</h2></header><div class=entry-content><p>今天來複習一下常見遍歷樹的方式。
Recursive way Inorder traversal 先拜訪 left subtree，再依序拜訪 root node 跟 right subtree。
void Inorder_traversal(TreeNode *node){ if (node == NULL){ return; } Inorder_traversal(node->left); cout &lt;&lt; node->val &lt;&lt; " "; Inorder_traversal(node->rihgt); return; } Preorder traversal 先拜訪 root node，再依序拜訪 left subtree 跟 right subtree。
void Preorder_traversal(TreeNode *node){ if (node == NULL){ return; } cout &lt;&lt; node->val &lt;&lt; " "; Preorder_traversal(node->left); Preorder_traversal(node->rihgt); return; } Postorder traversal 先依序拜訪 left subtree 跟 right subtree，再拜訪 root node。
void Postorder_traversal(TreeNode *node){ if (node == NULL){ return; } Postorder_traversal(node->left); Postorder_traversal(node->rihgt); cout &lt;&lt; node->val &lt;&lt; " "; return; } 可以看到用 recursive 寫的話，三種方式的 code 基本上長一樣，而且複雜度也都一樣，只是差在遍歷 root node 的時間不一樣。
time complexity: $O(n)$
space complextiy: $O(h)$, where $h = $ tree height
...</p></div><footer class=entry-footer><span title='2023-06-15 20:00:00 +0800 +0800'>June 15, 2023</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;590 words&nbsp;·&nbsp;cwHsueh</footer><a class=entry-link aria-label="post link to Tree traversal" href=http://localhost:1313/blog/posts/tree-traversal/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Gosper's Hack</h2></header><div class=entry-content><p>這是在寫 1799. Maximize Score After N Operations 時遇到的問題。
簡單來說，我想要解決的問題是「找到 n 個物品中取 k 個的所有組合」。而 Gosper’s Hack 可以有效率地找到 n 個 bit 中 k 個 bit 爲 1 的所有組合，剛剛好對應了我的問題。
Gosper’s Hack 的原理就是，從滿足條件（n 個 bit 中 k 個 bit 爲 1）的數字中，從最小的數字，一路找到最大的。
如果想找「5 個 bit 中 2 個 bit 爲 1」的組合，那麼 Gosper’s Hack 會依序找到
00011 00101 00110 01001 01010 01100 10001 10010 10100 11000 首先，滿足條件的數字中，最小的數字很容易就找到，就是把所有的 1 塞到最右邊去，也就是
int state = (1 &lt;&lt; k) - 1; 接下來比較難的問題是，要如何有效率地找到下一個數字。
找到下一個數字，分成兩個步驟
把最右邊的 $01$ 變成 $10$ 把剛剛 $10$ 右邊的 $1$ 全部推到最右邊去 看一個範例：有數字 $10011110_2$，他的下一個數字應該是多少？
根據上面的步驟，$10011100_2$ 的下一個數字就是 $10100111_2$
...</p></div><footer class=entry-footer><span title='2023-05-15 20:00:00 +0800 +0800'>May 15, 2023</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;440 words&nbsp;·&nbsp;cwHsueh</footer><a class=entry-link aria-label="post link to Gosper's Hack" href=http://localhost:1313/blog/posts/gospers-hack/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Digital Root / Repeated digital sum</h2></header><div class=entry-content><p>今天寫到 leetcode 258. Add Digits (https://leetcode.com/problems/add-digits/)，發現了這個有趣的題目。題目本身不難，但是 follow up 要求寫出 O(1) 時間複雜度的解法，因此卡了一下。
看到 wiki (https://en.wikipedia.org/wiki/Digital_root#Congruence_formula) 才發現這樣的問題被叫做 Digital Root，而且還可以在不同進位下討論，挺有趣的。
先看一個簡單的範例：
有一個 5 進位 的數字 14324 （這是用 5 進位表示），把這個數字的每一位相加然後用 5 進位表示，直到剩下一位，這個數字會是多少？
1 + 4 + 3 + 2 + 4 = 14（10 進位） = 24（5 進位）
2 + 4 = 6（10 進位） = 11（5 進位）
1 + 1 = 2（5 進位）
這個數字會是 2。但是計算很麻煩，因爲要在 5 進位上面做運算，是人類很不收悉的進位。
簡單的方法就是把所有的計算都換到 10 進位上面。 有小標的 5 就是指這個數字是 5 進位的。
...</p></div><footer class=entry-footer><span title='2023-04-26 15:34:53 +0800 +0800'>April 26, 2023</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;306 words&nbsp;·&nbsp;cwHsueh</footer><a class=entry-link aria-label="post link to Digital Root / Repeated digital sum" href=http://localhost:1313/blog/posts/digital-root/></a></article><footer class=page-footer><nav class=pagination><a class=next href=http://localhost:1313/blog/posts/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=http://localhost:1313/blog/>cwHsueh</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>