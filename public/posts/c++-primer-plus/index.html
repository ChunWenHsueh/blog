<!doctype html><html lang=en dir=auto><head><script src="/blog/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=blog/livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>C++ Primer Plus notes | cwHsueh</title>
<meta name=keywords content><meta name=description content="Chapter 4
Union
union is a data structure that can store different types of data, but it can only store one type of data at a time. The size of union is the size of its largest data.
union one4all
{
    int int_val;
    long long_val;
    double double_val;
};

one4all pail;
pail.int_val = 15; // store an int
cout << pail.int_val;
pail.double_val = 1.38; // store a double, int value is lost
cout << pail.double_val;
Enumerations
enum spectrum {red, orange, yellow, green, blue, violet, indigo, ultraviolet};

spectrum band; // band a variable of type spectrum
band = blue; // valid, blue is an enumerator
band = 2000; // invalid, 2000 not an enumerator
Enumarators are integer type, and can be converted to int, but not reversely."><meta name=author content="cwHsueh"><link rel=canonical href=http://localhost:1313/blog/posts/c++-primer-plus/><link crossorigin=anonymous href=/blog/assets/css/stylesheet.45e028aa8ce0961349adf411b013ee39406be2c0bc80d4ea3fc04555f7f4611a.css integrity="sha256-ReAoqozglhNJrfQRsBPuOUBr4sC8gNTqP8BFVff0YRo=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/favicon-32x32.png><link rel=apple-touch-icon href=http://localhost:1313/apple-touch-icon.png><link rel=mask-icon href=http://localhost:1313/blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:1313/blog/posts/c++-primer-plus/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.css integrity=sha384-zh0CIslj+VczCZtlzBcjt5ppRcsAmDnRem7ESsYwWwg3m/OaJ2l4x7YBZl9Kxxib crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.js integrity=sha384-Rma6DA2IPUwhNxmrB/7S3Tno0YY7sFu9WSYMCuulLhIqYSGZ2gKCJWIqhBWqMQfh crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/contrib/auto-render.min.js integrity=sha384-hCXGrW6PitJEwbkoStFjeJxv+fSOOQKOPbJxSfM6G5sWZjAyWhXiTIIAmQqnlLlh crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script><meta property="og:url" content="http://localhost:1313/blog/posts/c++-primer-plus/"><meta property="og:site_name" content="cwHsueh"><meta property="og:title" content="C++ Primer Plus notes"><meta property="og:description" content="Chapter 4 Union union is a data structure that can store different types of data, but it can only store one type of data at a time. The size of union is the size of its largest data.
union one4all { int int_val; long long_val; double double_val; }; one4all pail; pail.int_val = 15; // store an int cout << pail.int_val; pail.double_val = 1.38; // store a double, int value is lost cout << pail.double_val; Enumerations enum spectrum {red, orange, yellow, green, blue, violet, indigo, ultraviolet}; spectrum band; // band a variable of type spectrum band = blue; // valid, blue is an enumerator band = 2000; // invalid, 2000 not an enumerator Enumarators are integer type, and can be converted to int, but not reversely."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-01-05T12:00:00+08:00"><meta property="article:modified_time" content="2024-01-05T12:00:00+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="C++ Primer Plus notes"><meta name=twitter:description content="Chapter 4
Union
union is a data structure that can store different types of data, but it can only store one type of data at a time. The size of union is the size of its largest data.
union one4all
{
    int int_val;
    long long_val;
    double double_val;
};

one4all pail;
pail.int_val = 15; // store an int
cout << pail.int_val;
pail.double_val = 1.38; // store a double, int value is lost
cout << pail.double_val;
Enumerations
enum spectrum {red, orange, yellow, green, blue, violet, indigo, ultraviolet};

spectrum band; // band a variable of type spectrum
band = blue; // valid, blue is an enumerator
band = 2000; // invalid, 2000 not an enumerator
Enumarators are integer type, and can be converted to int, but not reversely."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:1313/blog/posts/"},{"@type":"ListItem","position":2,"name":"C++ Primer Plus notes","item":"http://localhost:1313/blog/posts/c++-primer-plus/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"C++ Primer Plus notes","name":"C\u002b\u002b Primer Plus notes","description":"Chapter 4 Union union is a data structure that can store different types of data, but it can only store one type of data at a time. The size of union is the size of its largest data.\nunion one4all { int int_val; long long_val; double double_val; }; one4all pail; pail.int_val = 15; // store an int cout \u0026lt;\u0026lt; pail.int_val; pail.double_val = 1.38; // store a double, int value is lost cout \u0026lt;\u0026lt; pail.double_val; Enumerations enum spectrum {red, orange, yellow, green, blue, violet, indigo, ultraviolet}; spectrum band; // band a variable of type spectrum band = blue; // valid, blue is an enumerator band = 2000; // invalid, 2000 not an enumerator Enumarators are integer type, and can be converted to int, but not reversely.\n","keywords":[],"articleBody":"Chapter 4 Union union is a data structure that can store different types of data, but it can only store one type of data at a time. The size of union is the size of its largest data.\nunion one4all { int int_val; long long_val; double double_val; }; one4all pail; pail.int_val = 15; // store an int cout \u003c\u003c pail.int_val; pail.double_val = 1.38; // store a double, int value is lost cout \u003c\u003c pail.double_val; Enumerations enum spectrum {red, orange, yellow, green, blue, violet, indigo, ultraviolet}; spectrum band; // band a variable of type spectrum band = blue; // valid, blue is an enumerator band = 2000; // invalid, 2000 not an enumerator Enumarators are integer type, and can be converted to int, but not reversely.\nint color = blue; // valid, spectrum type promoted to int band = 3; // invalid, int not converted to spectrum band = orange + red; // not valid, but a little tricky, int not converted to spectrum band = orange; // valid color = 3 + red; // valid, red converted to int band = spectrum(3); // typecast 3 to type spectrum In practice, enumerations are used more often as a way of defining related symbolic constants than as a means of defining new types.\nenum bits{one = 1, two = 2, four = 4, eight = 8}; enum bigstep{first, second = 100, third}; // first = 0, third = 101 enum {zero, null = 0, one, numero_uno = 1}; // zero = 0, one = 1 Pointers int array[3] = {1, 2, 3}; int *ptr = array; // array = \u0026array[0] = address of first element of array // \u0026array = address of whole array = int (*ptr) [3] = pointer that points to array-of-3-ints array is the address of a 4-byte block of memory, \u0026array is the address of a 12-byte block of memory.\narray + 1 adds 4 to the address value, \u0026array + 1 adds 12 to the address value\nA way to describe the type of variable is to remove the variable name, for example, short (*pas)[20], pas points to array of 20 shorts, the type of pas is short (*)[20]\nsizeof(array_name) = size of the array\nsizeof(pointer_name) = size of the pointer\nint *pt = new int; delete pt; delete [] pt; // effect is undefined, don't do it int *ps = new int [10]; delete [] ps; delete ps; // effect is undefined, don't do it Use delete [] if you used new [] to allocate an array. Use delete (no brackets) if you used new to allocate a single entity. Chapter 5: Loops and Relational Expressions Prefix and Postfix increment In prefix increment ++i, it increments the value and return the value. However, in postfix increment i++, it copys the value, increments the value, then returns the copy of the value.\nFor classes, the prefix version is more efficient than the postfix version.\nType Aliases #define BYTE char // preprocessor replaces BYTE with char typedef char btye // makes byte an alias for char // typedef typeName aliasName typedef char * byte_pointer; // pointer to char type It’s better to use typedef instead of #define. Consider the following:\n#define FLOAT_POINTER float * FLOAT_POINTER pa, pb; // preprocessor substitution converts to float * pa, pb; // pa a pointer to float, pb just a float typedef approach doesn’t have that problem.\nChapter 7: Functions: C++’s Programming Modules Pointers and const int age = 39; const int * pt = \u0026age; *pt += 1; // INVALID because pt points to a const int cin \u003e\u003e *pt; // INVALID for the same reason age = 20; // VALID because age is not declared to be const Assigning the address of a const variable to a pointer-to-const is valid, however, assigning to regular pointer is not.\nconst float g_earth = 9.80; const float * pe = \u0026g_earth; // VALID const float g_moon = 1.63; float * pm = \u0026g_moon; // INVALID const doesn’t prevent changing the value of pt, it prevents changing the value which pt points to.\nint age = 39; const int * pt = \u0026age; int sage = 80; pt = \u0026sage; // okay to point to another location If you want to prevent changing the value of pt, write DataType * const VariableName = \u0026Data.\nint sloth = 3; const int * ps = \u0026sloth; // a pointer to const int int * const finger = \u0026sloth; // a const pointer to int *finger = 4; // VALID finger and *ps are both const, and *finger and ps are not const.\nFunctions and Two-Dimensional Arrays int data[3][4] = {{1,2,3,4}, {9,8,7,6}, {2,4,6,8}}; data is an array with three elements. The first element is an array of four int values. Hence, the type of data is pointer-to-array-of-four-int, so an appropriate prototype would be:\nint sum(int (*ar2)[4], int size); int sum(int ar2[][4], int size); // VALID, more readable int sum(int *ar2[4], int size); // INVALID Now the sum function works with arrays with four columns.\nint a[100][4]; int b[6][4]; ... int total1 = sum(a, 100); // sum all of a int total2 = sum(b, 6); // sum all of b int total3 = sum(a, 10); // sum first 10 rows of a int total4 = sum(a+10, 20); // sum next 20 rows of a Pointers to Functions Funcitons also have addresses. Pointers to functions are useful because we can pass in different functions in different times.\nHere’s what a declaration of an appropriate pointer type looks like:\ndouble pam(int); // prototype double (*pf)(int); // pf points to a function that takes // one int argument and that // returns type double double *pf(int); // pf() a function that returns a pointer-to-double We can use two ways to invoke a function with function pointers.\ndouble pam(int); double (*pf)(int); pf = pam; // pf now points to the pam() function double x = pam(4); // call pam() using the function name double y = (*pf)(5); // call pam() using the pointer pf double y = pf(5); // also call pam() using the pointer pf // however, the previous one provides a visual reminder that the code is using a function pointer Chapter 8: Adventures in Functions Temporary Variables, Reference Arguments, and const When the reference parameter is a const, the compiler generates a temporary variable when:\nThe actual argument is the correct type but isn’t an lvalue The actual argument is of the wrong type, but can be conoverted to the corret type lvalue is a data object that can be referenced by address, such as variables, array elements, stucture members. Non-lvalue include literal constants and expressions with multiple terms.\ndouble refcube(const double \u0026ra){ return ra * ra * ra; } double side = 3.0; double * pd = \u0026side; double \u0026 rd = side; long edge = 5L; double lens[4] = { 2.0, 5.0, 10.0, 12.0}; double c1 = refcube(side); // ra is side double c2 = refcube(lens[2]); // ra is lens[2] double c3 = refcube(rd); // ra is rd is side double c4 = refcube(*pd); // ra is *pd is side double c5 = refcube(edge); // ra is temporary variable, long coverted to double double c6 = refcube(7.0); // ra is temporary variable, literal constants double c7 = refcube(side + 10.0); // ra is temporary variable, multiple terms Note that if refcude does not use constant references, c5, c6, c7 will show error. If there is no such rule, this will happen:\nvoid swapr(int \u0026 a, int \u0026 b) // use references { int temp; temp = a; // use a, b for values of variables a = b; b = temp; } long a = 3, b = 5; swapr(a, b); // swapping temporary variable instead of swapping a and b In short, if the intent of a function with reference arguments is to modify variables passed as arguments, situations that create temporary variables thwart that purpose. Adding const means that we are not modifying them, so temporary variable cause no harm.\nIn C++11, there is a second kind of reference, called an rvalue reference. It’s declared using \u0026\u0026:\ndouble \u0026\u0026 rref = std::sqrt(36.00); // not allowed for double \u0026 double j = 15.0; double \u0026\u0026 jref = 2.0* j + 18.5; // not allowed for double \u0026 std::cout \u003c\u003c rref \u003c\u003c '\\n'; // display 6.0 std::cout \u003c\u003c jref \u003c\u003c '\\n'; // display 48.5; The original reference type (\u0026) is now called an lvalue reference.\nWhy Return a Reference? int \u0026 square(int \u0026i){ i *= i; return i; } int x = 2; int y = square(x); // note that x and y have different address int \u0026z = square(x); // x and z have same address If square() returned int instead of int \u0026, this could involve copying the entire structure to a temporary location and then copying that copy to y. But with a reference return value, x is copied directly to y, a more efficient approach.\nBeing Careful About What a Return Reference Refers To Avoid these lines:\nconst free_throws \u0026 clone2(free_throws \u0026 ft) { free_throws newguy; // first step to big error newguy = ft; // copy info return newguy; // return reference to copy } It returns a reference to a temporary variable. The simplest way to avoid is to return a reference that was passed as an argument, like the square() function above.\nAnother way is to use new to create new storage.\nconst free_throws \u0026 clone(free_throws \u0026 ft) { free_throws * pt; *pt = ft; // copy info return *pt; // return reference to copy } However, it is easy to forget to use delete later.\nFunction Overloading void print(const char * str, int width); // #1 void print(double d, int width); // #2 void print(long l, int width); // #3 void print(int i, int width); // #4 void print(const char *str); // #5 print(\"Pancakes\", 15); // use #1 print(\"Syrup\"); // use #5 print(1999.0, 10); // use #2 print(1999, 12); // use #4 print(1999L, 15); // use #3 unsigned int year = 3210; print(year, 6); // ambiguous call, error // If the only print() prototype were #2, then print(year, 6) will convert to type double The function-matching process does discriminate between const and non-const variables.\nvoid dribble(char * bits); // overloaded void dribble (const char *cbits); // overloaded void dabble(char * bits); // not overloaded void drivel(const char * bits); // not overloaded const char p1[20] = \"How's the weather?\"; char p2[20] = \"How's business?\"; dribble(p1); // dribble(const char *); dribble(p2); // dribble(char *); dabble(p1); // no match dabble(p2); // dabble(char *); drivel(p1); // drivel(const char *); drivel(p2); // drivel(const char *); since it's valid to assign non-const value to a const variable, but not vice versa void stove(double \u0026 r1); // matches modifiable lvalue void stove(const double \u0026 r2); // matches const lvalue void stove(double \u0026\u0026 r3); // matches rvalue double x = 55.5; const double y = 32.0; stove(x); // calls stove(double \u0026) stove(y); // calls stove(const double \u0026) stove(x+y); // calls stove(double \u0026\u0026) // If we omit the stove(double \u0026\u0026) function, then stove(x + y) will call the stove(const double \u0026) funciton instead Function Templates Let’s say we want to create swap() function that can swap two same type of data. One approach is to duplicate the function and overload it, however, it’s a waste of time and if we make changes to one function, we have to change every functions.\nWe can set up a swapping template like this:\ntemplate \u003ctypename AnyType\u003e void Swap(AnyType \u0026a, AnyType \u0026b) { AnyType temp; temp = a; a = b; b = temp; } The template does not create any functions.Instead, it provides the compiler with directions about how to define a function. If you want a function to swap ints, then the compiler creates a function following the template pattern, substituting int for AnyType.\nOverloaded Templates If we want to create swap() function for C arrays, we can overload templates.\ntemplate \u003ctypename T\u003e void Swap(T \u0026a, T \u0026b) { T temp; temp = a; a = b; b = temp; } template \u003ctypename T\u003e void Swap(T a[], T b[], int n) { T temp; for (int i = 0; i \u003c n; i++) { temp = a[i]; a[i] = b[i]; b[i] = temp; } } Template Limitations Let’s say we want to compare two numbers in a template, we can simply write things like a == b, however, the == equal sign (and \u003e, \u003c) is not defined under C arrays or other data structures. We must provide specialized template funcitons for particular types.\nExplicit Specializations Suppose we have a structure that looks like this:\nstruct job { char name[40]; double salary; int floor; }; and we want to define a swap funciton for it, but only swapping salary and floor, then we can use explicit specializations. The prototype and definition for an explicit specialization should be preceded by template \u003c\u003e and should mention the specialized type by name.\n// non template function prototype void Swap(job \u0026, job \u0026); // template prototype template \u003ctypename T\u003e void Swap(T \u0026, T \u0026); // explicit specialization for the job type template \u003c\u003e void Swap\u003cjob\u003e(job \u0026, job \u0026); // swaps just the salary and floor fields of a job structure template \u003c\u003e void Swap\u003cjob\u003e(job \u0026j1, job \u0026j2) // specialization { double t1; int t2; t1 = j1.salary; j1.salary = j2.salary; j2.salary = t1; t2 = j1.floor; j1.floor = j2.floor; j2.floor = t2; } For a given function name, you can have a non template function,a template function,and an explicit specialization template function,along with overloaded versions of all of these. A specialization overrides the regular template,and a non template function overrides both.\nInstantiations and Specializations When the compiler uses the template to generate a funciton for a particular type, we call it instantiation of the template. If we write this:\ntemplate \u003ctypename T\u003e void Swap(T \u0026a, T \u0026b) { T temp; temp = a; a = b; b = temp; } ... Swap(i, j); // i, j are int type ... Then this is called implicit instantiation. The compiler creates a function Swap() for int type because the program uses Swap() with int parameters.\nThere is also explicit instantiation, which means that we can tell the compiler to generate a function for specific type for us.\ntemplate void Swap\u003cint\u003e(int, int); // explicit instantiation It basically tells the compiler “Use the Swap() template to generate a function definition for the int type.”\nNote the difference between explicit instantiation and explicit specialization. The explicit specialization declaration has \u003c\u003e after the keyword template, whereas the explicit instantiation omits the \u003c\u003e.\ntemplate void Swap\u003cint\u003e(int \u0026, int \u0026); // explicit instantiation template \u003c\u003e void Swap\u003cint\u003e(int \u0026, int \u0026); // explicit specialization template \u003c\u003e void Swap(int \u0026, int \u0026); // explicit specialization Explicit specialization tells the compiler “Don’t use the Swap() template to generate a function definition. Instead, use a separate, specialized function definition explicitly defined for the int type.”\nWhich Function Version Does the Compiler Pick? The compiler will pick the function by such ranking:\nExact match, with regular functions outranking templates Conversion by promotion (for example, the automatic conversions of char and short to int and of float to double) Conversion by standard conversion (for example, converting int to char or long to double) User-defined conversions, such as those defined in class declarations For example,\nmay('B'); // actual argument is type char void may(int); // #1 float may(float, float = 3); // #2 void may(char); // #3 char * may(const char *); // #4 char may(const char \u0026); // #5 template\u003cclass T\u003e void may(const T \u0026); // #6 template\u003cclass T\u003e void may(T *); // #7 #4 and #7 are not viable. #1 is better than #2, since char-to-int is a promotion, whereas char-to-float is a standard conversion. #3, #5 and #6 are better than #1 since they are exact matches. #3 and #5 are better than #6 because #6 is a template. However, what happens if we have #3 and #5 at the same time? Most of the time, two exact matches are an error, however, special cases are exceptions to this rule.\nExact Matches and Best Matches Suppose you have the following code:\nstruct blot {int a; char b[10];}; blot ink = {25, \"spots\"}; ... recycle(ink); // the following prototypes are exact matches void recycle(blot); // #1 blot-to-blot void recycle(const blot); // #2 blot-to-(const blot) void recycle(blot \u0026); // #3 blot-to-(blot \u0026) void recycle(const blot \u0026); // #4 blot-to-(const blot \u0026) Pointers and references to non-const data are preferentially matched to non-const pointer and reference parameters. If only Functions #3 and #4 were available in the recycle() example, #3 would be chosen because ink wasn’t declared as const.\nHowever, this discrimination between const and non-const applies just to data referred to by pointers and references. That is, if only #1 and #2 were available, you would get an ambiguity error.\nIf we have two template functions with exact matches, the more specialized is the better one. For example:\ntemplate \u003cclass Type\u003e void recycle (Type t); // #1 template \u003cclass Type\u003e void recycle (Type * t); // #2 struct blot {int a; char b[10];}; blot ink = {25, \"spots\"}; ... recycle(\u0026ink); // address of a structure The recycle(\u0026ink) call matches Template #1, with Type interpreted as blot *.The recycle(\u0026ink) function call also matches Template #2, this time with Type being ink. In Template #2, Type was already specialized as a pointer, hence it is “more specialized.”\nMaking Your Own Choices template\u003cclass T\u003e T lesser(T a, T b) // #1 { ... } int lesser (int a, int b) // #2 { ... } int m = 20; int n = -30; double x = 15.5; double y = 25.9; cout \u003c\u003c lesser(m, n) \u003c\u003c endl; // use #2 cout \u003c\u003c lesser(x, y) \u003c\u003c endl; // use #1 with double cout \u003c\u003c lesser\u003c\u003e(m, n) \u003c\u003c endl; // use #1 with int, tells compiler to choose a template function cout \u003c\u003c lesser\u003cint\u003e(x, y) \u003c\u003c endl; // use #1 with int, explicit instantiation What’s That Type? template\u003cclass T1, class T2\u003e void ft(T1 x, T2 y) { ... ?type? xpy = x + y; // what is the type of xpy ... } What should the type for xpy be? We can use decltype keyworld as a solution.\n// decltype(expression) var; decltype(x + y) xpy = x + y; // make xpy the same type as x + y decltype should follow these rules:\nIf expression has no additional parentheses, then var is the same type as the identifier\nIf expression is a funciton call, then var is the same type as the function return type. Note that there’s no need to actually call the funciton.\ndecltype with extra parentheses preserves references from the original expression\nIf none of the preceding cases apply, var is the same type as expression\ndouble x = 5.5; double y = 7.9; double \u0026rx = x; const double * pd; decltype(x) w; // w is type double decltype(rx) u = y; // u is type double \u0026 decltype(pd) v; // v is type const double * long indeed(int); decltype (indeed(3)) m; // m is type long double xx = 4.4; decltype ((xx)) r2 = xx; // r2 is double \u0026 decltype(xx) w = xx; // w is double (Stage 1 match) int j = 3; int \u0026k = j int \u0026n = j; decltype(j+6) i1; // i1 type int decltype(100L) i2; // i2 type long decltype(k+n) i3; // i3 type int; Note that we can use typedef and decltype at the same time.\ntypedef decltype(x + y) xytype; xytype xpy = x + y; Alternative Function Syntax template\u003cclass T1, class T2\u003e ?type? gt(T1 x, T2 y) { ... return x + y; } What if the problem appears in return type? In this case, we cannot use decltype(x + y) for the return type, since parameters x and y have not been declared. The decltype has to come after the parameters are declared. Instead, we can write:\ntemplate\u003cclass T1, class T2\u003e auto gt(T1 x, T2 y) -\u003e decltype(x + y) { ... return x + y; } Chapter 9: Memory Models and Namespaces Separate Compilation We can divide the program into three parts:\nA header file that contains the structure declarations and prototypes for functions that use those structures A source code file that contains the code for the structure-related functions A source code file that contains the code that calls the structure-related functions However, this creates new problems. For example, if you had a function definition in a header file and two other files that are part of a single program included it, you would wind up with two definitions of the same function, which is an error.\nHere are some things commonly found in header files:\nFunction prototypes Symbolic constants defined using #define or const Structure declarations Class declarations Template declarations Inline functions Here is an example of seperating a program into three files:\n// coordin.h -- structure templates and function prototypes // structure templates #ifndef COORDIN_H_ #define COORDIN_H_ struct polar { double distance; // distance from origin double angle; // direction from origin }; struct rect { double x; // horizontal distance from origin double y; // vertical distance from origin }; // prototypes polar rect_to_polar(rect xypos); void show_polar(polar dapos); #endif // file1.cpp -- example of a three-file program #include #include \"coordin.h\" // structure templates, function prototypes using namespace std; int main() { rect rplace; polar pplace; cout \u003c\u003c \"Enter the x and y values: \"; while (cin \u003e\u003e rplace.x \u003e\u003e rplace.y) // slick use of cin { pplace = rect_to_polar(rplace); show_polar(pplace); cout \u003c\u003c \"Next two numbers (q to quit): \"; } cout \u003c\u003c \"Bye!\\n\"; return 0; } // file2.cpp -- contains functions called in file1.cpp #include #include #include \"coordin.h\" // structure templates, function prototypes // convert rectangular to polar coordinates polar rect_to_polar(rect xypos) { using namespace std; polar answer; answer.distance = sqrt( xypos.x * xypos.x + xypos.y * xypos.y); answer.angle = atan2(xypos.y, xypos.x); return answer; // returns a polar structure } // show polar coordinates, converting angle to degrees void show_polar (polar dapos) { using namespace std; const double Rad_to_deg = 57.29577951; cout \u003c\u003c \"distance = \" \u003c\u003c dapos.distance; cout \u003c\u003c \", angle = \" \u003c\u003c dapos.angle * Rad_to_deg; cout \u003c\u003c \" degrees\\n\"; } Header File Management You should include a header file just once in a file. It’s easy to include a header file multiple times accidentally. For example, you might use a header file that includes another header file.\nWe can use preprocessor #ifndef (if not defined) directive.\n#ifndef COORDIN_H_ #define COORDIN_H_ // place include file contents here #endif The code above means “process the statements between the #ifndef and #endif only if the name COORDIN_H_ has not been defined previously by the preprocessor #define directive.”\nStorage Duration, Scope, and Linkage C++ uses four different schemes for storing data,\nAutomatic storage duration: Variables declared inside a function definition (including function parameters) will be created when program enters a function or a block and freed when executuion leaves the function or block. Static storage duration: Varialbes defined outside function definition or with the keyword static have static storage duration. They persist for the entire time a program is running. Thread storage duration: Variables declared with the thread_local keyword have storage that persists for as long as the containing thread lasts. Dynamic storage duration: Memory allocated by the new keyword persists until it is freed with the delete operator or until the program ends. Scope and Linkage Scope describes how widely visible a name is in a file. Linkage describes how a name can be shared in different units (files).\nStatic Duration Variables int global = 1000; // static duration, external linkage (other files can see the variable) static int one_file = 50; // static duration, internal linkage (only this file can see the varialbe) int main() { ... } void funct1(int n) { static int count = 0; // static duration, no linkage (only funct1 can see the variable) int llama = 0; ... } void funct2(int q) { ... } The static duration variables (global, one_file, count) persist when the program begins and execute until the program terminates.\nInitializing Static Variables All static duration variables have the following initialization feature: all its bits set to 0. It is also called zero-initialization.\n#include int x; // zero-initialization int y = 5; // constant-expression initialization long z = 13 * 13; // constant-expression initialization const double pi = 4.0 * atan(1.0); // dynamic initialization First, x, y, z and pi are zero-initialized. Then the compiler initialize y and z to 5 and 169. pi will be initialized until the atan() function is linked and the program executes.\nStatic Duration, External Linkage // file01.cpp extern int cats = 20; // definition because of initialization, the extern can be omitted int dogs = 22; // definition ... // file02.cpp // use cats and dogs from file01.cpp extern int cats; // referencing declaration extern int dogs; // does not cause storage to be allocated Static Duration, Internal Linkagek // file01 int errors = 20; // file02 int errors = 5; // this is an error, since violates the one definition rule If we want to use the same variable name, we should addd static keyword.\n// file01 int errors = 20; // file02 static int errors = 5; // this is an error, since violates the one definition rule Static Storage Duration, No Linkage // reference: https://stackoverflow.com/questions/12186857/what-is-the-difference-between-static-local-variables-and-static-global-variable void foo () { static int x = 0; ++x; cout \u003c\u003c x \u003c\u003c endl; } int main (int argc, char const *argv[]) { foo(); // 1 foo(); // 2 foo(); // 3 return 0; } The difference between static internal linkage and static local variable is\nThe name is only accessible within the function, and has no linkage It is initialised the first time execution reaches the definition, not necessarily during the program’s initialisation phases More About const Whereas a global variable has external linkage by default,a const global variable has internal linkage by default.\nIf, for some reason, you want to make a constant have external linkage, you can use the extern keyword to override the default internal linkage.\nChapter 10: Objects and Classes const Member Functions Consider the following code:\nconst Stock land = Stock(\"Kludgeforn Properties\"); land.show(); // error In Stock::show() function, we cannot guarantee that it will not modify the object. To solve the issue, we can add const at the end of the function when we declare or write definition for it.\nvoid Stock::show() const{ // promises not to change the object } Chapter 11: Working with Classes Operator Overloading A common computing task is adding two arrays. We might write something like this:\nfor (int i = 0; i \u003c 20; i++){ evening[i] = sam[i] + janet[i]; } We can overload the + operator so that you can do this:\nevening = sam + janet; For example, operator+() overloads the + operator and operator*() overloads the * operator. We can also write operator[]() to overload the [] operator, which is the array-indexing operator.\nLet’s say we have a Time class, and we want to use + operator to add two Time objects. We can write the following code:\nclass Time { private: int hours; int minutes; public: Time operator+(const Time \u0026t) const{ Time sum; sum.minutes = minutes + t.minutes; sum.hours = hours + t.hours + sum.minutes / 60; sum.minutes %= 60; return sum; }; ... // other funcions in the class ... }; Now we can simply write time1 + time2 instead of time1.add(time2), and it will be translated to time1.operator+(time2).\nIntroducing Friends There are still some restrictions when overloading operators. For example, if we overload the * operator and write time1 * 2.5, it translates to time1.operator*(2). However, 2.5 * time1 does not correspond to a member function since 2.5 is not a Time object.\nWe can write a nonmember function Time operator*(double m, const Time \u0026t) to resolve this, but it raises a new problem: nonmember functions cannot access private data in a class. There is a special category of nonmenber functions, called friends, that can access private members of a class.\nCreating Friends To create a friend function, we need to add friend keyword in the prefix of the declaration.\nfriend Time operator*(double m, const Time \u0026t); // goes in class declaration The friend function is not a member function although it is in class declaration, but it has the same access rights as a member function.\nThe definition should like this:\n// no need to add friend keyword // no need to write Time Time::operator*(double m, const Time \u0026t) since it is not a member function Time operator*(double m, const Time \u0026t){ Time result; long totalminutes = t.hours * mult * 60 +t. minutes * mult; // can access private members result.hours = totalminutes / 60; result.minutes = totalminutes % 60; return result; } Now, the statement time2 = 2.5 * time1 translates to time2 = operator*(2.5, time1)\nActually, we can write it as a non-friend function. However, it is better to write it as a friend function, since it ties the function and the class interface together, and allows potential access to private data in the future.\nTime operator*(double m, const Time \u0026t){ return t * m; // use t.operator*(m) // no need to access private members } Overloading the \u003c\u003c Operator Suppose trip is a Time object. To display Time values, we need to write trip.show() to print out the values. However, we could overload the \u003c\u003c operator and make cout \u003c\u003c trip print out the values.\nWe can overload the operator this way:\nvoid operator\u003c\u003c(ostream \u0026os, const Time \u0026t){ os \u003c\u003c t.hours \u003c\u003c \"hours, \" \u003c\u003c t.minutes \u003c\u003c \" minutes\"; } How about a more complex one, something like this: cout \u003c\u003c \"Trip time: \" \u003c\u003c trip \u003c\u003c \"\\n\";\nActually, cout is an ostream object, and the ostream class returns a reference to an ostream object when implementing the \u003c\u003c operator.\nWe just need to make operator\u003c\u003c() return a ostream object.\nostream\u0026 operator\u003c\u003c(ostrream \u0026os, const Time \u0026t){ os \u003c\u003c t.hours \u003c\u003c \"hours, \" \u003c\u003c t.minutes \u003c\u003c \" minutes\"; return os; } A Vector Class Vector class\nAutomatic Conversions and Type Casts for Classes C++ provides the following type conversions for classes:\nA class constructor that has but a single argument serves as an instruction for converting a value of the argument type to the class type. For example, if we have a constructor Stonewt(double lbs) for Stonewt class. Then Stonewt myCat = 19.6 will convert 19.6 to a Stonewt object.\nHowever, using explicit in the constructor declaration eliminates implicit conversions and allows only explicit conversions.\nexplicit Stonewt(double lbs); // no implicit conversions allowed Stonewt myCat; // create a Stonewt object myCat = 19.6; // not valid if Stonewt(double) is declared as explicit mycat = Stonewt(19.6); // ok, an explicit conversion mycat = (Stonewt) 19.6; // ok, old form for explicit typecast A special class member operator function called a conversion function serves as an instruction for converting a class object to some other type. This conversion function is invoked automatically when you assign a class object to a variable of that type or use the type cast operator to that type. class Stonewt { ... // conversion functions explicit operator int() const; }; Stonewt::operator int() { return int (pounds + 0.5); } Stonewt wolfe(285.7); int host = int (wolfe); // an explicit conversion Conversions and Friends Stonewt operator+(const Stonewt \u0026 st1, const Stonewt \u0026 st2) // friend function { double pds = st1.pounds + st2.pounds; Stonewt sum(pds); return sum; } Stonewt jennySt(9, 12); double pennyD = 146.0; Stonewt total; total = pennyD + jennySt; // ok with friend function, but not member function // convert pennyD to a Stonewt object Chapter 12: Classes and Dynamic Memory Allocation A Review Example and Static Class Members Let’s take a look at a class example:\n// strngbad.h -- flawed string class definition #include #ifndef STRNGBAD_H_ #define STRNGBAD_H_ class StringBad { private: char * str; // pointer to string int len; // length of string static int num_strings; // number of objects public: StringBad(const char * s); // constructor StringBad(); // default constructor ~StringBad(); // destructor // friend function friend std::ostream \u0026 operator\u003c\u003c(std::ostream \u0026 os, const StringBad \u0026 st); }; #endif // strngbad.cpp -- StringBad class methods #include // string.h for some #include \"strngbad.h\" using std::cout; // initializing static class member int StringBad::num_strings = 0; // class methods // construct StringBad from C string StringBad::StringBad(const char * s) { len = std::strlen(s); // set size str = new char[len + 1]; // allot storage std::strcpy(str, s); // initialize pointer num_strings++; // set object count cout \u003c\u003c num_strings \u003c\u003c \": \\\"\" \u003c\u003c str \u003c\u003c \"\\\" object created\\n\"; // For Your Information } StringBad::StringBad() // default constructor { len = 4; str = new char[4]; std::strcpy(str, \"C++\"); // default string num_strings++; cout \u003c\u003c num_strings \u003c\u003c \": \\\"\" \u003c\u003c str \u003c\u003c \"\\\" default object created\\n\"; // FYI } StringBad::~StringBad() // necessary destructor { cout \u003c\u003c \"\\\"\" \u003c\u003c str \u003c\u003c \"\\\" object deleted, \"; // FYI --num_strings; // required cout \u003c\u003c num_strings \u003c\u003c \" left\\n\"; // FYI delete [] str; // required } std::ostream \u0026 operator\u003c\u003c(std::ostream \u0026 os, const StringBad \u0026 st) { os \u003c\u003c st.str; return os; } Notice that we initializes the static num_strings member to 0 in the .cpp file instead of the header file. That’s because we cannot initialize a static member variable inside the class declaration. Declaration only tells how to allocate the memory, but it doesn’t allocate memory. For static members, we need to initialize outside the class declaration (but not const static).\nThe StringBad class seems fine, however, there’s actually some problems. Let’s look at an example:\nvoid callme(StringBad sb){ cout \u003c\u003c \"String passed by value:\\n\"; cout \u003c\u003c \" \\\"\" \u003c\u003c sb \u003c\u003c \"\\\"\\n\"; } StringBad headline(\"Celery Stalks at Midnight\"); callme(headline); cout \u003c\u003c headline \u003c\u003c endl; // print out something strange When we pass by value, the function will create a temporary StringBad object that points to the same address as the headline does. After the callme function, the destructor will be called, causing the pointer to be released, which messes up the original string.\nSpecial Member Functions The problems with the StringBad class stem from special member functions. C++ provides the following member functions:\nA default constructor if you define no constructors A default destructor if you don’t define one A copy constructor if you don’t define one An assignment operator if you don’t define one An address operator if you don’t define one Default Constructor If we omit any constructors, the compiler will call the default constructor. If we define a constructor with no arguments, or its arguments have default values, it will become the default constructor.\nHowever, we can have only one default constructor; otherwise, there will be ambiguity.\nClass_name(){}; // default constructor Class_name(){ // default constructor with no arguments member = 0; } Class_name(){int n = 0}{ // default constructor with default argument value member = n; } Copy Constructor A copy constructor for a class normally has this prototype: Class_name(const Class_name \u0026);. The default copy constructor performs a member-by-member copy of the nonstatic members. Each member is copied by value.\nA copy constructor is invoked whenever a new object is created and initialized to an existing object of the same kind.\n// given that motto is a StringBad object StringBad ditto(motto); // calls StringBad(const StringBad \u0026) StringBad metoo = motto; // calls StringBad(const StringBad \u0026) StringBad also = StringBad(motto); // calls StringBad(const StringBad \u0026) StringBad * pStringBad = new StringBad(motto); // calls StringBad(const StringBad \u0026) The middle two declarations may use a copy constructor directly to create metoo and also, or they may use a copy constructor to generate temporary objects whose contents are then assigned to metoo and also.\nBack to Stringbad: Where the Copy Constructor Goes Wrong The callme function creates a temporary variable that invokes the copy constructor, and this variable points to the same address as our original object. We should provide a copy constructor for the StringBad class.\nStringBad::StringBad(const StringBad \u0026 st) { num_strings++; // handle static member update len = st.len; // same length str = new char [len + 1]; // allot space std::strcpy(str, st.str); // copy string to new location cout \u003c\u003c num_strings \u003c\u003c \": \\\"\" \u003c\u003c str \u003c\u003c \"\\\" object created\\n\"; // For Your Information } Assignment Operator Assignment Operator has the following prototype:Class_name \u0026 Class_name::operator=(const Class_name \u0026);.\nAn overloaded assignment operator is used when you assign one object to another existing object:\nStringBad headline(\"Celery Stalks at Midnight\"); StringBad knot; knot = headline; // assignment operator invoked Like a copy constructor,an implicit implementation of an assignment operator performs a member-to-member copy.\nBack to Stringbad: Where the Assignment Goes Wrong We should also provide a assignment operator for the StringBad class. The implementation is similar to that of the copy constructor, but there are some differences:\nUse delete [] to free the old string The function should protect against assigning an object to itself The function returns a reference to the invoking object Here is the implementation:\nStringBad \u0026 StringBad::operator=(const StringBad \u0026 st) { if (this == \u0026st) // object assigned to itself return *this; // all done delete [] str; // free old string len = st.len; str = new char [len + 1]; // get space for new string std::strcpy(str, st.str); // copy the string return *this; // return reference to invoking object } The New, Improved String Class We still need a few functions to improve the String class, such as comparison members or bracket notation.\nHere is an improved String class:\nString class\nFor static class member functions, it can only use static data members, since it is not associated with a particular object.\nWe added String \u0026 String::operator=(const char * s) to improve efficiency. Consider the following code:\nString name; char temp[40]; cin.getline(temp, 40); name = temp; // use constructor to convert type The program will do the following steps:\nUse String(const char *) constructor to construct a temporary String object Use String \u0026 String::operator=(const String \u0026) to copy the object to name call ~String() destructor to delete the temporary object Which is slower than copying the C string directly to the String object.\nLooking Again at Placement new Using placement new is different from using regular new to allocate memory for objects. If we want to destroy the object that was allocated by placement new, we must call the destructor explicitly to do so.\nchar * buffer = new char[512]; // get a block of memory MyClass *ptr; ptr = new (buffer) MyClass; // place object in buffer ptr-\u003e~MyClass(); // call the destructor explicitly delete [] buffer; // Free the raw memory allocated earlier We have to call the destructor instead of delete. The reason is that delete does two things:\nIt calls the destructor of the object It attempts to free the memory where the object was located However, when using the placement new, the memory location is provided by us, and therefore delete might not know how to correctly deallocate it, leading to undefined behavior.\nMember Initializer List Let’s say we have a class that looks like this:\nclass Queue{ private: enum {Size = 10}; Node * front; // pointer to front of Queue Node * rear; // pointer to rear of Queue int items; // current number of items in Queue const int qsize; // maximum number of items in Queue public: Queue(int qs) { front = rear = NULL; items = 0; qsize = qs; // not acceptable! } }; We want to assign qs to the qsize variable, however, const variable can only be initialized to a value, not assigned to a value.\nCalling a constructor creates an object before the code within the brackets is executed. Thus, the constructor will first allocate space for the four member variables, then enter the brackets and assign values into allocated space.\nWe can use member initializer list syntax to initialize member variables.\nQueue(int qs) : qsize(qs) // initialize qsize to qs, instead of assigning { front = rear = NULL; items = 0; } // or Queue(int qs) : qsize(qs), front(NULL), rear(NULL), items(0) { } Only constructors can use this initializer-list syntax. We also have to use it for class members that are declared as references.\nIn-class initialization is equivalent to using a member initialization list in the constructors:\nclass Classy{ int mem1 = 10; // in-class initialization } // is equivalent to Classy(): mem1(10){ ... } The items are initialized in the order which they are decalred, not in the order in which they appear in the initializer list.\nChapter 13: Class Inheritance Beginning with a Simple Base Class // tabtenn0.h -- a table-tennis base class #ifndef TABTENN0_H_ #define TABTENN0_H_ #include using std::string; // simple base class class TableTennisPlayer { private: string firstname; string lastname; bool hasTable; public: TableTennisPlayer (const string \u0026 fn = \"none\", const string \u0026 ln = \"none\", bool ht = false); void Name() const; bool HasTable() const { return hasTable; }; void ResetTable(bool v) { hasTable = v; }; }; #endif //tabtenn0.cpp -- simple base-class methods #include \"tabtenn0.h\" #include TableTennisPlayer::TableTennisPlayer (const string \u0026 fn, const string \u0026 ln, bool ht) : firstname(fn), lastname(ln), hasTable(ht) {} void TableTennisPlayer::Name() const { std::cout \u003c\u003c lastname \u003c\u003c \", \" \u003c\u003c firstname; } Now we can create RatedPlayer class that derives from the TableTennesPlayer base class:\n// RatedPlayer derives from the TableTennisPlayer base class class RatedPlayer : public TableTennisPlayer { private: unsigned int rating; // add a data member public: RatedPlayer (unsigned int r = 0, const string \u0026 fn = \"none\", const string \u0026 ln = \"none\", bool ht = false); RatedPlayer(unsigned int r, const TableTennisPlayer \u0026 tp); unsigned int Rating() const { return rating; } // add a method void ResetRating (unsigned int r) {rating = r;} // add a method }; With public derivation, the public members of the base class become public members of the derived class. The private portions of a base class become part of the derived class, but they can be accessed only through public and protected methods of the base class.\nConstructors When a program constructs a derived-class object, it first constructs the base-class object. We must use member initailizer list syntax to construct base-class object before we enter the body of the derived-class constructor.\nRatedPlayer::RatedPlayer(unsigned int r, const string \u0026 fn, const string \u0026 ln, bool ht) : TableTennisPlayer(fn, ln, ht) { rating = r; } We we omit calling a base-class constructor, the program uses the default constructor.\nRatedPlayer::RatedPlayer(unsigned int r, const string \u0026 fn, const string \u0026 ln, bool ht) { rating = r; } // is same as RatedPlayer::RatedPlayer(unsigned int r, const string \u0026 fn, const string \u0026 ln, bool ht) : TableTennisPlayer() { rating = r; } Special Relationships Between Derived and Base Classes A base-class pointer can point to a derivedclass object without an explicit type cast and that a base-class reference can refer to a derived-class object without an explicit type cast.\nRatedPlayer player1(1140, \"Mallory\", \"Duck\", true); TableTennisPlayer \u0026 rt = player; TableTennisPlayer * pt = \u0026player; rt.Name(); // invoke Name() with reference pt-\u003eName(); // invoke Name() with pointer TableTennisPlayer player2(player1); // The exact match should be TableTennisPlayer(const RatedPlayer \u0026) that doesn't exist // but there is the implicit copy constructor TableTennisPlayer(const TableTennisPlayer \u0026) However,a base-class pointer or reference can invoke just base-class methods, not derived-class methods.\nPolymorphic Public Inheritance virtual determines which method is used if the method is invoked by a reference or a pointer instead of by an object. If you don’t use the keyword virtual, the program chooses a method based on the reference type or pointer type.\nFor example, if we have a base-class Brass and a derived-class BrassPlus, and a virtual function ViewAcct() for both classes.\nBrass dom(\"Dominic Banker\", 11224, 4183.45); BrassPlus dot(\"Dorothy Banker\", 12118, 2592.00); dom.ViewAcct(); // use Brass::ViewAcct() dot.ViewAcct(); // use BrassPlus::ViewAcct() Brass \u0026b1_ref = dom; Brass \u0026b2_ref = dot; b1_ref.ViewAcct(); // use Brass::ViewAcct() b2_ref.ViewAcct(); // use BrassPlus::ViewAcct() If we don’t have virtual keyword for the function, the reference will use Brass::ViewAcct() in both line of code.\nWhen a method is declared virtual in a base class, it is automatically virtual in the derived class, but it is a good idea to document which functions are virtual by using the keyword virtual in the derived class declarations.\nThe Need for Virtual Destructors It’s also the usual practice to declare a virtual destructor for the base class. It ensures that the correct sequence of destructors is called.\nBrass *ptr = new BrassPlus(); delete ptr; // calls BrassPlus destructor // then automatically calls the base-class destructor How Virtual Functions Work The usual way compilers handle virtual functions is to add a hidden member to each object.The hidden member holds a pointer to an array of function addresses. Such an array is usually termed a virtual function table (vtbl). When we call a virtual function, the program looks at the vtbl address stored in an object and goes to the corresponding table of function addresses.\nIn short, using virtual functions has the following modest costs in memory and execution speed:\nEach object has its size increased by the amount needed to hold an address For each class, the compiler creates a table (an array) of addresses of virtual functions For each function call, there’s an extra step of going to a table to look up an address Redefinition Hides Methods Suppose we create something like the following:\nclass Dwelling { public: virtual void showperks(int a) const; ... }; class Hovel : public Dwelling { public: virtual void showperks() const; ... }; Hovel trump; trump.showperks(); // valid trump.showperks(5); // invalid The new showperks() function that takes no arguments will hide the base class version that takes an int argument (it actually hides all base-class methods of the same name), instead of overloading the function.\nIf the base class declaration is overloaded, we need to redefine all the base-class version in the derived class.\nclass Dwelling { public: // three overloaded showperks() virtual void showperks(int a) const; virtual void showperks(double x) const; virtual void showperks() const; ... }; class Hovel : public Dwelling { public: // three redefined showperks() virtual void showperks(int a) const; virtual void showperks(double x) const; virtual void showperks() const; ... }; If we redefine just one version, the other two become hidden and cannot be used by objects of the derived class.\nAccess Control: protected The protected keyword is like private in outside world and public for derived class. It’s useful for derived class to access to internal functions that are not available publicly.\nAbstract Base Classes (ABC) Suppose we want to create two classes, Circle and Ellipse. Of course we can first write the Ellipse class and then write the Circle class by inheriting the Ellipse class, since a circle is-a ellipse. However, this derivation is awkward, because circle is simpler than ellipse. It seems simpler to define a Circle class without using inheritance.\nThe useful thing about ABC is that we can extract the same part of circle and ellipse, and derive the Circle and Ellipse classes from the ABC. For the different part of circle and ellipse, we can create pure virtual functions in ABC and let derived class to override them.\nWhen a class contains a pure virtual function, we can’t create an object of that class. C++ allows even a pure virtual funciton to have a definition. We can make the prototype virtual but still provide a definition in the implementation file.\nInheritance and Dynamic Memory Allocation When both the base class and the derived class use dynamic memory allocation, the derived-class destructor, copy constructor,and assignment operator all must use their base-class counterparts to handle the base-class component.\nFor a destructor, it is done automatically.\nbaseDMA::~baseDMA() // takes care of baseDMA stuff { delete [] label; } hasDMA::~hasDMA() // takes care of hasDMA stuff { delete [] style; } For a copy constructor, it is accomplished by invoking the base-class copy constructor in the member initialization list, or else the default constructor is invoked automatically.\nbaseDMA::baseDMA(const baseDMA \u0026 rs) { label = new char[std::strlen(rs.label) + 1]; std::strcpy(label, rs.label); rating = rs.rating; } hasDMA::hasDMA(const hasDMA \u0026 hs): baseDMA(hs) { style = new char[std::strlen(hs.style) + 1]; std::strcpy(style, hs.style); } For the assignment operator, it is accomplished by using the scope-resolution operator in an explicit call of the base-class assignment operator.\nbaseDMA \u0026 baseDMA::operator=(const baseDMA \u0026 rs) { if (this == \u0026rs) return *this; delete [] label; label = new char[std::strlen(rs.label) + 1]; std::strcpy(label, rs.label); rating = rs.rating; return *this; } hasDMA \u0026 hasDMA::operator=(const hasDMA \u0026 hs) { if (this == \u0026hs) return *this; baseDMA::operator=(hs); // copy base portion, same as *this = hs delete [] style; // prepare for new style style = new char[std::strlen(hs.style) + 1]; std::strcpy(style, hs.style); return *this; } Chapter 14: Reusing Code in C++ Private Inheritance We use public inheritance to create is-a relationship, however, when we use private inheritance, it creates has-a relationship.\nIt seems weird to use a private inheritance, since we have no right to access base class methods in the outside world, but actually, the derived class contains all the members and data of the base class, so it creates has-a relationship.\nStudent Class Example Let’s say we want to create a Student class, the class should contain a string member and a valarray member. We could use containment to do so, but try private inheritance in here.\nclass Student : private std::string, private std::valarray\u003cdouble\u003e { public: ... }; We don’t need to create private data in the Student class, it’s because the two inherited base class already provide all the needed data members.\nInitializing Base-Class Components // containment Student(const char * str, const double * pd, int n) : name(str), scores(pd, n) {} // use object names for containment // private inheritance Student(const char * str, const double * pd, int n) : std::string(str), std::valarray\u003cdouble\u003e(pd, n) {} // use class names for inheritance Accessing Base-Class Methods Containment adds an object to a class as a named member object, and we use the variable name as a interface to access the class. Private inheritance provides the same feature as containment, but only without the interface, however, inheritance lets you use the class name and the scope-resolution operator to invoke base-class methods:\n// containment double Student::Average() const { if (scores.size() \u003e 0) return scores.sum()/scores.size(); else return 0; } // private inheritance double Student::Average() const { if (ArrayDb::size() \u003e 0) return ArrayDb::sum()/ArrayDb::size(); else reutrn 0; } Accessing Base-Class Objects The way to access base-class objects is to use a type cast. Because Student is derived from a string, it’s possible to type cast a Student object to a string object.\nconst string \u0026 Student::Name() const { return (const string \u0026) *this; } Accessing Base-Class Friends We use explicit type cast to invoke the correct functions. This is basically the same technique used to access a base-class object in a class method.\nostream \u0026 operator\u003c\u003c(ostream \u0026 os, const Student \u0026 stu) { os \u003c\u003c \"Scores for \" \u003c\u003c (const String \u0026) stu \u003c\u003c \":\\n\"; ... } \u003c\u003c (const String \u0026) stu converts stu to a string object, then invokes the operator\u003c\u003c(ostream \u0026, const string \u0026) function.\nThe revised Student class Student\nContainment or Private Inheritance? Both containment and private inheritance can create has-a relationship, but which one should we use? In general, we should use containment to model a has-a relationship, and use private inheritance if the new class needs to access protected members in the original class or if it needs to redefine virtual functions.\nProtected Inheritance With protected inheritance, public and protected members of a base class become protected members of the derived class. The main difference between private and protected inheritance is when we derive another class from a derived class.\nRedefining Access with using Suppose we want to make a particular base-class method available publicly in the derived class. A easy way is to define a derived-class method that uses the base-class method. For example:\ndouble Student::sum() const // public Student method { return std::valarray\u003cdouble\u003e::sum(); // use privately-inherited method } Another way is to use a using declaration. For example:\nclass Student : private std::string, private std::valarray\u003cdouble\u003e { ... public: using std::valarray\u003cdouble\u003e::min; using std::valarray\u003cdouble\u003e::max; ... }; The using declaration makes the valarray::min() and valarray::max() methods available as if they were public Student methods.\nMultiple Inheritance Let’s say we have a base class called Worker, and two derived class, Singer and Waiter. We can derive a SingingWaiter class from Singer and Waiter class:\nclass SingingWaiter : public Waiter, public Singer {...}; This is called multiple inheritance (MI).\nMI can cause new problems.\ninheriting different methods with the same name from two different base classes inheriting nultiple instances of a class via two or more related immediate base class (SingingWaiter class encounters) Let’s look at an example.\nWorker0\nThe main difference between Singer and Worker class is the Show function. What will happen if we call the Show function in SingingWaiter class?\nHow Many Workers? SingingWaiter winds up two Worker components.\nWe can assign the address of a derived-class object to a base-class pointer, however, this does not work in MI, since it’s ambiguous now. We should specify which Worker we are pointing at:\nSingingWaiter ed; Worker * pw = \u0026ed; // ambiguous Worker * pw1 = (Waiter *) \u0026ed; // the Worker in Waiter Worker * pw2 = (Singer *) \u0026ed; // the Worker in Singer Virtual Base Classes Virtual base classes allow an object derived from multiple bases that themselves share a common base to inherit just one object of that shared base class.\nWe would make Worker a virtual base class to Singer and Waiter by using the keyword virtual in the class declarations:\n// both order is valid class Singer : virtual public Worker {...}; class Waiter : public virtual Worker {...}; // define SingingWaiter as before class SingingWaiter: public Singer, public Waiter {...}; New Constructor Rules C++ disables the automatic passing of information through an intermediate class to a base class if the base class is virtual. We have to call the virtual base class constructor explicitly.\n// wk will not be pass down to base class constructor, it will use default base class constructor SingingWaiter(const Worker \u0026 wk, int p = 0, int v = Singer::other) : Waiter(wk,p), Singer(wk,v) {} // flawed // the correct way to initialize, this will work only if we have virtual base class SingingWaiter(const Worker \u0026 wk, int p = 0, int v = Singer::other) : Worker(wk), Waiter(wk,p), Singer(wk,v) {} Which Method? Use scope-resolution operator to clarify which funciton we want to invoke.\nSingingWaiter newhire(\"Elise Hawks\", 2005, 6, soprano); newhire.Show(); // ambiguous SingingWaiter newhire(\"Elise Hawks\", 2005, 6, soprano); newhire.Singer::Show(); // use Singer version A better way is to redefine Show() for SingingWaiter and specify which Show() to use (or use both).\nHowever, the Show() function is an increment approach.\nvoid Worker::Show() const { cout \u003c\u003c \"Name: \" \u003c\u003c fullname \u003c\u003c \"\\n\"; cout \u003c\u003c \"Employee ID: \" \u003c\u003c id \u003c\u003c \"\\n\"; } void Waiter::Show() const { cout \u003c\u003c \"Category: waiter\\n\"; Worker::Show(); cout \u003c\u003c \"Panache rating: \" \u003c\u003c panache \u003c\u003c \"\\n\"; } void Singer::Show() const { cout \u003c\u003c \"Category: singer\\n\"; Worker::Show(); cout \u003c\u003c \"Vocal range: \" \u003c\u003c pv[voice] \u003c\u003c endl; } We can’t combine Waiter::Show() and Singer::Show() without calling Worker::Show() twice.\nWe can use a modular approach to solve this. That is, providing a method that displays only the new components.\nvoid Worker::Data() const { cout \u003c\u003c \"Name: \" \u003c\u003c fullname \u003c\u003c \"\\n\"; cout \u003c\u003c \"Employee ID: \" \u003c\u003c id \u003c\u003c \"\\n\"; } void Waiter::Data() const { cout \u003c\u003c \"Panache rating: \" \u003c\u003c panache \u003c\u003c \"\\n\"; } void Singer::Data() const { cout \u003c\u003c \"Vocal range: \" \u003c\u003c pv[voice] \u003c\u003c \"\\n\"; } void SingingWaiter::Data() const { Singer::Data(); Waiter::Data(); } void SingingWaiter::Show() const { cout \u003c\u003c \"Category: singing waiter\\n\"; Worker::Data(); Data(); } Mixed Virtual and Nonvirtual Bases Suppose, for example, that class B is a virtual base class to classes C and D and a nonvirtual base class to classes X and Y. Furthermore, suppose class M is derived from C, D, X, and Y. In this case, class M contains one class B subobject for all the virtually derived ancestors (that is, classes C and D) and a separate class B subobject for each nonvirtual ancestor (that is, classes X and Y). So, all told, it would contain three class B subobjects.\nVirtual Base Classes and Dominance With nonvirtual base classes, if a class inherits two or more members (data or methods) with the same name from different classes, using that name without qualifying it with a class name is ambiguous. If virtual base classes are involved, however, such a use may or may not be ambiguous. In this case, if one name dominates all others, it can be used unambiguously without a qualifier.\nclass B { public: short q(); } class C : virtual public B { public: long q(); int omg() }; class D : public C {}; class E : virtual public B { private: int omg(); }; class F: public D, public E {}; The q() from class C dominates the definition in class B, thus, methods in F can use q() to denote C::q(). Neither definition of omg() dominates the other, therefore, we must add qualifier.\nThe virtual ambiguity rules pay no attention to access rules. That is, even if E::omg() is private, using omg() is ambiguous. Even if C::q() is private, q() would still refer to inaccessible C::q().\nClass Templates Let’s just see a template example.\n// stacktp.h -- a stack template #ifndef STACKTP_H_ #define STACKTP_H_ template \u003ctypename Type\u003e class Stack { private: enum {MAX = 10}; // constant specific to class Type items[MAX]; // holds stack items int top; // index for top stack item public: Stack(); bool isempty(); bool isfull(); bool push(const Type \u0026 item); // add item to stack bool pop(Type \u0026 item); // pop top into item }; template \u003ctypename Type\u003e Stack\u003cType\u003e::Stack() { top = 0; } template \u003ctypename Type\u003e bool Stack\u003cType\u003e::isempty() { return top == 0; } template \u003ctypename Type\u003e bool Stack\u003cType\u003e::isfull() { return top == MAX; } template \u003ctypename Type\u003e bool Stack\u003cType\u003e::push(const Type \u0026 item) { if (top \u003c MAX) { items[top++] = item; return true; } else return false; } template \u003ctypename Type\u003e bool Stack\u003cType\u003e::pop(Type \u0026 item) { if (top \u003e 0) { item = items[--top]; return true; } else return false; } #endif Notice that we have to put class declaration and definition in the same file, since class templates are not class, they are just instructions to the compiler about how to generate class (same as funciton templates).\nAn Array Template Example and Non-Type Arguments Let’s begin with a simple array template that lets you specify an array size. One is to use a dynamic array and a constructor argument to provide the number of elements.\ntemplate \u003cclass T\u003e Stack\u003cT\u003e::Stack(int ss): stacksize(ss), top(0){ items = new Type [stacksize] } Another approach is to use a template argument to provide the number of elements. This is what std::array does.\ntemplate\u003cclass T, int n\u003e class ArrayTP{ private: T ar[n]; ... } T is a type parameter, or type argument. n is called a non-type, or expression argument.\nExpression arguments can be an integer type, an enumerration type, a reference, or a pointer. Also the template code can’t alter the value of the arument or take its address. Also when instantiating a template, the expression argument should be a constant expression.\nThe constructor approach (the Stack example) uses heap memory, whereas the expressoin argument approach uses memory stack. This provides faster execution time, particularly if we have a lot of small arrays.\nHowever, the drawback is that different array sizes generate different templates. Also, the constructor approach is more versatile, since you can resize the array.\nTemplate Versatility Using More Than One Type Parameter We can also write this:\ntemplate \u003cclass T1, class T2\u003e class Pair{ private: T1 a; T2 b; ... } Default Type Template Parameters template \u003cclass T1, class T2 = int\u003e class Topo {...}; Topo\u003cdouble, double\u003e m1; // T1 is double, T2 is double Topo\u003cdouble\u003e m2; // T1 is double, T2 is int Template Specializations It is similar to function templates.\nImplicit Instantiations The compiler doesn’t generate an implicit instantiation of the class until it needs an object:\nArrayTP\u003cdouble, 30\u003e * pt; // a pointer, no object needed yet pt = new ArrayTP\u003cdouble, 30\u003e; // now an object is needed Explicit Instantiations template class ArrayTP\u003cstring, 100\u003e; // generate ArrayTP class The compiler generates the class definition, including method definitions, even though no object of the class has yet been created or mentioned.\nExplicit Specializations Tells the compiler to generate the template in a particular way.\nLet’s say we have a template, and we want to specialize it when the type is const char *:\ntemplate \u003ctypename T\u003e class SortedArray { ...// details omitted }; // specialization template \u003c\u003e class SortedArray\u003cconst char *\u003e { ...// details omitted }; Partial Specializations // general template template \u003cclass T1, class T2\u003e class Pair {...}; // specialization with T2 set to int template \u003cclass T1\u003e class Pair\u003cT1, int\u003e {...}; // specialization with T1 and T2 set to int template \u003c\u003e class Pair\u003cint, int\u003e {...}; Pair\u003cdouble, double\u003e p1; // use general Pair template Pair\u003cdouble, int\u003e p2; // use Pair partial specialization Pair\u003cint, int\u003e p3; // use Pair explicit specialization template\u003cclass T\u003e class Feeb { ... };// general version template\u003cclass T*\u003e class Feeb { ... };// pointer partial specialization Feeb\u003cchar\u003e fb1; // use general Feeb template, T is char Feeb\u003cchar *\u003e fb2; // use Feeb T* specialization, T is char // general template template \u003cclass T1, class T2, class T3\u003e class Trio{...}; // specialization with T3 set to T2 template \u003cclass T1, class T2\u003e class Trio\u003cT1, T2, T2\u003e {...}; // specialization with T3 and T2 set to T1* template \u003cclass T1\u003e class Trio\u003cT1, T1*, T1*\u003e {...}; Trio\u003cint, short, char *\u003e t1; // use general template Trio\u003cint, short\u003e t2; // use Trio Trio\u003cchar, char *, char *\u003e t3; use Trio\u003cT1, T1*, T1*\u003e Member Templates A template can be a member of a structure, class, or template class.\ntemplate \u003ctypename T\u003e class beta { private: template \u003ctypename V\u003e // nested template class member class hold { private: V val; public: hold(V v = 0) : val(v) {} void show() const { cout \u003c\u003c val \u003c\u003c endl; } V Value() const { return val; } }; hold\u003cT\u003e q; // template object hold\u003cint\u003e n; // template object public: beta( T t, int i) : q(t), n(i) {} template\u003ctypename U\u003e // template method U blab(U u, T t) { return (n.Value() + q.Value()) * u / t; } void Show() const { q.show(); n.show();} }; We can also write the definition outside the class template, but it depends on the compiler. Some compilers don’t support.\ntemplate \u003ctypename T\u003e class beta { private: template \u003ctypename V\u003e // declaration class hold; hold\u003cT\u003e q; hold\u003cint\u003e n; public: beta( T t, int i) : q(t), n(i) {} template\u003ctypename U\u003e // declaration U blab(U u, T t); void Show() const { q.show(); n.show();} }; // member definition template \u003ctypename T\u003e template\u003ctypename V\u003e class beta\u003cT\u003e::hold { private: V val; public: hold(V v = 0) : val(v) {} void show() const { std::cout \u003c\u003c val \u003c\u003c std::endl; } V Value() const { return val; } }; // member definition template \u003ctypename T\u003e template \u003ctypename U\u003e U beta\u003cT\u003e::blab(U u, T t) { return (n.Value() + q.Value()) * u / t; } Templates As Parameters We can write:\ntemplate \u003ctemplate \u003ctypename T\u003e class Thing\u003e class Crab Here template class is the type, and Thing is the parameter. Suppose we have this declaration Crab legs;. Then the template argument King must be a template class whose declaration look like this：\ntemplate \u003ctypename T\u003e class King {...}; For example:\ntemplate \u003ctemplate \u003ctypename T\u003e class Thing\u003e class Crab { private: Thing\u003cint\u003e s1; Thing\u003cdouble\u003e s2; public: Crab() {}; // assumes the thing class has push() and pop() members bool push(int a, double x) { return s1.push(a) \u0026\u0026 s2.push(x); } bool pop(int \u0026 a, double \u0026 x){ return s1.pop(a) \u0026\u0026 s2.pop(x); } }; // create object Crab\u003cStack\u003e nebula; We can also mix template parameters with regular parameters.\ntemplate \u003ctemplate \u003ctypename T\u003e class Thing, typename U, typename V\u003e class Crab{ private: Thing\u003cU\u003e s1; Thing\u003cV\u003e s2; ... } Crab\u003cStack, int, double\u003e nebula; // T=Stack, U=int, V=double Template Classes and Friends Template class declarations can have friends, too. There are three categories of templates’ friend:\nNon-template friends Bound template friends, meaning the type of the friend is determined by the type of the class when a class is instantiated Unbound template friends, meaning that all specializations of the friend are friends to each specialization of the class Non-Template Friend Functions to Template Classes template \u003cclass T\u003e class HasFriend { public: friend void counts(); // friend to all HasFriend instantiations ... }; This declaration makes the counts() function a friend to all instantiations of the template. But the problem is, how do this function access a HasFriend object without having any parameter?\nIt could access a global object; it could access nonglobal objects by using a global pointer; it could create its own objects; and it could access static data members of a template class, which exist separately from an object.\nWhat if we want to pass an object as a parameter? Can we write:\nfriend void report(HasFriend \u0026); The answer is no. The reason is that HasFriend is not a object. We need to indicate a specialization. For example:\ntemplate \u003cclass T\u003e class HasFriend { public: friend void report(HasFriend\u003cT\u003e \u0026); // bound template friend ... }; Notice that report() is not a template function; it just has a parameter that is a template. This means that you have to define explicit specializations for the friends you plan to use:\nvoid report(HasFriend\u003cshort\u003e \u0026) {...}; // explicit specialization for short void report(HasFriend\u003cint\u003e \u0026) {...}; // explicit specialization for int Bound Template Friend Functions to Template Classes We can make friend functions a template and bound them with each specialization.\nFirst, declare each template function before the class definition.\ntemplate \u003ctypename T\u003e void counts(); template \u003ctypename T\u003e void report(T \u0026); Then declare the templates as friends inside the function:\ntemplate \u003ctypename TT\u003e class HasFriendT { ... friend void counts\u003cTT\u003e(); friend void report\u003c\u003e(HasFriendT\u003cTT\u003e \u0026); // same as report","wordCount":"11385","inLanguage":"en","datePublished":"2024-01-05T12:00:00+08:00","dateModified":"2024-01-05T12:00:00+08:00","author":{"@type":"Person","name":"cwHsueh"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/blog/posts/c++-primer-plus/"},"publisher":{"@type":"Organization","name":"cwHsueh","logo":{"@type":"ImageObject","url":"http://localhost:1313/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/blog/ accesskey=h title="cwHsueh (Alt + H)">cwHsueh</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://cwhsueh.com title=about><span>about</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li><li><a href=http://localhost:1313/blog/leetcode/ title=leetcode><span>leetcode</span></a></li><li><a href=http://localhost:1313/blog/tags/ title=tags><span>tags</span></a></li><li><a href=http://localhost:1313/blog/archives/ title=archive><span>archive</span></a></li><li><a href=http://localhost:1313/blog/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://localhost:1313/blog/>Home</a>&nbsp;»&nbsp;<a href=http://localhost:1313/blog/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">C++ Primer Plus notes</h1><div class=post-meta><span title='2024-01-05 12:00:00 +0800 +0800'>January 5, 2024</span>&nbsp;·&nbsp;54 min&nbsp;·&nbsp;11385 words&nbsp;·&nbsp;cwHsueh</div></header><div class=post-content><h2 id=chapter-4>Chapter 4<a hidden class=anchor aria-hidden=true href=#chapter-4>#</a></h2><h3 id=union>Union<a hidden class=anchor aria-hidden=true href=#union>#</a></h3><p>union is a data structure that can store different types of data, but it can only store one type of data at a time. The size of union is the size of its largest data.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>union</span> <span class=nc>one4all</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>int_val</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>long</span> <span class=n>long_val</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>double</span> <span class=n>double_val</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>one4all</span> <span class=n>pail</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>pail</span><span class=p>.</span><span class=n>int_val</span> <span class=o>=</span> <span class=mi>15</span><span class=p>;</span> <span class=c1>// store an int
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>pail</span><span class=p>.</span><span class=n>int_val</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>pail</span><span class=p>.</span><span class=n>double_val</span> <span class=o>=</span> <span class=mf>1.38</span><span class=p>;</span> <span class=c1>// store a double, int value is lost
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>pail</span><span class=p>.</span><span class=n>double_val</span><span class=p>;</span>
</span></span></code></pre></div><h3 id=enumerations>Enumerations<a hidden class=anchor aria-hidden=true href=#enumerations>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>enum</span> <span class=nc>spectrum</span> <span class=p>{</span><span class=n>red</span><span class=p>,</span> <span class=n>orange</span><span class=p>,</span> <span class=n>yellow</span><span class=p>,</span> <span class=n>green</span><span class=p>,</span> <span class=n>blue</span><span class=p>,</span> <span class=n>violet</span><span class=p>,</span> <span class=n>indigo</span><span class=p>,</span> <span class=n>ultraviolet</span><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>spectrum</span> <span class=n>band</span><span class=p>;</span> <span class=c1>// band a variable of type spectrum
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>band</span> <span class=o>=</span> <span class=n>blue</span><span class=p>;</span> <span class=c1>// valid, blue is an enumerator
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>band</span> <span class=o>=</span> <span class=mi>2000</span><span class=p>;</span> <span class=c1>// invalid, 2000 not an enumerator
</span></span></span></code></pre></div><p>Enumarators are integer type, and can be converted to <code>int</code>, but not reversely.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>int</span> <span class=n>color</span> <span class=o>=</span> <span class=n>blue</span><span class=p>;</span> <span class=c1>// valid, spectrum type promoted to int
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>band</span> <span class=o>=</span> <span class=mi>3</span><span class=p>;</span> <span class=c1>// invalid, int not converted to spectrum
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>band</span> <span class=o>=</span> <span class=n>orange</span> <span class=o>+</span> <span class=n>red</span><span class=p>;</span> <span class=c1>// not valid, but a little tricky, int not converted to spectrum
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>band</span> <span class=o>=</span> <span class=n>orange</span><span class=p>;</span> <span class=c1>// valid
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>color</span> <span class=o>=</span> <span class=mi>3</span> <span class=o>+</span> <span class=n>red</span><span class=p>;</span> <span class=c1>// valid, red converted to int
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>band</span> <span class=o>=</span> <span class=n>spectrum</span><span class=p>(</span><span class=mi>3</span><span class=p>);</span> <span class=c1>// typecast 3 to type spectrum
</span></span></span></code></pre></div><p>In practice, enumerations are used more often as a way of defining related symbolic constants than as a means of defining new types.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>enum</span> <span class=nc>bits</span><span class=p>{</span><span class=n>one</span> <span class=o>=</span> <span class=mi>1</span><span class=p>,</span> <span class=n>two</span> <span class=o>=</span> <span class=mi>2</span><span class=p>,</span> <span class=n>four</span> <span class=o>=</span> <span class=mi>4</span><span class=p>,</span> <span class=n>eight</span> <span class=o>=</span> <span class=mi>8</span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>enum</span> <span class=nc>bigstep</span><span class=p>{</span><span class=n>first</span><span class=p>,</span> <span class=n>second</span> <span class=o>=</span> <span class=mi>100</span><span class=p>,</span> <span class=n>third</span><span class=p>};</span> <span class=c1>// first = 0, third = 101
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>enum</span> <span class=p>{</span><span class=n>zero</span><span class=p>,</span> <span class=n>null</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=n>one</span><span class=p>,</span> <span class=n>numero_uno</span> <span class=o>=</span> <span class=mi>1</span><span class=p>};</span> <span class=c1>// zero = 0, one = 1
</span></span></span></code></pre></div><h3 id=pointers>Pointers<a hidden class=anchor aria-hidden=true href=#pointers>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>int</span> <span class=n>array</span><span class=p>[</span><span class=mi>3</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=o>*</span><span class=n>ptr</span> <span class=o>=</span> <span class=n>array</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=c1>// array = &amp;array[0] = address of first element of array
</span></span></span><span class=line><span class=cl><span class=c1>// &amp;array = address of whole array = int (*ptr) [3] = pointer that points to array-of-3-ints
</span></span></span></code></pre></div><p><code>array</code> is the address of a 4-byte block of memory, <code>&amp;array</code> is the address of a 12-byte block of memory.<br><code>array + 1</code> adds 4 to the address value, <code>&amp;array + 1</code> adds 12 to the address value</p><p>A way to describe the type of variable is to remove the variable name, for example, <code>short (*pas)[20]</code>, <code>pas</code> points to array of 20 shorts, the type of <code>pas</code> is <code>short (*)[20]</code></p><p><code>sizeof(array_name)</code> = size of the array<br><code>sizeof(pointer_name)</code> = size of the pointer</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>int</span> <span class=o>*</span><span class=n>pt</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>int</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>delete</span> <span class=n>pt</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>delete</span> <span class=p>[]</span> <span class=n>pt</span><span class=p>;</span> <span class=c1>// effect is undefined, don&#39;t do it
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=o>*</span><span class=n>ps</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>int</span> <span class=p>[</span><span class=mi>10</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=k>delete</span> <span class=p>[]</span> <span class=n>ps</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>delete</span> <span class=n>ps</span><span class=p>;</span> <span class=c1>// effect is undefined, don&#39;t do it
</span></span></span></code></pre></div><ol><li>Use <code>delete []</code> if you used <code>new []</code> to allocate an array.</li><li>Use <code>delete</code> (no brackets) if you used <code>new</code> to allocate a single entity.</li></ol><h2 id=chapter-5-loops-and-relational-expressions>Chapter 5: Loops and Relational Expressions<a hidden class=anchor aria-hidden=true href=#chapter-5-loops-and-relational-expressions>#</a></h2><h3 id=prefix-and-postfix-increment>Prefix and Postfix increment<a hidden class=anchor aria-hidden=true href=#prefix-and-postfix-increment>#</a></h3><p>In prefix increment <code>++i</code>, it increments the value and return the value. However, in postfix increment <code>i++</code>, it copys the value, increments the value, then returns the copy of the value.<br>For classes, the prefix version is more efficient than the postfix version.</p><h3 id=type-aliases>Type Aliases<a hidden class=anchor aria-hidden=true href=#type-aliases>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=cp>#define BYTE char </span><span class=c1>// preprocessor replaces BYTE with char
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>typedef</span> <span class=kt>char</span> <span class=n>btye</span> <span class=c1>// makes byte an alias for char
</span></span></span><span class=line><span class=cl><span class=c1>// typedef typeName aliasName
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>typedef</span> <span class=kt>char</span> <span class=o>*</span> <span class=n>byte_pointer</span><span class=p>;</span> <span class=c1>// pointer to char type
</span></span></span></code></pre></div><p>It&rsquo;s better to use <code>typedef</code> instead of <code>#define</code>. Consider the following:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=cp>#define FLOAT_POINTER float *
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=n>FLOAT_POINTER</span> <span class=n>pa</span><span class=p>,</span> <span class=n>pb</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// preprocessor substitution converts to
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>float</span> <span class=o>*</span> <span class=n>pa</span><span class=p>,</span> <span class=n>pb</span><span class=p>;</span> <span class=c1>// pa a pointer to float, pb just a float
</span></span></span></code></pre></div><p><code>typedef</code> approach doesn&rsquo;t have that problem.</p><h2 id=chapter-7-functions-cs-programming-modules>Chapter 7: Functions: C++’s Programming Modules<a hidden class=anchor aria-hidden=true href=#chapter-7-functions-cs-programming-modules>#</a></h2><h3 id=pointers-and-const>Pointers and <code>const</code><a hidden class=anchor aria-hidden=true href=#pointers-and-const>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>int</span> <span class=n>age</span> <span class=o>=</span> <span class=mi>39</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=kt>int</span> <span class=o>*</span> <span class=n>pt</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>age</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=o>*</span><span class=n>pt</span> <span class=o>+=</span> <span class=mi>1</span><span class=p>;</span> <span class=c1>// INVALID because pt points to a const int
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>cin</span> <span class=o>&gt;&gt;</span> <span class=o>*</span><span class=n>pt</span><span class=p>;</span> <span class=c1>// INVALID for the same reason
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>age</span> <span class=o>=</span> <span class=mi>20</span><span class=p>;</span> <span class=c1>// VALID because age is not declared to be const
</span></span></span></code></pre></div><p>Assigning the address of a <code>const</code> variable to a pointer-to-const is valid, however, assigning to regular pointer is not.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>const</span> <span class=kt>float</span> <span class=n>g_earth</span> <span class=o>=</span> <span class=mf>9.80</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=kt>float</span> <span class=o>*</span> <span class=n>pe</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>g_earth</span><span class=p>;</span> <span class=c1>// VALID
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=kt>float</span> <span class=n>g_moon</span> <span class=o>=</span> <span class=mf>1.63</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>float</span> <span class=o>*</span> <span class=n>pm</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>g_moon</span><span class=p>;</span> <span class=c1>// INVALID
</span></span></span></code></pre></div><p><code>const</code> doesn&rsquo;t prevent changing the value of <code>pt</code>, it prevents changing the value which <code>pt</code> points to.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>int</span> <span class=n>age</span> <span class=o>=</span> <span class=mi>39</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=kt>int</span> <span class=o>*</span> <span class=n>pt</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>age</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>sage</span> <span class=o>=</span> <span class=mi>80</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>pt</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>sage</span><span class=p>;</span> <span class=c1>// okay to point to another location
</span></span></span></code></pre></div><p>If you want to prevent changing the value of <code>pt</code>, write <code>DataType * const VariableName = &amp;Data</code>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>int</span> <span class=n>sloth</span> <span class=o>=</span> <span class=mi>3</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=kt>int</span> <span class=o>*</span> <span class=n>ps</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>sloth</span><span class=p>;</span> <span class=c1>// a pointer to const int
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=o>*</span> <span class=k>const</span> <span class=n>finger</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>sloth</span><span class=p>;</span> <span class=c1>// a const pointer to int
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=o>*</span><span class=n>finger</span> <span class=o>=</span> <span class=mi>4</span><span class=p>;</span> <span class=c1>// VALID
</span></span></span></code></pre></div><p><code>finger</code> and <code>*ps</code> are both const, and <code>*finger</code> and <code>ps</code> are not const.</p><h3 id=functions-and-two-dimensional-arrays>Functions and Two-Dimensional Arrays<a hidden class=anchor aria-hidden=true href=#functions-and-two-dimensional-arrays>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>int</span> <span class=n>data</span><span class=p>[</span><span class=mi>3</span><span class=p>][</span><span class=mi>4</span><span class=p>]</span> <span class=o>=</span> <span class=p>{{</span><span class=mi>1</span><span class=p>,</span><span class=mi>2</span><span class=p>,</span><span class=mi>3</span><span class=p>,</span><span class=mi>4</span><span class=p>},</span> <span class=p>{</span><span class=mi>9</span><span class=p>,</span><span class=mi>8</span><span class=p>,</span><span class=mi>7</span><span class=p>,</span><span class=mi>6</span><span class=p>},</span> <span class=p>{</span><span class=mi>2</span><span class=p>,</span><span class=mi>4</span><span class=p>,</span><span class=mi>6</span><span class=p>,</span><span class=mi>8</span><span class=p>}};</span>
</span></span></code></pre></div><p><code>data</code> is an array with three elements. The first element is an array of four <code>int</code> values. Hence, the type of <code>data</code> is pointer-to-array-of-four-int, so an appropriate prototype would be:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>int</span> <span class=nf>sum</span><span class=p>(</span><span class=kt>int</span> <span class=p>(</span><span class=o>*</span><span class=n>ar2</span><span class=p>)[</span><span class=mi>4</span><span class=p>],</span> <span class=kt>int</span> <span class=n>size</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>sum</span><span class=p>(</span><span class=kt>int</span> <span class=n>ar2</span><span class=p>[][</span><span class=mi>4</span><span class=p>],</span> <span class=kt>int</span> <span class=n>size</span><span class=p>);</span> <span class=c1>// VALID, more readable
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>sum</span><span class=p>(</span><span class=kt>int</span> <span class=o>*</span><span class=n>ar2</span><span class=p>[</span><span class=mi>4</span><span class=p>],</span> <span class=kt>int</span> <span class=n>size</span><span class=p>);</span> <span class=c1>// INVALID
</span></span></span></code></pre></div><p>Now the <code>sum</code> function works with arrays with four columns.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>int</span> <span class=n>a</span><span class=p>[</span><span class=mi>100</span><span class=p>][</span><span class=mi>4</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>b</span><span class=p>[</span><span class=mi>6</span><span class=p>][</span><span class=mi>4</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>total1</span> <span class=o>=</span> <span class=n>sum</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=mi>100</span><span class=p>);</span> <span class=c1>// sum all of a
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=n>total2</span> <span class=o>=</span> <span class=n>sum</span><span class=p>(</span><span class=n>b</span><span class=p>,</span> <span class=mi>6</span><span class=p>);</span> <span class=c1>// sum all of b
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=n>total3</span> <span class=o>=</span> <span class=n>sum</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=mi>10</span><span class=p>);</span> <span class=c1>// sum first 10 rows of a
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=n>total4</span> <span class=o>=</span> <span class=n>sum</span><span class=p>(</span><span class=n>a</span><span class=o>+</span><span class=mi>10</span><span class=p>,</span> <span class=mi>20</span><span class=p>);</span> <span class=c1>// sum next 20 rows of a
</span></span></span></code></pre></div><h3 id=pointers-to-functions>Pointers to Functions<a hidden class=anchor aria-hidden=true href=#pointers-to-functions>#</a></h3><p>Funcitons also have addresses. Pointers to functions are useful because we can pass in different functions in different times.</p><p>Here’s what a declaration of an appropriate pointer type looks like:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>double</span> <span class=nf>pam</span><span class=p>(</span><span class=kt>int</span><span class=p>);</span> <span class=c1>// prototype
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>double</span> <span class=p>(</span><span class=o>*</span><span class=n>pf</span><span class=p>)(</span><span class=kt>int</span><span class=p>);</span> <span class=c1>// pf points to a function that takes
</span></span></span><span class=line><span class=cl><span class=c1>// one int argument and that
</span></span></span><span class=line><span class=cl><span class=c1>// returns type double
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>double</span> <span class=o>*</span><span class=nf>pf</span><span class=p>(</span><span class=kt>int</span><span class=p>);</span> <span class=c1>// pf() a function that returns a pointer-to-double
</span></span></span></code></pre></div><p>We can use two ways to invoke a function with function pointers.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>double</span> <span class=nf>pam</span><span class=p>(</span><span class=kt>int</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>double</span> <span class=p>(</span><span class=o>*</span><span class=n>pf</span><span class=p>)(</span><span class=kt>int</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>pf</span> <span class=o>=</span> <span class=n>pam</span><span class=p>;</span> <span class=c1>// pf now points to the pam() function
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>double</span> <span class=n>x</span> <span class=o>=</span> <span class=n>pam</span><span class=p>(</span><span class=mi>4</span><span class=p>);</span> <span class=c1>// call pam() using the function name
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>double</span> <span class=n>y</span> <span class=o>=</span> <span class=p>(</span><span class=o>*</span><span class=n>pf</span><span class=p>)(</span><span class=mi>5</span><span class=p>);</span> <span class=c1>// call pam() using the pointer pf
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>double</span> <span class=n>y</span> <span class=o>=</span> <span class=n>pf</span><span class=p>(</span><span class=mi>5</span><span class=p>);</span> <span class=c1>// also call pam() using the pointer pf
</span></span></span><span class=line><span class=cl><span class=c1>// however, the previous one provides a visual reminder that the code is using a function pointer
</span></span></span></code></pre></div><h2 id=chapter-8-adventures-in-functions>Chapter 8: Adventures in Functions<a hidden class=anchor aria-hidden=true href=#chapter-8-adventures-in-functions>#</a></h2><h3 id=temporary-variables-reference-arguments-and-const>Temporary Variables, Reference Arguments, and <code>const</code><a hidden class=anchor aria-hidden=true href=#temporary-variables-reference-arguments-and-const>#</a></h3><p>When the reference parameter is a <code>const</code>, the compiler generates a temporary variable when:</p><ol><li>The actual argument is the correct type but isn’t an lvalue</li><li>The actual argument is of the wrong type, but can be conoverted to the corret type</li></ol><p>lvalue is a data object that can be referenced by address, such as variables, array elements, stucture members. Non-lvalue include literal constants and expressions with multiple terms.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>double</span> <span class=nf>refcube</span><span class=p>(</span><span class=k>const</span> <span class=kt>double</span> <span class=o>&amp;</span><span class=n>ra</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>ra</span> <span class=o>*</span> <span class=n>ra</span> <span class=o>*</span> <span class=n>ra</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kt>double</span> <span class=n>side</span> <span class=o>=</span> <span class=mf>3.0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>double</span> <span class=o>*</span> <span class=n>pd</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>side</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>double</span> <span class=o>&amp;</span> <span class=n>rd</span> <span class=o>=</span> <span class=n>side</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>long</span> <span class=n>edge</span> <span class=o>=</span> <span class=mi>5L</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>double</span> <span class=n>lens</span><span class=p>[</span><span class=mi>4</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span> <span class=mf>2.0</span><span class=p>,</span> <span class=mf>5.0</span><span class=p>,</span> <span class=mf>10.0</span><span class=p>,</span> <span class=mf>12.0</span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=kt>double</span> <span class=n>c1</span> <span class=o>=</span> <span class=n>refcube</span><span class=p>(</span><span class=n>side</span><span class=p>);</span> <span class=c1>// ra is side
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>double</span> <span class=n>c2</span> <span class=o>=</span> <span class=n>refcube</span><span class=p>(</span><span class=n>lens</span><span class=p>[</span><span class=mi>2</span><span class=p>]);</span> <span class=c1>// ra is lens[2]
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>double</span> <span class=n>c3</span> <span class=o>=</span> <span class=n>refcube</span><span class=p>(</span><span class=n>rd</span><span class=p>);</span> <span class=c1>// ra is rd is side
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>double</span> <span class=n>c4</span> <span class=o>=</span> <span class=n>refcube</span><span class=p>(</span><span class=o>*</span><span class=n>pd</span><span class=p>);</span> <span class=c1>// ra is *pd is side
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>double</span> <span class=n>c5</span> <span class=o>=</span> <span class=n>refcube</span><span class=p>(</span><span class=n>edge</span><span class=p>);</span> <span class=c1>// ra is temporary variable, long coverted to double
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>double</span> <span class=n>c6</span> <span class=o>=</span> <span class=n>refcube</span><span class=p>(</span><span class=mf>7.0</span><span class=p>);</span> <span class=c1>// ra is temporary variable, literal constants
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>double</span> <span class=n>c7</span> <span class=o>=</span> <span class=n>refcube</span><span class=p>(</span><span class=n>side</span> <span class=o>+</span> <span class=mf>10.0</span><span class=p>);</span> <span class=c1>// ra is temporary variable, multiple terms
</span></span></span></code></pre></div><p>Note that if <code>refcude</code> does not use constant references, c5, c6, c7 will show error. If there is no such rule, this will happen:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>void</span> <span class=nf>swapr</span><span class=p>(</span><span class=kt>int</span> <span class=o>&amp;</span> <span class=n>a</span><span class=p>,</span> <span class=kt>int</span> <span class=o>&amp;</span> <span class=n>b</span><span class=p>)</span> <span class=c1>// use references
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>temp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>temp</span> <span class=o>=</span> <span class=n>a</span><span class=p>;</span> <span class=c1>// use a, b for values of variables
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>a</span> <span class=o>=</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>b</span> <span class=o>=</span> <span class=n>temp</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kt>long</span> <span class=n>a</span> <span class=o>=</span> <span class=mi>3</span><span class=p>,</span> <span class=n>b</span> <span class=o>=</span> <span class=mi>5</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>swapr</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>);</span> <span class=c1>// swapping temporary variable instead of swapping a and b
</span></span></span></code></pre></div><p>In short, if the intent of a function with reference arguments is to modify variables passed as arguments, situations that create temporary variables thwart that purpose. Adding <code>const</code> means that we are not modifying them, so temporary variable cause no harm.</p><p>In C++11, there is a second kind of reference, called an rvalue reference. It&rsquo;s declared using <code>&&</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>double</span> <span class=o>&amp;&amp;</span> <span class=n>rref</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>sqrt</span><span class=p>(</span><span class=mf>36.00</span><span class=p>);</span> <span class=c1>// not allowed for double &amp;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>double</span> <span class=n>j</span> <span class=o>=</span> <span class=mf>15.0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>double</span> <span class=o>&amp;&amp;</span> <span class=n>jref</span> <span class=o>=</span> <span class=mf>2.0</span><span class=o>*</span> <span class=n>j</span> <span class=o>+</span> <span class=mf>18.5</span><span class=p>;</span> <span class=c1>// not allowed for double &amp;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>rref</span> <span class=o>&lt;&lt;</span> <span class=sc>&#39;\n&#39;</span><span class=p>;</span> <span class=c1>// display 6.0
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>jref</span> <span class=o>&lt;&lt;</span> <span class=sc>&#39;\n&#39;</span><span class=p>;</span> <span class=c1>// display 48.5;
</span></span></span></code></pre></div><p>The original reference type (<code>&</code>) is now called an lvalue reference.</p><h3 id=why-return-a-reference>Why Return a Reference?<a hidden class=anchor aria-hidden=true href=#why-return-a-reference>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>int</span> <span class=o>&amp;</span> <span class=n>square</span><span class=p>(</span><span class=kt>int</span> <span class=o>&amp;</span><span class=n>i</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=n>i</span> <span class=o>*=</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>x</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>y</span> <span class=o>=</span> <span class=n>square</span><span class=p>(</span><span class=n>x</span><span class=p>);</span> <span class=c1>// note that x and y have different address
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=o>&amp;</span><span class=n>z</span> <span class=o>=</span> <span class=n>square</span><span class=p>(</span><span class=n>x</span><span class=p>);</span> <span class=c1>// x and z have same address
</span></span></span></code></pre></div><p>If <code>square()</code> returned <code>int</code> instead of <code>int &</code>, this could involve copying the entire structure to a temporary location and then copying that copy to <code>y</code>. But with a reference return value, <code>x</code> is copied directly to <code>y</code>, a more efficient approach.</p><h3 id=being-careful-about-what-a-return-reference-refers-to>Being Careful About What a Return Reference Refers To<a hidden class=anchor aria-hidden=true href=#being-careful-about-what-a-return-reference-refers-to>#</a></h3><p>Avoid these lines:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>const</span> <span class=n>free_throws</span> <span class=o>&amp;</span> <span class=n>clone2</span><span class=p>(</span><span class=n>free_throws</span> <span class=o>&amp;</span> <span class=n>ft</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>free_throws</span> <span class=n>newguy</span><span class=p>;</span> <span class=c1>// first step to big error
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>newguy</span> <span class=o>=</span> <span class=n>ft</span><span class=p>;</span> <span class=c1>// copy info
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=n>newguy</span><span class=p>;</span> <span class=c1>// return reference to copy
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>It returns a reference to a temporary variable. The simplest way to avoid is to return a reference that was passed as an argument, like the <code>square()</code> function above.</p><p>Another way is to use <code>new</code> to create new storage.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>const</span> <span class=n>free_throws</span> <span class=o>&amp;</span> <span class=n>clone</span><span class=p>(</span><span class=n>free_throws</span> <span class=o>&amp;</span> <span class=n>ft</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>free_throws</span> <span class=o>*</span> <span class=n>pt</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=n>pt</span> <span class=o>=</span> <span class=n>ft</span><span class=p>;</span> <span class=c1>// copy info
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=o>*</span><span class=n>pt</span><span class=p>;</span> <span class=c1>// return reference to copy
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>However, it is easy to forget to use <code>delete</code> later.</p><h3 id=function-overloading>Function Overloading<a hidden class=anchor aria-hidden=true href=#function-overloading>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>void</span> <span class=nf>print</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span> <span class=n>str</span><span class=p>,</span> <span class=kt>int</span> <span class=n>width</span><span class=p>);</span> <span class=c1>// #1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>print</span><span class=p>(</span><span class=kt>double</span> <span class=n>d</span><span class=p>,</span> <span class=kt>int</span> <span class=n>width</span><span class=p>);</span> <span class=c1>// #2
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>print</span><span class=p>(</span><span class=kt>long</span> <span class=n>l</span><span class=p>,</span> <span class=kt>int</span> <span class=n>width</span><span class=p>);</span> <span class=c1>// #3
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>print</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=p>,</span> <span class=kt>int</span> <span class=n>width</span><span class=p>);</span> <span class=c1>// #4
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>print</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>str</span><span class=p>);</span> <span class=c1>// #5
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=n>print</span><span class=p>(</span><span class=s>&#34;Pancakes&#34;</span><span class=p>,</span> <span class=mi>15</span><span class=p>);</span> <span class=c1>// use #1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>print</span><span class=p>(</span><span class=s>&#34;Syrup&#34;</span><span class=p>);</span> <span class=c1>// use #5
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>print</span><span class=p>(</span><span class=mf>1999.0</span><span class=p>,</span> <span class=mi>10</span><span class=p>);</span> <span class=c1>// use #2
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>print</span><span class=p>(</span><span class=mi>1999</span><span class=p>,</span> <span class=mi>12</span><span class=p>);</span> <span class=c1>// use #4
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>print</span><span class=p>(</span><span class=mi>1999L</span><span class=p>,</span> <span class=mi>15</span><span class=p>);</span> <span class=c1>// use #3
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>year</span> <span class=o>=</span> <span class=mi>3210</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>print</span><span class=p>(</span><span class=n>year</span><span class=p>,</span> <span class=mi>6</span><span class=p>);</span> <span class=c1>// ambiguous call, error
</span></span></span><span class=line><span class=cl><span class=c1>// If the only print() prototype were #2, then print(year, 6) will convert to type double
</span></span></span></code></pre></div><p>The function-matching process does discriminate between const and non-const variables.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>void</span> <span class=nf>dribble</span><span class=p>(</span><span class=kt>char</span> <span class=o>*</span> <span class=n>bits</span><span class=p>);</span> <span class=c1>// overloaded
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>dribble</span> <span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>cbits</span><span class=p>);</span> <span class=c1>// overloaded
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>dabble</span><span class=p>(</span><span class=kt>char</span> <span class=o>*</span> <span class=n>bits</span><span class=p>);</span> <span class=c1>// not overloaded
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>drivel</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span> <span class=n>bits</span><span class=p>);</span> <span class=c1>// not overloaded
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=kt>char</span> <span class=n>p1</span><span class=p>[</span><span class=mi>20</span><span class=p>]</span> <span class=o>=</span> <span class=s>&#34;How&#39;s the weather?&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>char</span> <span class=n>p2</span><span class=p>[</span><span class=mi>20</span><span class=p>]</span> <span class=o>=</span> <span class=s>&#34;How&#39;s business?&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>dribble</span><span class=p>(</span><span class=n>p1</span><span class=p>);</span> <span class=c1>// dribble(const char *);
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>dribble</span><span class=p>(</span><span class=n>p2</span><span class=p>);</span> <span class=c1>// dribble(char *);
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>dabble</span><span class=p>(</span><span class=n>p1</span><span class=p>);</span> <span class=c1>// no match
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>dabble</span><span class=p>(</span><span class=n>p2</span><span class=p>);</span> <span class=c1>// dabble(char *);
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>drivel</span><span class=p>(</span><span class=n>p1</span><span class=p>);</span> <span class=c1>// drivel(const char *);
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>drivel</span><span class=p>(</span><span class=n>p2</span><span class=p>);</span> <span class=c1>// drivel(const char *); since it&#39;s valid to assign non-const value to a const variable, but not vice versa
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>stove</span><span class=p>(</span><span class=kt>double</span> <span class=o>&amp;</span> <span class=n>r1</span><span class=p>);</span> <span class=c1>// matches modifiable lvalue
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>stove</span><span class=p>(</span><span class=k>const</span> <span class=kt>double</span> <span class=o>&amp;</span> <span class=n>r2</span><span class=p>);</span> <span class=c1>// matches const lvalue
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>stove</span><span class=p>(</span><span class=kt>double</span> <span class=o>&amp;&amp;</span> <span class=n>r3</span><span class=p>);</span> <span class=c1>// matches rvalue
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>double</span> <span class=n>x</span> <span class=o>=</span> <span class=mf>55.5</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=kt>double</span> <span class=n>y</span> <span class=o>=</span> <span class=mf>32.0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>stove</span><span class=p>(</span><span class=n>x</span><span class=p>);</span> <span class=c1>// calls stove(double &amp;)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>stove</span><span class=p>(</span><span class=n>y</span><span class=p>);</span> <span class=c1>// calls stove(const double &amp;)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>stove</span><span class=p>(</span><span class=n>x</span><span class=o>+</span><span class=n>y</span><span class=p>);</span> <span class=c1>// calls stove(double &amp;&amp;)
</span></span></span><span class=line><span class=cl><span class=c1>// If we omit the stove(double &amp;&amp;) function, then stove(x + y) will call the stove(const double &amp;) funciton instead
</span></span></span></code></pre></div><h3 id=function-templates>Function Templates<a hidden class=anchor aria-hidden=true href=#function-templates>#</a></h3><p>Let&rsquo;s say we want to create <code>swap()</code> function that can swap two same type of data. One approach is to duplicate the function and overload it, however, it&rsquo;s a waste of time and if we make changes to one function, we have to change every functions.</p><p>We can set up a swapping template like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>AnyType</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>Swap</span><span class=p>(</span><span class=n>AnyType</span> <span class=o>&amp;</span><span class=n>a</span><span class=p>,</span> <span class=n>AnyType</span> <span class=o>&amp;</span><span class=n>b</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>AnyType</span> <span class=n>temp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>temp</span> <span class=o>=</span> <span class=n>a</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>a</span> <span class=o>=</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>b</span> <span class=o>=</span> <span class=n>temp</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The template does not create any functions.Instead, it provides the compiler with directions about how to define a function. If you want a function to swap <code>int</code>s, then the compiler creates a function following the template pattern, substituting <code>int</code> for <code>AnyType</code>.</p><h3 id=overloaded-templates>Overloaded Templates<a hidden class=anchor aria-hidden=true href=#overloaded-templates>#</a></h3><p>If we want to create <code>swap()</code> function for C arrays, we can overload templates.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>Swap</span><span class=p>(</span><span class=n>T</span> <span class=o>&amp;</span><span class=n>a</span><span class=p>,</span> <span class=n>T</span> <span class=o>&amp;</span><span class=n>b</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>T</span> <span class=n>temp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>temp</span> <span class=o>=</span> <span class=n>a</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>a</span> <span class=o>=</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>b</span> <span class=o>=</span> <span class=n>temp</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>Swap</span><span class=p>(</span><span class=n>T</span> <span class=n>a</span><span class=p>[],</span> <span class=n>T</span> <span class=n>b</span><span class=p>[],</span> <span class=kt>int</span> <span class=n>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>T</span> <span class=n>temp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>n</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>temp</span> <span class=o>=</span> <span class=n>a</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=n>a</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>b</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=n>b</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>temp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=template-limitations>Template Limitations<a hidden class=anchor aria-hidden=true href=#template-limitations>#</a></h3><p>Let&rsquo;s say we want to compare two numbers in a template, we can simply write things like <code>a == b</code>, however, the <code>==</code> equal sign (and <code>>, &lt;</code>) is not defined under C arrays or other data structures. We must provide specialized template funcitons for particular types.</p><h3 id=explicit-specializations>Explicit Specializations<a hidden class=anchor aria-hidden=true href=#explicit-specializations>#</a></h3><p>Suppose we have a structure that looks like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>struct</span> <span class=nc>job</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=n>name</span><span class=p>[</span><span class=mi>40</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=kt>double</span> <span class=n>salary</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>floor</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>and we want to define a swap funciton for it, but only swapping <code>salary</code> and <code>floor</code>, then we can use explicit specializations. The prototype and definition for an explicit specialization should be preceded by <code>template &lt;></code> and should mention the specialized type by name.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// non template function prototype
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>Swap</span><span class=p>(</span><span class=n>job</span> <span class=o>&amp;</span><span class=p>,</span> <span class=n>job</span> <span class=o>&amp;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// template prototype
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>Swap</span><span class=p>(</span><span class=n>T</span> <span class=o>&amp;</span><span class=p>,</span> <span class=n>T</span> <span class=o>&amp;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// explicit specialization for the job type
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>template</span> <span class=o>&lt;&gt;</span> <span class=kt>void</span> <span class=n>Swap</span><span class=o>&lt;</span><span class=n>job</span><span class=o>&gt;</span><span class=p>(</span><span class=n>job</span> <span class=o>&amp;</span><span class=p>,</span> <span class=n>job</span> <span class=o>&amp;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// swaps just the salary and floor fields of a job structure
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>template</span> <span class=o>&lt;&gt;</span> <span class=kt>void</span> <span class=n>Swap</span><span class=o>&lt;</span><span class=n>job</span><span class=o>&gt;</span><span class=p>(</span><span class=n>job</span> <span class=o>&amp;</span><span class=n>j1</span><span class=p>,</span> <span class=n>job</span> <span class=o>&amp;</span><span class=n>j2</span><span class=p>)</span> <span class=c1>// specialization
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>double</span> <span class=n>t1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>t2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>t1</span> <span class=o>=</span> <span class=n>j1</span><span class=p>.</span><span class=n>salary</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>j1</span><span class=p>.</span><span class=n>salary</span> <span class=o>=</span> <span class=n>j2</span><span class=p>.</span><span class=n>salary</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>j2</span><span class=p>.</span><span class=n>salary</span> <span class=o>=</span> <span class=n>t1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>t2</span> <span class=o>=</span> <span class=n>j1</span><span class=p>.</span><span class=n>floor</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>j1</span><span class=p>.</span><span class=n>floor</span> <span class=o>=</span> <span class=n>j2</span><span class=p>.</span><span class=n>floor</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>j2</span><span class=p>.</span><span class=n>floor</span> <span class=o>=</span> <span class=n>t2</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>For a given function name, you can have a non template function,a template function,and an explicit specialization template function,along with overloaded versions of all of these. A specialization overrides the regular template,and a non template function overrides both.</p><h3 id=instantiations-and-specializations>Instantiations and Specializations<a hidden class=anchor aria-hidden=true href=#instantiations-and-specializations>#</a></h3><p>When the compiler uses the template to generate a funciton for a particular type, we call it <em><strong>instantiation</strong></em> of the template. If we write this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>Swap</span><span class=p>(</span><span class=n>T</span> <span class=o>&amp;</span><span class=n>a</span><span class=p>,</span> <span class=n>T</span> <span class=o>&amp;</span><span class=n>b</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>T</span> <span class=n>temp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>temp</span> <span class=o>=</span> <span class=n>a</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>a</span> <span class=o>=</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>b</span> <span class=o>=</span> <span class=n>temp</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=n>Swap</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=n>j</span><span class=p>);</span> <span class=c1>// i, j are int type
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>...</span>
</span></span></code></pre></div><p>Then this is called <em><strong>implicit instantiation</strong></em>. The compiler creates a function <code>Swap()</code> for <code>int</code> type because the program uses <code>Swap()</code> with <code>int</code> parameters.</p><p>There is also <em><strong>explicit instantiation</strong></em>, which means that we can tell the compiler to generate a function for specific type for us.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span> <span class=kt>void</span> <span class=n>Swap</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span><span class=p>(</span><span class=kt>int</span><span class=p>,</span> <span class=kt>int</span><span class=p>);</span> <span class=c1>// explicit instantiation
</span></span></span></code></pre></div><p>It basically tells the compiler &ldquo;Use the <code>Swap()</code> template to generate a function definition for the <code>int</code> type.&rdquo;</p><p>Note the difference between explicit instantiation and explicit specialization. The explicit specialization declaration has <code>&lt;></code> after the keyword <code>template</code>, whereas the explicit instantiation omits the <code>&lt;></code>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span> <span class=kt>void</span> <span class=n>Swap</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span><span class=p>(</span><span class=kt>int</span> <span class=o>&amp;</span><span class=p>,</span> <span class=kt>int</span> <span class=o>&amp;</span><span class=p>);</span> <span class=c1>// explicit instantiation
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>template</span> <span class=o>&lt;&gt;</span> <span class=kt>void</span> <span class=n>Swap</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span><span class=p>(</span><span class=kt>int</span> <span class=o>&amp;</span><span class=p>,</span> <span class=kt>int</span> <span class=o>&amp;</span><span class=p>);</span> <span class=c1>// explicit specialization
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>template</span> <span class=o>&lt;&gt;</span> <span class=kt>void</span> <span class=n>Swap</span><span class=p>(</span><span class=kt>int</span> <span class=o>&amp;</span><span class=p>,</span> <span class=kt>int</span> <span class=o>&amp;</span><span class=p>);</span> <span class=c1>// explicit specialization
</span></span></span></code></pre></div><p>Explicit specialization tells the compiler &ldquo;Don’t use the <code>Swap()</code> template to generate a function definition. Instead, use a separate, specialized function definition explicitly defined for the <code>int</code> type.&rdquo;</p><h3 id=which-function-version-does-the-compiler-pick>Which Function Version Does the Compiler Pick?<a hidden class=anchor aria-hidden=true href=#which-function-version-does-the-compiler-pick>#</a></h3><p>The compiler will pick the function by such ranking:</p><ol><li>Exact match, with regular functions outranking templates</li><li>Conversion by promotion (for example, the automatic conversions of char and
short to int and of float to double)</li><li>Conversion by standard conversion (for example, converting int to char or long
to double)</li><li>User-defined conversions, such as those defined in class declarations</li></ol><p>For example,</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>may</span><span class=p>(</span><span class=sc>&#39;B&#39;</span><span class=p>);</span> <span class=c1>// actual argument is type char
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>may</span><span class=p>(</span><span class=kt>int</span><span class=p>);</span> <span class=c1>// #1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>float</span> <span class=nf>may</span><span class=p>(</span><span class=kt>float</span><span class=p>,</span> <span class=kt>float</span> <span class=o>=</span> <span class=mi>3</span><span class=p>);</span> <span class=c1>// #2
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>may</span><span class=p>(</span><span class=kt>char</span><span class=p>);</span> <span class=c1>// #3
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>char</span> <span class=o>*</span> <span class=nf>may</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=p>);</span> <span class=c1>// #4
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>char</span> <span class=nf>may</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>&amp;</span><span class=p>);</span> <span class=c1>// #5
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>template</span><span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span> <span class=kt>void</span> <span class=n>may</span><span class=p>(</span><span class=k>const</span> <span class=n>T</span> <span class=o>&amp;</span><span class=p>);</span> <span class=c1>// #6
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>template</span><span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span> <span class=kt>void</span> <span class=n>may</span><span class=p>(</span><span class=n>T</span> <span class=o>*</span><span class=p>);</span> <span class=c1>// #7
</span></span></span></code></pre></div><p>#4 and #7 are not viable. #1 is better than #2, since <code>char</code>-to-<code>int</code> is a promotion, whereas <code>char</code>-to-<code>float</code> is a standard conversion. #3, #5 and #6 are better than #1 since they are exact matches. #3 and #5 are better than #6 because #6 is a template. However, what happens if we have #3 and #5 at the same time? Most of the time, two exact matches are an error, however, special cases are exceptions to this rule.</p><h3 id=exact-matches-and-best-matches>Exact Matches and Best Matches<a hidden class=anchor aria-hidden=true href=#exact-matches-and-best-matches>#</a></h3><p>Suppose you have the following code:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>struct</span> <span class=nc>blot</span> <span class=p>{</span><span class=kt>int</span> <span class=n>a</span><span class=p>;</span> <span class=kt>char</span> <span class=n>b</span><span class=p>[</span><span class=mi>10</span><span class=p>];};</span>
</span></span><span class=line><span class=cl><span class=n>blot</span> <span class=n>ink</span> <span class=o>=</span> <span class=p>{</span><span class=mi>25</span><span class=p>,</span> <span class=s>&#34;spots&#34;</span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=n>recycle</span><span class=p>(</span><span class=n>ink</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// the following prototypes are exact matches
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>recycle</span><span class=p>(</span><span class=n>blot</span><span class=p>);</span> <span class=c1>// #1 blot-to-blot
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>recycle</span><span class=p>(</span><span class=k>const</span> <span class=n>blot</span><span class=p>);</span> <span class=c1>// #2 blot-to-(const blot)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>recycle</span><span class=p>(</span><span class=n>blot</span> <span class=o>&amp;</span><span class=p>);</span> <span class=c1>// #3 blot-to-(blot &amp;)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>recycle</span><span class=p>(</span><span class=k>const</span> <span class=n>blot</span> <span class=o>&amp;</span><span class=p>);</span> <span class=c1>// #4 blot-to-(const blot &amp;)
</span></span></span></code></pre></div><p>Pointers and references to non-<code>const</code> data are preferentially matched to non-<code>const</code> pointer and reference parameters. If only Functions #3 and #4 were available in the <code>recycle()</code> example, #3 would be chosen because <code>ink</code> wasn’t declared as <code>const</code>.</p><p>However, this discrimination between <code>const</code> and non-<code>const</code> applies just to data referred to by pointers and references. That is, if only #1 and #2 were available, you would get an ambiguity error.</p><p>If we have two template functions with exact matches, the more specialized is the better one. For example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>Type</span><span class=o>&gt;</span> <span class=kt>void</span> <span class=n>recycle</span> <span class=p>(</span><span class=n>Type</span> <span class=n>t</span><span class=p>);</span> <span class=c1>// #1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>Type</span><span class=o>&gt;</span> <span class=kt>void</span> <span class=n>recycle</span> <span class=p>(</span><span class=n>Type</span> <span class=o>*</span> <span class=n>t</span><span class=p>);</span> <span class=c1>// #2
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>blot</span> <span class=p>{</span><span class=kt>int</span> <span class=n>a</span><span class=p>;</span> <span class=kt>char</span> <span class=n>b</span><span class=p>[</span><span class=mi>10</span><span class=p>];};</span>
</span></span><span class=line><span class=cl><span class=n>blot</span> <span class=n>ink</span> <span class=o>=</span> <span class=p>{</span><span class=mi>25</span><span class=p>,</span> <span class=s>&#34;spots&#34;</span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=n>recycle</span><span class=p>(</span><span class=o>&amp;</span><span class=n>ink</span><span class=p>);</span> <span class=c1>// address of a structure
</span></span></span></code></pre></div><p>The <code>recycle(&amp;ink)</code> call matches Template #1, with <code>Type</code> interpreted as <code>blot *</code>.The <code>recycle(&amp;ink)</code> function call also matches Template #2, this time with <code>Type</code> being <code>ink</code>. In Template #2, <code>Type</code> was already specialized as a pointer, hence it is &ldquo;more specialized.&rdquo;</p><h3 id=making-your-own-choices>Making Your Own Choices<a hidden class=anchor aria-hidden=true href=#making-your-own-choices>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=n>T</span> <span class=n>lesser</span><span class=p>(</span><span class=n>T</span> <span class=n>a</span><span class=p>,</span> <span class=n>T</span> <span class=n>b</span><span class=p>)</span> <span class=c1>// #1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>lesser</span> <span class=p>(</span><span class=kt>int</span> <span class=n>a</span><span class=p>,</span> <span class=kt>int</span> <span class=n>b</span><span class=p>)</span> <span class=c1>// #2
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>m</span> <span class=o>=</span> <span class=mi>20</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>n</span> <span class=o>=</span> <span class=o>-</span><span class=mi>30</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>double</span> <span class=n>x</span> <span class=o>=</span> <span class=mf>15.5</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>double</span> <span class=n>y</span> <span class=o>=</span> <span class=mf>25.9</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>lesser</span><span class=p>(</span><span class=n>m</span><span class=p>,</span> <span class=n>n</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span> <span class=c1>// use #2
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>lesser</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span> <span class=c1>// use #1 with double
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>lesser</span><span class=o>&lt;&gt;</span><span class=p>(</span><span class=n>m</span><span class=p>,</span> <span class=n>n</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span> <span class=c1>// use #1 with int, tells compiler to choose a template function
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>lesser</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span> <span class=c1>// use #1 with int,  explicit instantiation
</span></span></span></code></pre></div><h3 id=whats-that-type>What’s That Type?<a hidden class=anchor aria-hidden=true href=#whats-that-type>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>class</span> <span class=nc>T1</span><span class=p>,</span> <span class=k>class</span> <span class=nc>T2</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>ft</span><span class=p>(</span><span class=n>T1</span> <span class=n>x</span><span class=p>,</span> <span class=n>T2</span> <span class=n>y</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=o>?</span><span class=n>type</span><span class=o>?</span> <span class=n>xpy</span> <span class=o>=</span> <span class=n>x</span> <span class=o>+</span> <span class=n>y</span><span class=p>;</span> <span class=c1>// what is the type of xpy
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>What should the type for <code>xpy</code> be? We can use <code>decltype</code> keyworld as a solution.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// decltype(expression) var;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>decltype</span><span class=p>(</span><span class=n>x</span> <span class=o>+</span> <span class=n>y</span><span class=p>)</span> <span class=n>xpy</span> <span class=o>=</span> <span class=n>x</span> <span class=o>+</span> <span class=n>y</span><span class=p>;</span> <span class=c1>// make xpy the same type as x + y
</span></span></span></code></pre></div><p><code>decltype</code> should follow these rules:</p><ol><li><p>If <code>expression</code> has no additional parentheses, then <code>var</code> is the same type as the identifier</p></li><li><p>If <code>expression</code> is a funciton call, then <code>var</code> is the same type as the function return type. Note that there&rsquo;s no need to actually call the funciton.</p></li><li><p><code>decltype</code> with extra parentheses preserves references from the original expression</p></li><li><p>If none of the preceding cases apply, <code>var</code> is the same type as <code>expression</code></p></li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>double</span> <span class=n>x</span> <span class=o>=</span> <span class=mf>5.5</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>double</span> <span class=n>y</span> <span class=o>=</span> <span class=mf>7.9</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>double</span> <span class=o>&amp;</span><span class=n>rx</span> <span class=o>=</span> <span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=kt>double</span> <span class=o>*</span> <span class=n>pd</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>decltype</span><span class=p>(</span><span class=n>x</span><span class=p>)</span> <span class=n>w</span><span class=p>;</span> <span class=c1>// w is type double
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>decltype</span><span class=p>(</span><span class=n>rx</span><span class=p>)</span> <span class=n>u</span> <span class=o>=</span> <span class=n>y</span><span class=p>;</span> <span class=c1>// u is type double &amp;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>decltype</span><span class=p>(</span><span class=n>pd</span><span class=p>)</span> <span class=n>v</span><span class=p>;</span> <span class=c1>// v is type const double *
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>long</span> <span class=nf>indeed</span><span class=p>(</span><span class=kt>int</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>decltype</span> <span class=p>(</span><span class=n>indeed</span><span class=p>(</span><span class=mi>3</span><span class=p>))</span> <span class=n>m</span><span class=p>;</span> <span class=c1>// m is type long
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>double</span> <span class=n>xx</span> <span class=o>=</span> <span class=mf>4.4</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>decltype</span> <span class=p>((</span><span class=n>xx</span><span class=p>))</span> <span class=n>r2</span> <span class=o>=</span> <span class=n>xx</span><span class=p>;</span> <span class=c1>// r2 is double &amp;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>decltype</span><span class=p>(</span><span class=n>xx</span><span class=p>)</span> <span class=n>w</span> <span class=o>=</span> <span class=n>xx</span><span class=p>;</span> <span class=c1>// w is double (Stage 1 match)
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>3</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=o>&amp;</span><span class=n>k</span> <span class=o>=</span> <span class=n>j</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=o>&amp;</span><span class=n>n</span> <span class=o>=</span> <span class=n>j</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>decltype</span><span class=p>(</span><span class=n>j</span><span class=o>+</span><span class=mi>6</span><span class=p>)</span> <span class=n>i1</span><span class=p>;</span> <span class=c1>// i1 type int
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>decltype</span><span class=p>(</span><span class=mi>100L</span><span class=p>)</span> <span class=n>i2</span><span class=p>;</span> <span class=c1>// i2 type long
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>decltype</span><span class=p>(</span><span class=n>k</span><span class=o>+</span><span class=n>n</span><span class=p>)</span> <span class=n>i3</span><span class=p>;</span> <span class=c1>// i3 type int;
</span></span></span></code></pre></div><p>Note that we can use <code>typedef</code> and <code>decltype</code> at the same time.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>typedef</span> <span class=nf>decltype</span><span class=p>(</span><span class=n>x</span> <span class=o>+</span> <span class=n>y</span><span class=p>)</span> <span class=n>xytype</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>xytype</span> <span class=n>xpy</span> <span class=o>=</span> <span class=n>x</span> <span class=o>+</span> <span class=n>y</span><span class=p>;</span>
</span></span></code></pre></div><h3 id=alternative-function-syntax>Alternative Function Syntax<a hidden class=anchor aria-hidden=true href=#alternative-function-syntax>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>class</span> <span class=nc>T1</span><span class=p>,</span> <span class=k>class</span> <span class=nc>T2</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=o>?</span><span class=n>type</span><span class=o>?</span> <span class=n>gt</span><span class=p>(</span><span class=n>T1</span> <span class=n>x</span><span class=p>,</span> <span class=n>T2</span> <span class=n>y</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>x</span> <span class=o>+</span> <span class=n>y</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>What if the problem appears in return type? In this case, we cannot use <code>decltype(x + y)</code> for the return type, since parameters <code>x</code> and <code>y</code> have not been declared. The <code>decltype</code> has to come after the parameters are declared. Instead, we can write:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>class</span> <span class=nc>T1</span><span class=p>,</span> <span class=k>class</span> <span class=nc>T2</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>gt</span><span class=p>(</span><span class=n>T1</span> <span class=n>x</span><span class=p>,</span> <span class=n>T2</span> <span class=n>y</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=k>decltype</span><span class=p>(</span><span class=n>x</span> <span class=o>+</span> <span class=n>y</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>x</span> <span class=o>+</span> <span class=n>y</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=chapter-9-memory-models-and-namespaces>Chapter 9: Memory Models and Namespaces<a hidden class=anchor aria-hidden=true href=#chapter-9-memory-models-and-namespaces>#</a></h2><h3 id=separate-compilation>Separate Compilation<a hidden class=anchor aria-hidden=true href=#separate-compilation>#</a></h3><p>We can divide the program into three parts:</p><ol><li>A header file that contains the structure declarations and prototypes for functions that use those structures</li><li>A source code file that contains the code for the structure-related functions</li><li>A source code file that contains the code that calls the structure-related functions</li></ol><p>However, this creates new problems. For example, if you had a function definition in a header file and two other files that are part of a single program included it, you would wind up with two definitions of the same function, which is an error.</p><p>Here are some things commonly found in header files:</p><ul><li>Function prototypes</li><li>Symbolic constants defined using <code>#define</code> or <code>const</code></li><li>Structure declarations</li><li>Class declarations</li><li>Template declarations</li><li>Inline functions</li></ul><p>Here is an example of seperating a program into three files:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// coordin.h -- structure templates and function prototypes
</span></span></span><span class=line><span class=cl><span class=c1>// structure templates
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#ifndef COORDIN_H_
</span></span></span><span class=line><span class=cl><span class=cp>#define COORDIN_H_
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=k>struct</span> <span class=nc>polar</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>double</span> <span class=n>distance</span><span class=p>;</span> <span class=c1>// distance from origin
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>double</span> <span class=n>angle</span><span class=p>;</span> <span class=c1>// direction from origin
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>rect</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>double</span> <span class=n>x</span><span class=p>;</span> <span class=c1>// horizontal distance from origin
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>double</span> <span class=n>y</span><span class=p>;</span> <span class=c1>// vertical distance from origin
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// prototypes
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>polar</span> <span class=nf>rect_to_polar</span><span class=p>(</span><span class=n>rect</span> <span class=n>xypos</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>show_polar</span><span class=p>(</span><span class=n>polar</span> <span class=n>dapos</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=c1>// file1.cpp -- example of a three-file program
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;coordin.h&#34;</span><span class=cp> </span><span class=c1>// structure templates, function prototypes
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>using</span> <span class=k>namespace</span> <span class=n>std</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>rect</span> <span class=n>rplace</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>polar</span> <span class=n>pplace</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Enter the x and y values: &#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=n>cin</span> <span class=o>&gt;&gt;</span> <span class=n>rplace</span><span class=p>.</span><span class=n>x</span> <span class=o>&gt;&gt;</span> <span class=n>rplace</span><span class=p>.</span><span class=n>y</span><span class=p>)</span> <span class=c1>// slick use of cin
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>pplace</span> <span class=o>=</span> <span class=n>rect_to_polar</span><span class=p>(</span><span class=n>rplace</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>show_polar</span><span class=p>(</span><span class=n>pplace</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Next two numbers (q to quit): &#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Bye!</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// file2.cpp -- contains functions called in file1.cpp
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;cmath&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;coordin.h&#34;</span><span class=cp> </span><span class=c1>// structure templates, function prototypes
</span></span></span><span class=line><span class=cl><span class=c1>// convert rectangular to polar coordinates
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>polar</span> <span class=nf>rect_to_polar</span><span class=p>(</span><span class=n>rect</span> <span class=n>xypos</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>using</span> <span class=k>namespace</span> <span class=n>std</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>polar</span> <span class=n>answer</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>answer</span><span class=p>.</span><span class=n>distance</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>    <span class=n>sqrt</span><span class=p>(</span> <span class=n>xypos</span><span class=p>.</span><span class=n>x</span> <span class=o>*</span> <span class=n>xypos</span><span class=p>.</span><span class=n>x</span> <span class=o>+</span> <span class=n>xypos</span><span class=p>.</span><span class=n>y</span> <span class=o>*</span> <span class=n>xypos</span><span class=p>.</span><span class=n>y</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>answer</span><span class=p>.</span><span class=n>angle</span> <span class=o>=</span> <span class=n>atan2</span><span class=p>(</span><span class=n>xypos</span><span class=p>.</span><span class=n>y</span><span class=p>,</span> <span class=n>xypos</span><span class=p>.</span><span class=n>x</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>answer</span><span class=p>;</span> <span class=c1>// returns a polar structure
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>// show polar coordinates, converting angle to degrees
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>show_polar</span> <span class=p>(</span><span class=n>polar</span> <span class=n>dapos</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>using</span> <span class=k>namespace</span> <span class=n>std</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=kt>double</span> <span class=n>Rad_to_deg</span> <span class=o>=</span> <span class=mf>57.29577951</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;distance = &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>dapos</span><span class=p>.</span><span class=n>distance</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;, angle = &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>dapos</span><span class=p>.</span><span class=n>angle</span> <span class=o>*</span> <span class=n>Rad_to_deg</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; degrees</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=header-file-management>Header File Management<a hidden class=anchor aria-hidden=true href=#header-file-management>#</a></h3><p>You should include a header file just once in a file. It&rsquo;s easy to include a header file multiple times accidentally. For example, you might use a header file that includes another header file.</p><p>We can use preprocessor <code>#ifndef</code> (if not defined) directive.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=cp>#ifndef COORDIN_H_
</span></span></span><span class=line><span class=cl><span class=cp>#define COORDIN_H_
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=c1>// place include file contents here
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#endif
</span></span></span></code></pre></div><p>The code above means &ldquo;process the statements between the <code>#ifndef</code> and <code>#endif</code> only if the name <code>COORDIN_H_</code> has not been defined previously by the preprocessor #define directive.&rdquo;</p><h3 id=storage-duration-scope-and-linkage>Storage Duration, Scope, and Linkage<a hidden class=anchor aria-hidden=true href=#storage-duration-scope-and-linkage>#</a></h3><p>C++ uses four different schemes for storing data,</p><ul><li>Automatic storage duration: Variables declared inside a function definition (including function parameters) will be created when program enters a function or a block and freed when executuion leaves the function or block.</li><li>Static storage duration: Varialbes defined outside function definition or with the keyword <code>static</code> have static storage duration. They persist for the entire time a program is running.</li><li>Thread storage duration: Variables declared with the <code>thread_local</code> keyword have storage that persists for as long as the containing thread lasts.</li><li>Dynamic storage duration: Memory allocated by the <code>new</code> keyword persists until it is freed with the <code>delete</code> operator or until the program ends.</li></ul><h3 id=scope-and-linkage>Scope and Linkage<a hidden class=anchor aria-hidden=true href=#scope-and-linkage>#</a></h3><p>Scope describes how widely visible a name is in a file. Linkage describes how a name can be shared in different units (files).</p><h3 id=static-duration-variables>Static Duration Variables<a hidden class=anchor aria-hidden=true href=#static-duration-variables>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>int</span> <span class=n>global</span> <span class=o>=</span> <span class=mi>1000</span><span class=p>;</span> <span class=c1>// static duration, external linkage (other files can see the variable)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>static</span> <span class=kt>int</span> <span class=n>one_file</span> <span class=o>=</span> <span class=mi>50</span><span class=p>;</span> <span class=c1>// static duration, internal linkage (only this file can see the varialbe)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>funct1</span><span class=p>(</span><span class=kt>int</span> <span class=n>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=kt>int</span> <span class=n>count</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=c1>// static duration, no linkage (only funct1 can see the variable)
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=n>llama</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>funct2</span><span class=p>(</span><span class=kt>int</span> <span class=n>q</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The static duration variables (<code>global, one_file, count</code>) persist when the program begins and execute until the program terminates.</p><h3 id=initializing-static-variables>Initializing Static Variables<a hidden class=anchor aria-hidden=true href=#initializing-static-variables>#</a></h3><p>All static duration variables have the following initialization feature: all its bits set to 0. It is also called zero-initialization.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;cmath&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=kt>int</span> <span class=n>x</span><span class=p>;</span> <span class=c1>// zero-initialization
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=n>y</span> <span class=o>=</span> <span class=mi>5</span><span class=p>;</span> <span class=c1>// constant-expression initialization
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>long</span> <span class=n>z</span> <span class=o>=</span> <span class=mi>13</span> <span class=o>*</span> <span class=mi>13</span><span class=p>;</span> <span class=c1>// constant-expression initialization
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>const</span> <span class=kt>double</span> <span class=n>pi</span> <span class=o>=</span> <span class=mf>4.0</span> <span class=o>*</span> <span class=n>atan</span><span class=p>(</span><span class=mf>1.0</span><span class=p>);</span> <span class=c1>// dynamic initialization
</span></span></span></code></pre></div><p>First, <code>x, y, z</code> and <code>pi</code> are zero-initialized. Then the compiler initialize <code>y</code> and <code>z</code> to <code>5</code> and <code>169</code>. <code>pi</code> will be initialized until the <code>atan()</code> function is linked and the program executes.</p><h3 id=static-duration-external-linkage>Static Duration, External Linkage<a hidden class=anchor aria-hidden=true href=#static-duration-external-linkage>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// file01.cpp
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>extern</span> <span class=kt>int</span> <span class=n>cats</span> <span class=o>=</span> <span class=mi>20</span><span class=p>;</span> <span class=c1>// definition because of initialization, the extern can be omitted
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=n>dogs</span> <span class=o>=</span> <span class=mi>22</span><span class=p>;</span> <span class=c1>// definition
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// file02.cpp
</span></span></span><span class=line><span class=cl><span class=c1>// use cats and dogs from file01.cpp
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>extern</span> <span class=kt>int</span> <span class=n>cats</span><span class=p>;</span> <span class=c1>// referencing declaration
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>extern</span> <span class=kt>int</span> <span class=n>dogs</span><span class=p>;</span> <span class=c1>// does not cause storage to be allocated
</span></span></span></code></pre></div><h3 id=static-duration-internal-linkagek>Static Duration, Internal Linkagek<a hidden class=anchor aria-hidden=true href=#static-duration-internal-linkagek>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// file01
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=n>errors</span> <span class=o>=</span> <span class=mi>20</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// file02
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=n>errors</span> <span class=o>=</span> <span class=mi>5</span><span class=p>;</span> <span class=c1>// this is an error, since violates the one definition rule
</span></span></span></code></pre></div><p>If we want to use the same variable name, we should addd <code>static</code> keyword.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// file01
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=n>errors</span> <span class=o>=</span> <span class=mi>20</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// file02
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>static</span> <span class=kt>int</span> <span class=n>errors</span> <span class=o>=</span> <span class=mi>5</span><span class=p>;</span> <span class=c1>// this is an error, since violates the one definition rule
</span></span></span></code></pre></div><h3 id=static-storage-duration-no-linkage>Static Storage Duration, No Linkage<a hidden class=anchor aria-hidden=true href=#static-storage-duration-no-linkage>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// reference: https://stackoverflow.com/questions/12186857/what-is-the-difference-between-static-local-variables-and-static-global-variable
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>foo</span> <span class=p>()</span> <span class=p>{</span>   
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=kt>int</span> <span class=n>x</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=o>++</span><span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>x</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span> <span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=k>const</span> <span class=o>*</span><span class=n>argv</span><span class=p>[])</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>foo</span><span class=p>();</span>  <span class=c1>// 1
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>foo</span><span class=p>();</span>  <span class=c1>// 2
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>foo</span><span class=p>();</span>  <span class=c1>// 3
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The difference between static internal linkage and static local variable is</p><ul><li>The name is only accessible within the function, and has no linkage</li><li>It is initialised the first time execution reaches the definition, not necessarily during the program&rsquo;s initialisation phases</li></ul><h3 id=more-about-const>More About <code>const</code><a hidden class=anchor aria-hidden=true href=#more-about-const>#</a></h3><p>Whereas a global variable has external linkage by default,a <code>const</code> global variable has internal linkage by default.</p><p>If, for some reason, you want to make a constant have external linkage, you can use the <code>extern</code> keyword to override the default internal linkage.</p><h2 id=chapter-10-objects-and-classes>Chapter 10: Objects and Classes<a hidden class=anchor aria-hidden=true href=#chapter-10-objects-and-classes>#</a></h2><h3 id=const-member-functions><code>const</code> Member Functions<a hidden class=anchor aria-hidden=true href=#const-member-functions>#</a></h3><p>Consider the following code:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>const</span> <span class=n>Stock</span> <span class=n>land</span> <span class=o>=</span> <span class=n>Stock</span><span class=p>(</span><span class=s>&#34;Kludgeforn Properties&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>land</span><span class=p>.</span><span class=n>show</span><span class=p>();</span> <span class=c1>// error
</span></span></span></code></pre></div><p>In <code>Stock::show()</code> function, we cannot guarantee that it will not modify the object. To solve the issue, we can add <code>const</code> at the end of the function when we declare or write definition for it.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>void</span> <span class=n>Stock</span><span class=o>::</span><span class=n>show</span><span class=p>()</span> <span class=k>const</span><span class=p>{</span> <span class=c1>// promises not to change the object
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><h2 id=chapter-11-working-with-classes>Chapter 11: Working with Classes<a hidden class=anchor aria-hidden=true href=#chapter-11-working-with-classes>#</a></h2><h3 id=operator-overloading>Operator Overloading<a hidden class=anchor aria-hidden=true href=#operator-overloading>#</a></h3><p>A common computing task is adding two arrays. We might write something like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>20</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=n>evening</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>sam</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>+</span> <span class=n>janet</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>We can overload the <code>+</code> operator so that you can do this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>evening</span> <span class=o>=</span> <span class=n>sam</span> <span class=o>+</span> <span class=n>janet</span><span class=p>;</span>
</span></span></code></pre></div><p>For example, <code>operator+()</code> overloads the <code>+</code> operator and <code>operator*()</code> overloads the <code>*</code> operator. We can also write <code>operator[]()</code> to overload the <code>[]</code> operator, which is the array-indexing operator.</p><p>Let&rsquo;s say we have a <code>Time</code> class, and we want to use <code>+</code> operator to add two <code>Time</code> objects. We can write the following code:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>Time</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>hours</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>minutes</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Time</span> <span class=k>operator</span><span class=o>+</span><span class=p>(</span><span class=k>const</span> <span class=n>Time</span> <span class=o>&amp;</span><span class=n>t</span><span class=p>)</span> <span class=k>const</span><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>Time</span> <span class=n>sum</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>sum</span><span class=p>.</span><span class=n>minutes</span> <span class=o>=</span> <span class=n>minutes</span> <span class=o>+</span> <span class=n>t</span><span class=p>.</span><span class=n>minutes</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>sum</span><span class=p>.</span><span class=n>hours</span> <span class=o>=</span> <span class=n>hours</span> <span class=o>+</span> <span class=n>t</span><span class=p>.</span><span class=n>hours</span> <span class=o>+</span> <span class=n>sum</span><span class=p>.</span><span class=n>minutes</span> <span class=o>/</span> <span class=mi>60</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>sum</span><span class=p>.</span><span class=n>minutes</span> <span class=o>%=</span> <span class=mi>60</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>sum</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=c1>// other funcions in the class
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>Now we can simply write <code>time1 + time2</code> instead of <code>time1.add(time2)</code>, and it will be translated to <code>time1.operator+(time2)</code>.</p><h3 id=introducing-friends>Introducing Friends<a hidden class=anchor aria-hidden=true href=#introducing-friends>#</a></h3><p>There are still some restrictions when overloading operators. For example, if we overload the <code>*</code> operator and write <code>time1 * 2.5</code>, it translates to <code>time1.operator*(2)</code>. However, <code>2.5 * time1</code> does not correspond to a member function since <code>2.5</code> is not a <code>Time</code> object.</p><p>We can write a nonmember function <code>Time operator*(double m, const Time &amp;t)</code> to resolve this, but it raises a new problem: nonmember functions cannot access private data in a class. There is a special category of nonmenber functions, called <em><strong>friends</strong></em>, that can access private members of a class.</p><h3 id=creating-friends>Creating Friends<a hidden class=anchor aria-hidden=true href=#creating-friends>#</a></h3><p>To create a friend function, we need to add <code>friend</code> keyword in the prefix of the declaration.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>friend</span> <span class=n>Time</span> <span class=k>operator</span><span class=o>*</span><span class=p>(</span><span class=kt>double</span> <span class=n>m</span><span class=p>,</span> <span class=k>const</span> <span class=n>Time</span> <span class=o>&amp;</span><span class=n>t</span><span class=p>);</span> <span class=c1>// goes in class declaration
</span></span></span></code></pre></div><p>The friend function is not a member function although it is in class declaration, but it has the same access rights as a member function.</p><p>The definition should like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// no need to add friend keyword
</span></span></span><span class=line><span class=cl><span class=c1>// no need to write Time Time::operator*(double m, const Time &amp;t) since it is not a member function
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>Time</span> <span class=k>operator</span><span class=o>*</span><span class=p>(</span><span class=kt>double</span> <span class=n>m</span><span class=p>,</span> <span class=k>const</span> <span class=n>Time</span> <span class=o>&amp;</span><span class=n>t</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=n>Time</span> <span class=n>result</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>long</span> <span class=n>totalminutes</span> <span class=o>=</span> <span class=n>t</span><span class=p>.</span><span class=n>hours</span> <span class=o>*</span> <span class=n>mult</span> <span class=o>*</span> <span class=mi>60</span> <span class=o>+</span><span class=n>t</span><span class=p>.</span> <span class=n>minutes</span> <span class=o>*</span> <span class=n>mult</span><span class=p>;</span> <span class=c1>// can access private members
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>result</span><span class=p>.</span><span class=n>hours</span> <span class=o>=</span> <span class=n>totalminutes</span> <span class=o>/</span> <span class=mi>60</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>result</span><span class=p>.</span><span class=n>minutes</span> <span class=o>=</span> <span class=n>totalminutes</span> <span class=o>%</span> <span class=mi>60</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>result</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Now, the statement <code>time2 = 2.5 * time1</code> translates to <code>time2 = operator*(2.5, time1)</code></p><p>Actually, we can write it as a non-friend function. However, it is better to write it as a friend function, since it ties the function and the class interface together, and allows potential access to private data in the future.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>Time</span> <span class=k>operator</span><span class=o>*</span><span class=p>(</span><span class=kt>double</span> <span class=n>m</span><span class=p>,</span> <span class=k>const</span> <span class=n>Time</span> <span class=o>&amp;</span><span class=n>t</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>t</span> <span class=o>*</span> <span class=n>m</span><span class=p>;</span> <span class=c1>// use t.operator*(m)
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// no need to access private members
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><h3 id=overloading-the--operator>Overloading the <code>&lt;&lt;</code> Operator<a hidden class=anchor aria-hidden=true href=#overloading-the--operator>#</a></h3><p>Suppose <code>trip</code> is a <code>Time</code> object. To display <code>Time</code> values, we need to write <code>trip.show()</code> to print out the values. However, we could overload the <code>&lt;&lt;</code> operator and make <code>cout &lt;&lt; trip</code> print out the values.</p><p>We can overload the operator this way:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>void</span> <span class=k>operator</span><span class=o>&lt;&lt;</span><span class=p>(</span><span class=n>ostream</span> <span class=o>&amp;</span><span class=n>os</span><span class=p>,</span> <span class=k>const</span> <span class=n>Time</span> <span class=o>&amp;</span><span class=n>t</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=n>os</span> <span class=o>&lt;&lt;</span> <span class=n>t</span><span class=p>.</span><span class=n>hours</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;hours, &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>t</span><span class=p>.</span><span class=n>minutes</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; minutes&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>How about a more complex one, something like this: <code>cout &lt;&lt; "Trip time: " &lt;&lt; trip &lt;&lt; "\n";</code></p><p>Actually, <code>cout</code> is an <code>ostream</code> object, and the <code>ostream</code> class returns a reference to an <code>ostream</code> object when implementing the <code>&lt;&lt;</code> operator.</p><p>We just need to make <code>operator&lt;&lt;()</code> return a <code>ostream</code> object.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>ostream</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>&lt;&lt;</span><span class=p>(</span><span class=n>ostrream</span> <span class=o>&amp;</span><span class=n>os</span><span class=p>,</span> <span class=k>const</span> <span class=n>Time</span> <span class=o>&amp;</span><span class=n>t</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=n>os</span> <span class=o>&lt;&lt;</span> <span class=n>t</span><span class=p>.</span><span class=n>hours</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;hours, &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>t</span><span class=p>.</span><span class=n>minutes</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; minutes&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>os</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=a-vector-class>A Vector Class<a hidden class=anchor aria-hidden=true href=#a-vector-class>#</a></h3><p><a href=http://localhost:1313/blog/code/vector/>Vector class</a></p><h3 id=automatic-conversions-and-type-casts-for-classes>Automatic Conversions and Type Casts for Classes<a hidden class=anchor aria-hidden=true href=#automatic-conversions-and-type-casts-for-classes>#</a></h3><p>C++ provides the following type conversions for classes:</p><ul><li>A class constructor that has but a single argument serves as an instruction for converting a value of the argument type to the class type.</li></ul><p>For example, if we have a constructor <code>Stonewt(double lbs)</code> for <code>Stonewt</code> class. Then <code>Stonewt myCat = 19.6</code> will convert <code>19.6</code> to a <code>Stonewt</code> object.</p><p>However, using <code>explicit</code> in the constructor declaration eliminates implicit conversions and allows only explicit conversions.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>explicit</span> <span class=nf>Stonewt</span><span class=p>(</span><span class=kt>double</span> <span class=n>lbs</span><span class=p>);</span> <span class=c1>// no implicit conversions allowed
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=n>Stonewt</span> <span class=n>myCat</span><span class=p>;</span> <span class=c1>// create a Stonewt object
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>myCat</span> <span class=o>=</span> <span class=mf>19.6</span><span class=p>;</span> <span class=c1>// not valid if Stonewt(double) is declared as explicit
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>mycat</span> <span class=o>=</span> <span class=n>Stonewt</span><span class=p>(</span><span class=mf>19.6</span><span class=p>);</span> <span class=c1>// ok, an explicit conversion
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>mycat</span> <span class=o>=</span> <span class=p>(</span><span class=n>Stonewt</span><span class=p>)</span> <span class=mf>19.6</span><span class=p>;</span> <span class=c1>// ok, old form for explicit typecast
</span></span></span></code></pre></div><ul><li>A special class member operator function called a <em><strong>conversion function</strong></em> serves as an instruction for converting a class object to some other type. This conversion function is invoked automatically when you assign a class object to a variable of that type or use the type cast operator to that type.</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>Stonewt</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=c1>// conversion functions
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>explicit</span> <span class=k>operator</span> <span class=kt>int</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>Stonewt</span><span class=o>::</span><span class=k>operator</span> <span class=kt>int</span><span class=p>()</span> <span class=p>{</span> <span class=k>return</span> <span class=nf>int</span> <span class=p>(</span><span class=n>pounds</span> <span class=o>+</span> <span class=mf>0.5</span><span class=p>);</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>Stonewt</span> <span class=nf>wolfe</span><span class=p>(</span><span class=mf>285.7</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>host</span> <span class=o>=</span> <span class=kt>int</span> <span class=p>(</span><span class=n>wolfe</span><span class=p>);</span> <span class=c1>// an explicit conversion
</span></span></span></code></pre></div><h3 id=conversions-and-friends>Conversions and Friends<a hidden class=anchor aria-hidden=true href=#conversions-and-friends>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>Stonewt</span> <span class=k>operator</span><span class=o>+</span><span class=p>(</span><span class=k>const</span> <span class=n>Stonewt</span> <span class=o>&amp;</span> <span class=n>st1</span><span class=p>,</span> <span class=k>const</span> <span class=n>Stonewt</span> <span class=o>&amp;</span> <span class=n>st2</span><span class=p>)</span> <span class=c1>// friend function
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>double</span> <span class=n>pds</span> <span class=o>=</span> <span class=n>st1</span><span class=p>.</span><span class=n>pounds</span> <span class=o>+</span> <span class=n>st2</span><span class=p>.</span><span class=n>pounds</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Stonewt</span> <span class=nf>sum</span><span class=p>(</span><span class=n>pds</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>sum</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>Stonewt</span> <span class=nf>jennySt</span><span class=p>(</span><span class=mi>9</span><span class=p>,</span> <span class=mi>12</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>double</span> <span class=n>pennyD</span> <span class=o>=</span> <span class=mf>146.0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>Stonewt</span> <span class=n>total</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>total</span> <span class=o>=</span> <span class=n>pennyD</span> <span class=o>+</span> <span class=n>jennySt</span><span class=p>;</span> <span class=c1>// ok with friend function, but not member function
</span></span></span><span class=line><span class=cl><span class=c1>// convert pennyD to a Stonewt object
</span></span></span></code></pre></div><h2 id=chapter-12-classes-and-dynamic-memory-allocation>Chapter 12: Classes and Dynamic Memory Allocation<a hidden class=anchor aria-hidden=true href=#chapter-12-classes-and-dynamic-memory-allocation>#</a></h2><h3 id=a-review-example-and-static-class-members>A Review Example and Static Class Members<a hidden class=anchor aria-hidden=true href=#a-review-example-and-static-class-members>#</a></h3><p>Let&rsquo;s take a look at a class example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// strngbad.h -- flawed string class definition
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#ifndef STRNGBAD_H_
</span></span></span><span class=line><span class=cl><span class=cp>#define STRNGBAD_H_
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=k>class</span> <span class=nc>StringBad</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=kt>char</span> <span class=o>*</span> <span class=n>str</span><span class=p>;</span> <span class=c1>// pointer to string
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=kt>int</span> <span class=n>len</span><span class=p>;</span> <span class=c1>// length of string
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>static</span> <span class=kt>int</span> <span class=n>num_strings</span><span class=p>;</span> <span class=c1>// number of objects
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=n>StringBad</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span> <span class=n>s</span><span class=p>);</span> <span class=c1>// constructor
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>StringBad</span><span class=p>();</span> <span class=c1>// default constructor
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=o>~</span><span class=n>StringBad</span><span class=p>();</span> <span class=c1>// destructor
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// friend function
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>friend</span> <span class=n>std</span><span class=o>::</span><span class=n>ostream</span> <span class=o>&amp;</span> <span class=k>operator</span><span class=o>&lt;&lt;</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>ostream</span> <span class=o>&amp;</span> <span class=n>os</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=k>const</span> <span class=n>StringBad</span> <span class=o>&amp;</span> <span class=n>st</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=c1>// strngbad.cpp -- StringBad class methods
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#include</span> <span class=cpf>&lt;cstring&gt;</span><span class=cp> </span><span class=c1>// string.h for some
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#include</span> <span class=cpf>&#34;strngbad.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=k>using</span> <span class=n>std</span><span class=o>::</span><span class=n>cout</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=c1>// initializing static class member
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=n>StringBad</span><span class=o>::</span><span class=n>num_strings</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=c1>// class methods
</span></span></span><span class=line><span class=cl><span class=c1>// construct StringBad from C string
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>StringBad</span><span class=o>::</span><span class=n>StringBad</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span> <span class=n>s</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>len</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>strlen</span><span class=p>(</span><span class=n>s</span><span class=p>);</span> <span class=c1>// set size
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>str</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>char</span><span class=p>[</span><span class=n>len</span> <span class=o>+</span> <span class=mi>1</span><span class=p>];</span> <span class=c1>// allot storage
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>std</span><span class=o>::</span><span class=n>strcpy</span><span class=p>(</span><span class=n>str</span><span class=p>,</span> <span class=n>s</span><span class=p>);</span> <span class=c1>// initialize pointer
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>num_strings</span><span class=o>++</span><span class=p>;</span> <span class=c1>// set object count
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>num_strings</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;: </span><span class=se>\&#34;</span><span class=s>&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>str</span>
</span></span><span class=line><span class=cl>    <span class=o>&lt;&lt;</span> <span class=s>&#34;</span><span class=se>\&#34;</span><span class=s> object created</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span> <span class=c1>// For Your Information
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=n>StringBad</span><span class=o>::</span><span class=n>StringBad</span><span class=p>()</span> <span class=c1>// default constructor
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>len</span> <span class=o>=</span> <span class=mi>4</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>str</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>char</span><span class=p>[</span><span class=mi>4</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>strcpy</span><span class=p>(</span><span class=n>str</span><span class=p>,</span> <span class=s>&#34;C++&#34;</span><span class=p>);</span> <span class=c1>// default string
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>num_strings</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>num_strings</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;: </span><span class=se>\&#34;</span><span class=s>&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>str</span>
</span></span><span class=line><span class=cl>    <span class=o>&lt;&lt;</span> <span class=s>&#34;</span><span class=se>\&#34;</span><span class=s> default object created</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span> <span class=c1>// FYI
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=n>StringBad</span><span class=o>::~</span><span class=n>StringBad</span><span class=p>()</span> <span class=c1>// necessary destructor
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;</span><span class=se>\&#34;</span><span class=s>&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>str</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;</span><span class=se>\&#34;</span><span class=s> object deleted, &#34;</span><span class=p>;</span> <span class=c1>// FYI
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=o>--</span><span class=n>num_strings</span><span class=p>;</span> <span class=c1>// required
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>num_strings</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; left</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span> <span class=c1>// FYI
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>delete</span> <span class=p>[]</span> <span class=n>str</span><span class=p>;</span> <span class=c1>// required
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>ostream</span> <span class=o>&amp;</span> <span class=k>operator</span><span class=o>&lt;&lt;</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>ostream</span> <span class=o>&amp;</span> <span class=n>os</span><span class=p>,</span> <span class=k>const</span> <span class=n>StringBad</span> <span class=o>&amp;</span> <span class=n>st</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>os</span> <span class=o>&lt;&lt;</span> <span class=n>st</span><span class=p>.</span><span class=n>str</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>os</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Notice that we initializes the static <code>num_strings</code> member to <code>0</code> in the <code>.cpp</code> file instead of the header file. That&rsquo;s because we cannot initialize a static member variable inside the class declaration. Declaration only tells how to allocate the memory, but it doesn&rsquo;t allocate memory. For static members, we need to initialize outside the class declaration (but not <code>const static</code>).</p><p>The <code>StringBad</code> class seems fine, however, there&rsquo;s actually some problems. Let&rsquo;s look at an example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>void</span> <span class=nf>callme</span><span class=p>(</span><span class=n>StringBad</span> <span class=n>sb</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;String passed by value:</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; </span><span class=se>\&#34;</span><span class=s>&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>sb</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;</span><span class=se>\&#34;\n</span><span class=s>&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>StringBad</span> <span class=nf>headline</span><span class=p>(</span><span class=s>&#34;Celery Stalks at Midnight&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>callme</span><span class=p>(</span><span class=n>headline</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>headline</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span> <span class=c1>// print out something strange
</span></span></span></code></pre></div><p>When we pass by value, the function will create a temporary <code>StringBad</code> object that points to the same address as the <code>headline</code> does. After the <code>callme</code> function, the destructor will be called, causing the pointer to be released, which messes up the original string.</p><h3 id=special-member-functions>Special Member Functions<a hidden class=anchor aria-hidden=true href=#special-member-functions>#</a></h3><p>The problems with the <code>StringBad</code> class stem from <em><strong>special member functions</strong></em>. C++ provides the following member functions:</p><ul><li>A default constructor if you define no constructors</li><li>A default destructor if you don’t define one</li><li>A copy constructor if you don’t define one</li><li>An assignment operator if you don’t define one</li><li>An address operator if you don’t define one</li></ul><h4 id=default-constructor>Default Constructor<a hidden class=anchor aria-hidden=true href=#default-constructor>#</a></h4><p>If we omit any constructors, the compiler will call the default constructor. If we define a constructor with no arguments, or its arguments have default values, it will become the default constructor.</p><p>However, we can have only one default constructor; otherwise, there will be ambiguity.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>Class_name</span><span class=p>(){};</span> <span class=c1>// default constructor
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>Class_name</span><span class=p>(){</span> <span class=c1>// default constructor with no arguments
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>member</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=n>Class_name</span><span class=p>(){</span><span class=kt>int</span> <span class=n>n</span> <span class=o>=</span> <span class=mi>0</span><span class=p>}{</span> <span class=c1>// default constructor with default argument value
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>member</span> <span class=o>=</span> <span class=n>n</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h4 id=copy-constructor>Copy Constructor<a hidden class=anchor aria-hidden=true href=#copy-constructor>#</a></h4><p>A copy constructor for a class normally has this prototype: <code>Class_name(const Class_name &);</code>. The default copy constructor performs a member-by-member copy of the nonstatic members. Each member is copied by value.</p><p>A copy constructor is invoked whenever a new object is created and initialized to an existing object of the same kind.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// given that motto is a StringBad object
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>StringBad</span> <span class=nf>ditto</span><span class=p>(</span><span class=n>motto</span><span class=p>);</span> <span class=c1>// calls StringBad(const StringBad &amp;)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>StringBad</span> <span class=n>metoo</span> <span class=o>=</span> <span class=n>motto</span><span class=p>;</span> <span class=c1>// calls StringBad(const StringBad &amp;)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>StringBad</span> <span class=n>also</span> <span class=o>=</span> <span class=n>StringBad</span><span class=p>(</span><span class=n>motto</span><span class=p>);</span> <span class=c1>// calls StringBad(const StringBad &amp;)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>StringBad</span> <span class=o>*</span> <span class=n>pStringBad</span> <span class=o>=</span> <span class=k>new</span> <span class=n>StringBad</span><span class=p>(</span><span class=n>motto</span><span class=p>);</span> <span class=c1>// calls StringBad(const StringBad &amp;)
</span></span></span></code></pre></div><p>The middle two declarations may use a copy constructor directly to create <code>metoo</code> and <code>also</code>, or they may use a copy constructor to generate temporary objects whose contents are then assigned to <code>metoo</code> and <code>also</code>.</p><h5 id=back-to-stringbad-where-the-copy-constructor-goes-wrong>Back to Stringbad: Where the Copy Constructor Goes Wrong<a hidden class=anchor aria-hidden=true href=#back-to-stringbad-where-the-copy-constructor-goes-wrong>#</a></h5><p>The <code>callme</code> function creates a temporary variable that invokes the copy constructor, and this variable points to the same address as our original object. We should provide a copy constructor for the <code>StringBad</code> class.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>StringBad</span><span class=o>::</span><span class=n>StringBad</span><span class=p>(</span><span class=k>const</span> <span class=n>StringBad</span> <span class=o>&amp;</span> <span class=n>st</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>num_strings</span><span class=o>++</span><span class=p>;</span> <span class=c1>// handle static member update
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>len</span> <span class=o>=</span> <span class=n>st</span><span class=p>.</span><span class=n>len</span><span class=p>;</span> <span class=c1>// same length
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>str</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>char</span> <span class=p>[</span><span class=n>len</span> <span class=o>+</span> <span class=mi>1</span><span class=p>];</span> <span class=c1>// allot space
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>std</span><span class=o>::</span><span class=n>strcpy</span><span class=p>(</span><span class=n>str</span><span class=p>,</span> <span class=n>st</span><span class=p>.</span><span class=n>str</span><span class=p>);</span> <span class=c1>// copy string to new location
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>num_strings</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;: </span><span class=se>\&#34;</span><span class=s>&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>str</span>
</span></span><span class=line><span class=cl>    <span class=o>&lt;&lt;</span> <span class=s>&#34;</span><span class=se>\&#34;</span><span class=s> object created</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span> <span class=c1>// For Your Information
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><h4 id=assignment-operator>Assignment Operator<a hidden class=anchor aria-hidden=true href=#assignment-operator>#</a></h4><p>Assignment Operator has the following prototype:<code>Class_name & Class_name::operator=(const Class_name &);</code>.</p><p>An overloaded assignment operator is used when you assign one object to another existing object:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>StringBad</span> <span class=nf>headline</span><span class=p>(</span><span class=s>&#34;Celery Stalks at Midnight&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>StringBad</span> <span class=n>knot</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>knot</span> <span class=o>=</span> <span class=n>headline</span><span class=p>;</span> <span class=c1>// assignment operator invoked
</span></span></span></code></pre></div><p>Like a copy constructor,an implicit implementation of an assignment operator performs a member-to-member copy.</p><h5 id=back-to-stringbad-where-the-assignment-goes-wrong>Back to Stringbad: Where the Assignment Goes Wrong<a hidden class=anchor aria-hidden=true href=#back-to-stringbad-where-the-assignment-goes-wrong>#</a></h5><p>We should also provide a assignment operator for the <code>StringBad</code> class. The implementation is similar to that of the copy constructor, but there are some differences:</p><ul><li>Use <code>delete []</code> to free the old string</li><li>The function should protect against assigning an object to itself</li><li>The function returns a reference to the invoking object</li></ul><p>Here is the implementation:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>StringBad</span> <span class=o>&amp;</span> <span class=n>StringBad</span><span class=o>::</span><span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=k>const</span> <span class=n>StringBad</span> <span class=o>&amp;</span> <span class=n>st</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=k>this</span> <span class=o>==</span> <span class=o>&amp;</span><span class=n>st</span><span class=p>)</span> <span class=c1>// object assigned to itself
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>return</span> <span class=o>*</span><span class=k>this</span><span class=p>;</span> <span class=c1>// all done
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>delete</span> <span class=p>[]</span> <span class=n>str</span><span class=p>;</span> <span class=c1>// free old string
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>len</span> <span class=o>=</span> <span class=n>st</span><span class=p>.</span><span class=n>len</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>str</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>char</span> <span class=p>[</span><span class=n>len</span> <span class=o>+</span> <span class=mi>1</span><span class=p>];</span> <span class=c1>// get space for new string
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>std</span><span class=o>::</span><span class=n>strcpy</span><span class=p>(</span><span class=n>str</span><span class=p>,</span> <span class=n>st</span><span class=p>.</span><span class=n>str</span><span class=p>);</span> <span class=c1>// copy the string
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=o>*</span><span class=k>this</span><span class=p>;</span> <span class=c1>// return reference to invoking object
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><h3 id=the-new-improved-string-class>The New, Improved <code>String</code> Class<a hidden class=anchor aria-hidden=true href=#the-new-improved-string-class>#</a></h3><p>We still need a few functions to improve the <code>String</code> class, such as comparison members or bracket notation.</p><p>Here is an improved <code>String</code> class:<br><a href=http://localhost:1313/blog/code/string/>String class</a></p><p>For static class member functions, it can only use static data members, since it is not associated with a particular object.</p><p>We added <code>String & String::operator=(const char * s)</code> to improve efficiency. Consider the following code:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>String</span> <span class=n>name</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>char</span> <span class=n>temp</span><span class=p>[</span><span class=mi>40</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=n>cin</span><span class=p>.</span><span class=n>getline</span><span class=p>(</span><span class=n>temp</span><span class=p>,</span> <span class=mi>40</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>name</span> <span class=o>=</span> <span class=n>temp</span><span class=p>;</span> <span class=c1>// use constructor to convert type
</span></span></span></code></pre></div><p>The program will do the following steps:</p><ul><li>Use <code>String(const char *)</code> constructor to construct a temporary <code>String</code> object</li><li>Use <code>String & String::operator=(const String &)</code> to copy the object to <code>name</code></li><li>call <code>~String()</code> destructor to delete the temporary object</li></ul><p>Which is slower than copying the C string directly to the <code>String</code> object.</p><h3 id=looking-again-at-placement-new>Looking Again at Placement <code>new</code><a hidden class=anchor aria-hidden=true href=#looking-again-at-placement-new>#</a></h3><p>Using placement <code>new</code> is different from using regular <code>new</code> to allocate memory for objects. If we want to destroy the object that was allocated by placement <code>new</code>, we must call the destructor explicitly to do so.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>char</span> <span class=o>*</span> <span class=n>buffer</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>char</span><span class=p>[</span><span class=mi>512</span><span class=p>];</span> <span class=c1>// get a block of memory
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>MyClass</span> <span class=o>*</span><span class=n>ptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>ptr</span> <span class=o>=</span> <span class=k>new</span> <span class=p>(</span><span class=n>buffer</span><span class=p>)</span> <span class=n>MyClass</span><span class=p>;</span> <span class=c1>// place object in buffer
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>ptr</span><span class=o>-&gt;~</span><span class=n>MyClass</span><span class=p>();</span> <span class=c1>// call the destructor explicitly
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>delete</span> <span class=p>[]</span> <span class=n>buffer</span><span class=p>;</span> <span class=c1>// Free the raw memory allocated earlier
</span></span></span></code></pre></div><p>We have to call the destructor instead of delete. The reason is that <code>delete</code> does two things:</p><ul><li>It calls the destructor of the object</li><li>It attempts to free the memory where the object was located</li></ul><p>However, when using the placement <code>new</code>, the memory location is provided by us, and therefore <code>delete</code> might not know how to correctly deallocate it, leading to undefined behavior.</p><h3 id=member-initializer-list>Member Initializer List<a hidden class=anchor aria-hidden=true href=#member-initializer-list>#</a></h3><p>Let&rsquo;s say we have a class that looks like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>Queue</span><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>enum</span> <span class=p>{</span><span class=n>Size</span> <span class=o>=</span> <span class=mi>10</span><span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=n>Node</span> <span class=o>*</span> <span class=n>front</span><span class=p>;</span> <span class=c1>// pointer to front of Queue
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Node</span> <span class=o>*</span> <span class=n>rear</span><span class=p>;</span> <span class=c1>// pointer to rear of Queue
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=n>items</span><span class=p>;</span> <span class=c1>// current number of items in Queue
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>const</span> <span class=kt>int</span> <span class=n>qsize</span><span class=p>;</span> <span class=c1>// maximum number of items in Queue
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Queue</span><span class=p>(</span><span class=kt>int</span> <span class=n>qs</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>front</span> <span class=o>=</span> <span class=n>rear</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>items</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>qsize</span> <span class=o>=</span> <span class=n>qs</span><span class=p>;</span> <span class=c1>// not acceptable!
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>We want to assign <code>qs</code> to the <code>qsize</code> variable, however, <code>const</code> variable can only be initialized to a value, not assigned to a value.</p><p>Calling a constructor creates an object before the code within the brackets is executed. Thus, the constructor will first allocate space for the four member variables, then enter the brackets and assign values into allocated space.</p><p>We can use <em><strong>member initializer list</strong></em> syntax to initialize member variables.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>Queue</span><span class=p>(</span><span class=kt>int</span> <span class=n>qs</span><span class=p>)</span> <span class=o>:</span> <span class=n>qsize</span><span class=p>(</span><span class=n>qs</span><span class=p>)</span> <span class=c1>// initialize qsize to qs, instead of assigning
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>front</span> <span class=o>=</span> <span class=n>rear</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>items</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>// or
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>Queue</span><span class=p>(</span><span class=kt>int</span> <span class=n>qs</span><span class=p>)</span> <span class=o>:</span> <span class=n>qsize</span><span class=p>(</span><span class=n>qs</span><span class=p>),</span> <span class=n>front</span><span class=p>(</span><span class=nb>NULL</span><span class=p>),</span> <span class=n>rear</span><span class=p>(</span><span class=nb>NULL</span><span class=p>),</span> <span class=n>items</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Only constructors can use this initializer-list syntax. We also have to use it for class members that are declared as references.</p><p>In-class initialization is equivalent to using a member initialization list in the constructors:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>Classy</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>mem1</span> <span class=o>=</span> <span class=mi>10</span><span class=p>;</span> <span class=c1>// in-class initialization
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>// is equivalent to
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>Classy</span><span class=p>()</span><span class=o>:</span> <span class=n>mem1</span><span class=p>(</span><span class=mi>10</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The items are initialized in the order which they are decalred, not in the order in which they appear in the initializer list.</p><h2 id=chapter-13-class-inheritance>Chapter 13: Class Inheritance<a hidden class=anchor aria-hidden=true href=#chapter-13-class-inheritance>#</a></h2><h3 id=beginning-with-a-simple-base-class>Beginning with a Simple Base Class<a hidden class=anchor aria-hidden=true href=#beginning-with-a-simple-base-class>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// tabtenn0.h -- a table-tennis base class
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#ifndef TABTENN0_H_
</span></span></span><span class=line><span class=cl><span class=cp>#define TABTENN0_H_
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;string&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=k>using</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=c1>// simple base class
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>class</span> <span class=nc>TableTennisPlayer</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>string</span> <span class=n>firstname</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>string</span> <span class=n>lastname</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=n>hasTable</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>TableTennisPlayer</span> <span class=p>(</span><span class=k>const</span> <span class=n>string</span> <span class=o>&amp;</span> <span class=n>fn</span> <span class=o>=</span> <span class=s>&#34;none&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=k>const</span> <span class=n>string</span> <span class=o>&amp;</span> <span class=n>ln</span> <span class=o>=</span> <span class=s>&#34;none&#34;</span><span class=p>,</span> <span class=kt>bool</span> <span class=n>ht</span> <span class=o>=</span> <span class=nb>false</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>Name</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=nf>HasTable</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=n>hasTable</span><span class=p>;</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>ResetTable</span><span class=p>(</span><span class=kt>bool</span> <span class=n>v</span><span class=p>)</span> <span class=p>{</span> <span class=n>hasTable</span> <span class=o>=</span> <span class=n>v</span><span class=p>;</span> <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=c1>//tabtenn0.cpp -- simple base-class methods
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#include</span> <span class=cpf>&#34;tabtenn0.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=n>TableTennisPlayer</span><span class=o>::</span><span class=n>TableTennisPlayer</span> <span class=p>(</span><span class=k>const</span> <span class=n>string</span> <span class=o>&amp;</span> <span class=n>fn</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=n>string</span> <span class=o>&amp;</span> <span class=n>ln</span><span class=p>,</span> <span class=kt>bool</span> <span class=n>ht</span><span class=p>)</span> <span class=o>:</span> <span class=n>firstname</span><span class=p>(</span><span class=n>fn</span><span class=p>),</span>
</span></span><span class=line><span class=cl>        <span class=n>lastname</span><span class=p>(</span><span class=n>ln</span><span class=p>),</span> <span class=n>hasTable</span><span class=p>(</span><span class=n>ht</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>TableTennisPlayer</span><span class=o>::</span><span class=n>Name</span><span class=p>()</span> <span class=k>const</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>lastname</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;, &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>firstname</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Now we can create <code>RatedPlayer</code> class that derives from the <code>TableTennesPlayer</code> base class:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// RatedPlayer derives from the TableTennisPlayer base class
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>class</span> <span class=nc>RatedPlayer</span> <span class=o>:</span> <span class=k>public</span> <span class=n>TableTennisPlayer</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>rating</span><span class=p>;</span> <span class=c1>// add a data member
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>RatedPlayer</span> <span class=p>(</span><span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>r</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=k>const</span> <span class=n>string</span> <span class=o>&amp;</span> <span class=n>fn</span> <span class=o>=</span> <span class=s>&#34;none&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=k>const</span> <span class=n>string</span> <span class=o>&amp;</span> <span class=n>ln</span> <span class=o>=</span> <span class=s>&#34;none&#34;</span><span class=p>,</span> <span class=kt>bool</span> <span class=n>ht</span> <span class=o>=</span> <span class=nb>false</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>RatedPlayer</span><span class=p>(</span><span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>r</span><span class=p>,</span> <span class=k>const</span> <span class=n>TableTennisPlayer</span> <span class=o>&amp;</span> <span class=n>tp</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=nf>Rating</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=n>rating</span><span class=p>;</span> <span class=p>}</span> <span class=c1>// add a method
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>void</span> <span class=nf>ResetRating</span> <span class=p>(</span><span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>r</span><span class=p>)</span> <span class=p>{</span><span class=n>rating</span> <span class=o>=</span> <span class=n>r</span><span class=p>;}</span> <span class=c1>// add a method
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span></code></pre></div><p>With public derivation, the public members of the base class become public members of the derived class. The private portions of a base class become part of the derived class, but they can be accessed only through public and protected methods of the base class.</p><h3 id=constructors>Constructors<a hidden class=anchor aria-hidden=true href=#constructors>#</a></h3><p>When a program constructs a derived-class object, it first constructs the base-class object. We must use member initailizer list syntax to construct base-class object before we enter the body of the derived-class constructor.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>RatedPlayer</span><span class=o>::</span><span class=n>RatedPlayer</span><span class=p>(</span><span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>r</span><span class=p>,</span> <span class=k>const</span> <span class=n>string</span> <span class=o>&amp;</span> <span class=n>fn</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=n>string</span> <span class=o>&amp;</span> <span class=n>ln</span><span class=p>,</span> <span class=kt>bool</span> <span class=n>ht</span><span class=p>)</span> <span class=o>:</span> <span class=n>TableTennisPlayer</span><span class=p>(</span><span class=n>fn</span><span class=p>,</span> <span class=n>ln</span><span class=p>,</span> <span class=n>ht</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>rating</span> <span class=o>=</span> <span class=n>r</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>We we omit calling a base-class constructor, the program uses the default constructor.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>RatedPlayer</span><span class=o>::</span><span class=n>RatedPlayer</span><span class=p>(</span><span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>r</span><span class=p>,</span> <span class=k>const</span> <span class=n>string</span> <span class=o>&amp;</span> <span class=n>fn</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=n>string</span> <span class=o>&amp;</span> <span class=n>ln</span><span class=p>,</span> <span class=kt>bool</span> <span class=n>ht</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>rating</span> <span class=o>=</span> <span class=n>r</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>// is same as
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>RatedPlayer</span><span class=o>::</span><span class=n>RatedPlayer</span><span class=p>(</span><span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>r</span><span class=p>,</span> <span class=k>const</span> <span class=n>string</span> <span class=o>&amp;</span> <span class=n>fn</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=n>string</span> <span class=o>&amp;</span> <span class=n>ln</span><span class=p>,</span> <span class=kt>bool</span> <span class=n>ht</span><span class=p>)</span> <span class=o>:</span> <span class=n>TableTennisPlayer</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>rating</span> <span class=o>=</span> <span class=n>r</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=special-relationships-between-derived-and-base-classes>Special Relationships Between Derived and Base Classes<a hidden class=anchor aria-hidden=true href=#special-relationships-between-derived-and-base-classes>#</a></h3><p>A base-class pointer can point to a derivedclass object without an explicit type cast and that a base-class reference can refer to a derived-class object without an explicit type cast.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>RatedPlayer</span> <span class=nf>player1</span><span class=p>(</span><span class=mi>1140</span><span class=p>,</span> <span class=s>&#34;Mallory&#34;</span><span class=p>,</span> <span class=s>&#34;Duck&#34;</span><span class=p>,</span> <span class=nb>true</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>TableTennisPlayer</span> <span class=o>&amp;</span> <span class=n>rt</span> <span class=o>=</span> <span class=n>player</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>TableTennisPlayer</span> <span class=o>*</span> <span class=n>pt</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>player</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>rt</span><span class=p>.</span><span class=n>Name</span><span class=p>();</span> <span class=c1>// invoke Name() with reference
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>pt</span><span class=o>-&gt;</span><span class=n>Name</span><span class=p>();</span> <span class=c1>// invoke Name() with pointer
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=n>TableTennisPlayer</span> <span class=nf>player2</span><span class=p>(</span><span class=n>player1</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// The exact match should be TableTennisPlayer(const RatedPlayer &amp;) that doesn&#39;t exist
</span></span></span><span class=line><span class=cl><span class=c1>// but there is the implicit copy constructor TableTennisPlayer(const TableTennisPlayer &amp;)
</span></span></span></code></pre></div><p>However,a base-class pointer or reference can invoke just base-class methods, not derived-class methods.</p><h3 id=polymorphic-public-inheritance>Polymorphic Public Inheritance<a hidden class=anchor aria-hidden=true href=#polymorphic-public-inheritance>#</a></h3><p><code>virtual</code> determines which method is used if the method is invoked by a reference or a pointer instead of by an object. If you don’t use the keyword virtual, the program chooses a method based on the reference type or pointer type.</p><p>For example, if we have a base-class <code>Brass</code> and a derived-class <code>BrassPlus</code>, and a virtual function <code>ViewAcct()</code> for both classes.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>Brass</span> <span class=nf>dom</span><span class=p>(</span><span class=s>&#34;Dominic Banker&#34;</span><span class=p>,</span> <span class=mi>11224</span><span class=p>,</span> <span class=mf>4183.45</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>BrassPlus</span> <span class=nf>dot</span><span class=p>(</span><span class=s>&#34;Dorothy Banker&#34;</span><span class=p>,</span> <span class=mi>12118</span><span class=p>,</span> <span class=mf>2592.00</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>dom</span><span class=p>.</span><span class=n>ViewAcct</span><span class=p>();</span> <span class=c1>// use Brass::ViewAcct()
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>dot</span><span class=p>.</span><span class=n>ViewAcct</span><span class=p>();</span> <span class=c1>// use BrassPlus::ViewAcct()
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=n>Brass</span> <span class=o>&amp;</span><span class=n>b1_ref</span> <span class=o>=</span> <span class=n>dom</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>Brass</span> <span class=o>&amp;</span><span class=n>b2_ref</span> <span class=o>=</span> <span class=n>dot</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>b1_ref</span><span class=p>.</span><span class=n>ViewAcct</span><span class=p>();</span> <span class=c1>// use Brass::ViewAcct()
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>b2_ref</span><span class=p>.</span><span class=n>ViewAcct</span><span class=p>();</span> <span class=c1>// use BrassPlus::ViewAcct()
</span></span></span></code></pre></div><p>If we don&rsquo;t have <code>virtual</code> keyword for the function, the reference will use <code>Brass::ViewAcct()</code> in both line of code.</p><p>When a method is declared virtual in a base
class, it is automatically virtual in the derived class, but it is a good idea to document which functions are virtual by using the keyword <code>virtual</code> in the derived class declarations.</p><h3 id=the-need-for-virtual-destructors>The Need for Virtual Destructors<a hidden class=anchor aria-hidden=true href=#the-need-for-virtual-destructors>#</a></h3><p>It&rsquo;s also the usual practice to declare a virtual destructor for the base class. It ensures that the correct sequence of destructors is called.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>Brass</span> <span class=o>*</span><span class=n>ptr</span> <span class=o>=</span> <span class=k>new</span> <span class=n>BrassPlus</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=k>delete</span> <span class=n>ptr</span><span class=p>;</span> <span class=c1>// calls BrassPlus destructor
</span></span></span><span class=line><span class=cl><span class=c1>// then automatically calls the base-class destructor
</span></span></span></code></pre></div><h3 id=how-virtual-functions-work>How Virtual Functions Work<a hidden class=anchor aria-hidden=true href=#how-virtual-functions-work>#</a></h3><p><img alt="Example image" loading=lazy src=/images/primer-plus-13.5.png></p><p>The usual way compilers handle virtual functions is to add a hidden member to each object.The hidden member holds a pointer to an array of function addresses. Such an array is usually termed a virtual function table (vtbl). When we call a virtual function, the program looks at the vtbl address stored in an object and goes to the corresponding table of function addresses.</p><p>In short, using virtual functions has the following modest costs in memory and execution speed:</p><ul><li>Each object has its size increased by the amount needed to hold an address</li><li>For each class, the compiler creates a table (an array) of addresses of virtual functions</li><li>For each function call, there&rsquo;s an extra step of going to a table to look up an address</li></ul><h3 id=redefinition-hides-methods>Redefinition Hides Methods<a hidden class=anchor aria-hidden=true href=#redefinition-hides-methods>#</a></h3><p>Suppose we create something like the following:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>Dwelling</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=n>showperks</span><span class=p>(</span><span class=kt>int</span> <span class=n>a</span><span class=p>)</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Hovel</span> <span class=o>:</span> <span class=k>public</span> <span class=n>Dwelling</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=n>showperks</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>Hovel</span> <span class=n>trump</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>trump</span><span class=p>.</span><span class=n>showperks</span><span class=p>();</span> <span class=c1>// valid
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>trump</span><span class=p>.</span><span class=n>showperks</span><span class=p>(</span><span class=mi>5</span><span class=p>);</span> <span class=c1>// invalid
</span></span></span></code></pre></div><p>The new <code>showperks()</code> function that takes no arguments will hide the base class version that takes an <code>int</code> argument (it actually hides all base-class methods of the same name), instead of overloading the function.</p><p>If the base class declaration is overloaded, we need to redefine all the base-class version in the derived class.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>Dwelling</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=c1>// three overloaded showperks()
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>virtual</span> <span class=kt>void</span> <span class=n>showperks</span><span class=p>(</span><span class=kt>int</span> <span class=n>a</span><span class=p>)</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=nf>showperks</span><span class=p>(</span><span class=kt>double</span> <span class=n>x</span><span class=p>)</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=nf>showperks</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Hovel</span> <span class=o>:</span> <span class=k>public</span> <span class=n>Dwelling</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=c1>// three redefined showperks()
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>virtual</span> <span class=kt>void</span> <span class=n>showperks</span><span class=p>(</span><span class=kt>int</span> <span class=n>a</span><span class=p>)</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=nf>showperks</span><span class=p>(</span><span class=kt>double</span> <span class=n>x</span><span class=p>)</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=nf>showperks</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>If we redefine just one version, the other two become hidden and cannot be used by objects of the derived class.</p><h3 id=access-control-protected>Access Control: <code>protected</code><a hidden class=anchor aria-hidden=true href=#access-control-protected>#</a></h3><p>The <code>protected</code> keyword is like <code>private</code> in outside world and <code>public</code> for derived class. It&rsquo;s useful for derived class to access to internal functions that are not available publicly.</p><h3 id=abstract-base-classes-abc>Abstract Base Classes (ABC)<a hidden class=anchor aria-hidden=true href=#abstract-base-classes-abc>#</a></h3><p>Suppose we want to create two classes, <code>Circle</code> and <code>Ellipse</code>. Of course we can first write the <code>Ellipse</code> class and then write the <code>Circle</code> class by inheriting the <code>Ellipse</code> class, since a circle <em><strong>is-a</strong></em> ellipse. However, this derivation is awkward, because circle is simpler than ellipse. It seems simpler to define a <code>Circle</code> class without using inheritance.</p><p>The useful thing about ABC is that we can extract the same part of circle and ellipse, and derive the <code>Circle</code> and <code>Ellipse</code> classes from the ABC. For the different part of circle and ellipse, we can create pure virtual functions in ABC and let derived class to override them.</p><p>When a class contains a pure virtual function, we can&rsquo;t create an object of that class. C++ allows even a pure virtual funciton to have a definition. We can make the prototype virtual but still provide a definition in the implementation file.</p><h3 id=inheritance-and-dynamic-memory-allocation>Inheritance and Dynamic Memory Allocation<a hidden class=anchor aria-hidden=true href=#inheritance-and-dynamic-memory-allocation>#</a></h3><p>When both the base class and the derived class use dynamic memory allocation, the derived-class destructor, copy constructor,and assignment operator all must use their base-class counterparts to handle the base-class component.</p><p>For a destructor, it is done automatically.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>baseDMA</span><span class=o>::~</span><span class=n>baseDMA</span><span class=p>()</span> <span class=c1>// takes care of baseDMA stuff
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>delete</span> <span class=p>[]</span> <span class=n>label</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=n>hasDMA</span><span class=o>::~</span><span class=n>hasDMA</span><span class=p>()</span> <span class=c1>// takes care of hasDMA stuff
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>delete</span> <span class=p>[]</span> <span class=n>style</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>For a copy constructor, it is accomplished by invoking the base-class copy constructor in the member initialization list, or else the default constructor is invoked automatically.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>baseDMA</span><span class=o>::</span><span class=n>baseDMA</span><span class=p>(</span><span class=k>const</span> <span class=n>baseDMA</span> <span class=o>&amp;</span> <span class=n>rs</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>label</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>char</span><span class=p>[</span><span class=n>std</span><span class=o>::</span><span class=n>strlen</span><span class=p>(</span><span class=n>rs</span><span class=p>.</span><span class=n>label</span><span class=p>)</span> <span class=o>+</span> <span class=mi>1</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>strcpy</span><span class=p>(</span><span class=n>label</span><span class=p>,</span> <span class=n>rs</span><span class=p>.</span><span class=n>label</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>rating</span> <span class=o>=</span> <span class=n>rs</span><span class=p>.</span><span class=n>rating</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>hasDMA</span><span class=o>::</span><span class=n>hasDMA</span><span class=p>(</span><span class=k>const</span> <span class=n>hasDMA</span> <span class=o>&amp;</span> <span class=n>hs</span><span class=p>)</span><span class=o>:</span> <span class=n>baseDMA</span><span class=p>(</span><span class=n>hs</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>style</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>char</span><span class=p>[</span><span class=n>std</span><span class=o>::</span><span class=n>strlen</span><span class=p>(</span><span class=n>hs</span><span class=p>.</span><span class=n>style</span><span class=p>)</span> <span class=o>+</span> <span class=mi>1</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>strcpy</span><span class=p>(</span><span class=n>style</span><span class=p>,</span> <span class=n>hs</span><span class=p>.</span><span class=n>style</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>For the assignment operator, it is accomplished by using the scope-resolution operator in an explicit call of the base-class assignment operator.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>baseDMA</span> <span class=o>&amp;</span> <span class=n>baseDMA</span><span class=o>::</span><span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=k>const</span> <span class=n>baseDMA</span> <span class=o>&amp;</span> <span class=n>rs</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=k>this</span> <span class=o>==</span> <span class=o>&amp;</span><span class=n>rs</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=o>*</span><span class=k>this</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>delete</span> <span class=p>[]</span> <span class=n>label</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>label</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>char</span><span class=p>[</span><span class=n>std</span><span class=o>::</span><span class=n>strlen</span><span class=p>(</span><span class=n>rs</span><span class=p>.</span><span class=n>label</span><span class=p>)</span> <span class=o>+</span> <span class=mi>1</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>strcpy</span><span class=p>(</span><span class=n>label</span><span class=p>,</span> <span class=n>rs</span><span class=p>.</span><span class=n>label</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>rating</span> <span class=o>=</span> <span class=n>rs</span><span class=p>.</span><span class=n>rating</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>*</span><span class=k>this</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>hasDMA</span> <span class=o>&amp;</span> <span class=n>hasDMA</span><span class=o>::</span><span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=k>const</span> <span class=n>hasDMA</span> <span class=o>&amp;</span> <span class=n>hs</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=k>this</span> <span class=o>==</span> <span class=o>&amp;</span><span class=n>hs</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=o>*</span><span class=k>this</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>baseDMA</span><span class=o>::</span><span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=n>hs</span><span class=p>);</span> <span class=c1>// copy base portion, same as *this = hs
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>delete</span> <span class=p>[]</span> <span class=n>style</span><span class=p>;</span> <span class=c1>// prepare for new style
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>style</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>char</span><span class=p>[</span><span class=n>std</span><span class=o>::</span><span class=n>strlen</span><span class=p>(</span><span class=n>hs</span><span class=p>.</span><span class=n>style</span><span class=p>)</span> <span class=o>+</span> <span class=mi>1</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>strcpy</span><span class=p>(</span><span class=n>style</span><span class=p>,</span> <span class=n>hs</span><span class=p>.</span><span class=n>style</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>*</span><span class=k>this</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=chapter-14-reusing-code-in-c>Chapter 14: Reusing Code in C++<a hidden class=anchor aria-hidden=true href=#chapter-14-reusing-code-in-c>#</a></h2><h3 id=private-inheritance>Private Inheritance<a hidden class=anchor aria-hidden=true href=#private-inheritance>#</a></h3><p>We use public inheritance to create <em><strong>is-a</strong></em> relationship, however, when we use private inheritance, it creates <em><strong>has-a</strong></em> relationship.</p><p>It seems weird to use a private inheritance, since we have no right to access base class methods in the outside world, but actually, the derived class contains all the members and data of the base class, so it creates <em><strong>has-a</strong></em> relationship.</p><h4 id=student-class-example><code>Student</code> Class Example<a hidden class=anchor aria-hidden=true href=#student-class-example>#</a></h4><p>Let&rsquo;s say we want to create a <code>Student</code> class, the class should contain a string member and a valarray member. We could use containment to do so, but try private inheritance in here.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>Student</span> <span class=o>:</span> <span class=k>private</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=p>,</span> <span class=k>private</span> <span class=n>std</span><span class=o>::</span><span class=n>valarray</span><span class=o>&lt;</span><span class=kt>double</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>We don&rsquo;t need to create private data in the <code>Student</code> class, it&rsquo;s because the two inherited base class already provide all the needed data members.</p><h4 id=initializing-base-class-components>Initializing Base-Class Components<a hidden class=anchor aria-hidden=true href=#initializing-base-class-components>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// containment
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>Student</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span> <span class=n>str</span><span class=p>,</span> <span class=k>const</span> <span class=kt>double</span> <span class=o>*</span> <span class=n>pd</span><span class=p>,</span> <span class=kt>int</span> <span class=n>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=o>:</span> <span class=n>name</span><span class=p>(</span><span class=n>str</span><span class=p>),</span> <span class=n>scores</span><span class=p>(</span><span class=n>pd</span><span class=p>,</span> <span class=n>n</span><span class=p>)</span> <span class=p>{}</span> <span class=c1>// use object names for containment
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// private inheritance
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>Student</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span> <span class=n>str</span><span class=p>,</span> <span class=k>const</span> <span class=kt>double</span> <span class=o>*</span> <span class=n>pd</span><span class=p>,</span> <span class=kt>int</span> <span class=n>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=o>:</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=p>(</span><span class=n>str</span><span class=p>),</span> <span class=n>std</span><span class=o>::</span><span class=n>valarray</span><span class=o>&lt;</span><span class=kt>double</span><span class=o>&gt;</span><span class=p>(</span><span class=n>pd</span><span class=p>,</span> <span class=n>n</span><span class=p>)</span> <span class=p>{}</span> <span class=c1>// use class names for inheritance
</span></span></span></code></pre></div><h4 id=accessing-base-class-methods>Accessing Base-Class Methods<a hidden class=anchor aria-hidden=true href=#accessing-base-class-methods>#</a></h4><p>Containment adds an object to a class as a named member object, and we use the variable name as a interface to access the class. Private inheritance provides the same feature as containment, but only without the interface, however, inheritance lets you use the class name and the scope-resolution operator to invoke base-class methods:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// containment
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>double</span> <span class=n>Student</span><span class=o>::</span><span class=n>Average</span><span class=p>()</span> <span class=k>const</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>scores</span><span class=p>.</span><span class=n>size</span><span class=p>()</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>scores</span><span class=p>.</span><span class=n>sum</span><span class=p>()</span><span class=o>/</span><span class=n>scores</span><span class=p>.</span><span class=n>size</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// private inheritance
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>double</span> <span class=n>Student</span><span class=o>::</span><span class=n>Average</span><span class=p>()</span> <span class=k>const</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>ArrayDb</span><span class=o>::</span><span class=n>size</span><span class=p>()</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>ArrayDb</span><span class=o>::</span><span class=n>sum</span><span class=p>()</span><span class=o>/</span><span class=n>ArrayDb</span><span class=o>::</span><span class=n>size</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> 
</span></span><span class=line><span class=cl>        <span class=n>reutrn</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h4 id=accessing-base-class-objects>Accessing Base-Class Objects<a hidden class=anchor aria-hidden=true href=#accessing-base-class-objects>#</a></h4><p>The way to access base-class objects is to use a type cast. Because <code>Student</code> is derived from a <code>string</code>, it&rsquo;s possible to type cast a <code>Student</code> object to a <code>string</code> object.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>const</span> <span class=n>string</span> <span class=o>&amp;</span> <span class=n>Student</span><span class=o>::</span><span class=n>Name</span><span class=p>()</span> <span class=k>const</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>(</span><span class=k>const</span> <span class=n>string</span> <span class=o>&amp;</span><span class=p>)</span> <span class=o>*</span><span class=k>this</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h4 id=accessing-base-class-friends>Accessing Base-Class Friends<a hidden class=anchor aria-hidden=true href=#accessing-base-class-friends>#</a></h4><p>We use explicit type cast to invoke the correct functions. This is basically the same technique used to access a base-class object in a class method.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>ostream</span> <span class=o>&amp;</span> <span class=k>operator</span><span class=o>&lt;&lt;</span><span class=p>(</span><span class=n>ostream</span> <span class=o>&amp;</span> <span class=n>os</span><span class=p>,</span> <span class=k>const</span> <span class=n>Student</span> <span class=o>&amp;</span> <span class=n>stu</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>os</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Scores for &#34;</span> <span class=o>&lt;&lt;</span> <span class=p>(</span><span class=k>const</span> <span class=n>String</span> <span class=o>&amp;</span><span class=p>)</span> <span class=n>stu</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;:</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><code>&lt;&lt; (const String &) stu</code> converts <code>stu</code> to a <code>string</code> object, then invokes the <code>operator&lt;&lt;(ostream &, const string &)</code> function.</p><h4 id=the-revised-student-class>The revised <code>Student</code> class<a hidden class=anchor aria-hidden=true href=#the-revised-student-class>#</a></h4><p><a href=http://localhost:1313/blog/code/c++_primer_plus_studenti/>Student</a></p><h4 id=containment-or-private-inheritance>Containment or Private Inheritance?<a hidden class=anchor aria-hidden=true href=#containment-or-private-inheritance>#</a></h4><p>Both containment and private inheritance can create <em><strong>has-a</strong></em> relationship, but which one should we use? In general, we should use containment to model a <em><strong>has-a</strong></em> relationship, and use private inheritance if the new class needs to access protected members in the original class or if it needs to redefine virtual functions.</p><h4 id=protected-inheritance>Protected Inheritance<a hidden class=anchor aria-hidden=true href=#protected-inheritance>#</a></h4><p>With protected inheritance, public and protected members of a base class become protected members of the derived class. The main difference between private and protected inheritance is when we derive another class from a derived class.</p><h4 id=redefining-access-with-using>Redefining Access with <code>using</code><a hidden class=anchor aria-hidden=true href=#redefining-access-with-using>#</a></h4><p>Suppose we want to make a particular base-class method available publicly in the derived class. A easy way is to define a derived-class method that uses the base-class method. For example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>double</span> <span class=n>Student</span><span class=o>::</span><span class=n>sum</span><span class=p>()</span> <span class=k>const</span> <span class=c1>// public Student method
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>std</span><span class=o>::</span><span class=n>valarray</span><span class=o>&lt;</span><span class=kt>double</span><span class=o>&gt;::</span><span class=n>sum</span><span class=p>();</span> <span class=c1>// use privately-inherited method
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>Another way is to use a <code>using</code> declaration. For example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>Student</span> <span class=o>:</span> <span class=k>private</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=p>,</span> <span class=k>private</span> <span class=n>std</span><span class=o>::</span><span class=n>valarray</span><span class=o>&lt;</span><span class=kt>double</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>using</span> <span class=n>std</span><span class=o>::</span><span class=n>valarray</span><span class=o>&lt;</span><span class=kt>double</span><span class=o>&gt;::</span><span class=n>min</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>using</span> <span class=n>std</span><span class=o>::</span><span class=n>valarray</span><span class=o>&lt;</span><span class=kt>double</span><span class=o>&gt;::</span><span class=n>max</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>The using declaration makes the <code>valarray&lt;double>::min()</code> and <code>valarray&lt;double>::max()</code> methods available as if they were public Student methods.</p><h3 id=multiple-inheritance>Multiple Inheritance<a hidden class=anchor aria-hidden=true href=#multiple-inheritance>#</a></h3><p>Let&rsquo;s say we have a base class called <code>Worker</code>, and two derived class, <code>Singer</code> and <code>Waiter</code>. We can derive a <code>SingingWaiter</code> class from <code>Singer</code> and <code>Waiter</code> class:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>SingingWaiter</span> <span class=o>:</span> <span class=k>public</span> <span class=n>Waiter</span><span class=p>,</span> <span class=k>public</span> <span class=n>Singer</span> <span class=p>{...};</span>
</span></span></code></pre></div><p>This is called multiple inheritance (MI).</p><p>MI can cause new problems.</p><ul><li>inheriting different methods with the same name from two different base classes</li><li>inheriting nultiple instances of a class via two or more related immediate base class (<code>SingingWaiter</code> class encounters)</li></ul><p>Let&rsquo;s look at an example.</p><p><a href=http://localhost:1313/blog/code/c++_primer_plus_worker0/>Worker0</a></p><p>The main difference between <code>Singer</code> and <code>Worker</code> class is the <code>Show</code> function. What will happen if we call the <code>Show</code> function in <code>SingingWaiter</code> class?</p><h4 id=how-many-workers>How Many Workers?<a hidden class=anchor aria-hidden=true href=#how-many-workers>#</a></h4><p><code>SingingWaiter</code> winds up two <code>Worker</code> components.</p><p><img alt="Example image" loading=lazy src=/images/primer-plus-14.4.png></p><p>We can assign the address of a derived-class object to a base-class pointer, however, this does not work in MI, since it&rsquo;s ambiguous now. We should specify which <code>Worker</code> we are pointing at:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>SingingWaiter</span> <span class=n>ed</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>Worker</span> <span class=o>*</span> <span class=n>pw</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>ed</span><span class=p>;</span> <span class=c1>// ambiguous
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>Worker</span> <span class=o>*</span> <span class=n>pw1</span> <span class=o>=</span> <span class=p>(</span><span class=n>Waiter</span> <span class=o>*</span><span class=p>)</span> <span class=o>&amp;</span><span class=n>ed</span><span class=p>;</span> <span class=c1>// the Worker in Waiter
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>Worker</span> <span class=o>*</span> <span class=n>pw2</span> <span class=o>=</span> <span class=p>(</span><span class=n>Singer</span> <span class=o>*</span><span class=p>)</span> <span class=o>&amp;</span><span class=n>ed</span><span class=p>;</span> <span class=c1>// the Worker in Singer
</span></span></span></code></pre></div><h4 id=virtual-base-classes>Virtual Base Classes<a hidden class=anchor aria-hidden=true href=#virtual-base-classes>#</a></h4><p>Virtual base classes allow an object derived from multiple bases that themselves share a common base to inherit just one object of that shared base class.</p><p>We would make <code>Worker</code> a virtual base class to <code>Singer</code> and <code>Waiter</code> by using the keyword
<code>virtual</code> in the class declarations:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// both order is valid
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>class</span> <span class=nc>Singer</span> <span class=o>:</span> <span class=k>virtual</span> <span class=k>public</span> <span class=n>Worker</span> <span class=p>{...};</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Waiter</span> <span class=o>:</span> <span class=k>public</span> <span class=k>virtual</span> <span class=n>Worker</span> <span class=p>{...};</span>
</span></span><span class=line><span class=cl><span class=c1>// define SingingWaiter as before
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>class</span> <span class=nc>SingingWaiter</span><span class=o>:</span> <span class=k>public</span> <span class=n>Singer</span><span class=p>,</span> <span class=k>public</span> <span class=n>Waiter</span> <span class=p>{...};</span>
</span></span></code></pre></div><h4 id=new-constructor-rules>New Constructor Rules<a hidden class=anchor aria-hidden=true href=#new-constructor-rules>#</a></h4><p>C++ disables the automatic passing of information through an intermediate class to a base class if the base class is virtual. We have to call the virtual base class constructor explicitly.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// wk will not be pass down to base class constructor, it will use default base class constructor
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>SingingWaiter</span><span class=p>(</span><span class=k>const</span> <span class=n>Worker</span> <span class=o>&amp;</span> <span class=n>wk</span><span class=p>,</span> <span class=kt>int</span> <span class=n>p</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=kt>int</span> <span class=n>v</span> <span class=o>=</span> <span class=n>Singer</span><span class=o>::</span><span class=n>other</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=o>:</span> <span class=n>Waiter</span><span class=p>(</span><span class=n>wk</span><span class=p>,</span><span class=n>p</span><span class=p>),</span> <span class=n>Singer</span><span class=p>(</span><span class=n>wk</span><span class=p>,</span><span class=n>v</span><span class=p>)</span> <span class=p>{}</span> <span class=c1>// flawed
</span></span></span><span class=line><span class=cl><span class=c1>// the correct way to initialize, this will work only if we have virtual base class
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>SingingWaiter</span><span class=p>(</span><span class=k>const</span> <span class=n>Worker</span> <span class=o>&amp;</span> <span class=n>wk</span><span class=p>,</span> <span class=kt>int</span> <span class=n>p</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=kt>int</span> <span class=n>v</span> <span class=o>=</span> <span class=n>Singer</span><span class=o>::</span><span class=n>other</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=o>:</span> <span class=n>Worker</span><span class=p>(</span><span class=n>wk</span><span class=p>),</span> <span class=n>Waiter</span><span class=p>(</span><span class=n>wk</span><span class=p>,</span><span class=n>p</span><span class=p>),</span> <span class=n>Singer</span><span class=p>(</span><span class=n>wk</span><span class=p>,</span><span class=n>v</span><span class=p>)</span> <span class=p>{}</span>
</span></span></code></pre></div><h4 id=which-method>Which Method?<a hidden class=anchor aria-hidden=true href=#which-method>#</a></h4><p>Use scope-resolution operator to clarify which funciton we want to invoke.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>SingingWaiter</span> <span class=nf>newhire</span><span class=p>(</span><span class=s>&#34;Elise Hawks&#34;</span><span class=p>,</span> <span class=mi>2005</span><span class=p>,</span> <span class=mi>6</span><span class=p>,</span> <span class=n>soprano</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>newhire</span><span class=p>.</span><span class=n>Show</span><span class=p>();</span> <span class=c1>// ambiguous
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>SingingWaiter</span> <span class=nf>newhire</span><span class=p>(</span><span class=s>&#34;Elise Hawks&#34;</span><span class=p>,</span> <span class=mi>2005</span><span class=p>,</span> <span class=mi>6</span><span class=p>,</span> <span class=n>soprano</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>newhire</span><span class=p>.</span><span class=n>Singer</span><span class=o>::</span><span class=n>Show</span><span class=p>();</span> <span class=c1>// use Singer version
</span></span></span></code></pre></div><p>A better way is to redefine <code>Show()</code> for <code>SingingWaiter</code> and specify which <code>Show()</code> to use (or use both).</p><p>However, the <code>Show()</code> function is an increment approach.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>void</span> <span class=n>Worker</span><span class=o>::</span><span class=n>Show</span><span class=p>()</span> <span class=k>const</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Name: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>fullname</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Employee ID: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>id</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>Waiter</span><span class=o>::</span><span class=n>Show</span><span class=p>()</span> <span class=k>const</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Category: waiter</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Worker</span><span class=o>::</span><span class=n>Show</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Panache rating: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>panache</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>Singer</span><span class=o>::</span><span class=n>Show</span><span class=p>()</span> <span class=k>const</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Category: singer</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Worker</span><span class=o>::</span><span class=n>Show</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Vocal range: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>pv</span><span class=p>[</span><span class=n>voice</span><span class=p>]</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>We can&rsquo;t combine <code>Waiter::Show()</code> and <code>Singer::Show()</code> without calling <code>Worker::Show()</code> twice.</p><p>We can use a modular approach to solve this. That is, providing a method that displays only the new components.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>void</span> <span class=n>Worker</span><span class=o>::</span><span class=n>Data</span><span class=p>()</span> <span class=k>const</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Name: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>fullname</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Employee ID: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>id</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>Waiter</span><span class=o>::</span><span class=n>Data</span><span class=p>()</span> <span class=k>const</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Panache rating: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>panache</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>Singer</span><span class=o>::</span><span class=n>Data</span><span class=p>()</span> <span class=k>const</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Vocal range: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>pv</span><span class=p>[</span><span class=n>voice</span><span class=p>]</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>SingingWaiter</span><span class=o>::</span><span class=n>Data</span><span class=p>()</span> <span class=k>const</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Singer</span><span class=o>::</span><span class=n>Data</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>Waiter</span><span class=o>::</span><span class=n>Data</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>SingingWaiter</span><span class=o>::</span><span class=n>Show</span><span class=p>()</span> <span class=k>const</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Category: singing waiter</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Worker</span><span class=o>::</span><span class=n>Data</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>Data</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h4 id=mixed-virtual-and-nonvirtual-bases>Mixed Virtual and Nonvirtual Bases<a hidden class=anchor aria-hidden=true href=#mixed-virtual-and-nonvirtual-bases>#</a></h4><p>Suppose, for example, that class <code>B</code> is a virtual base class to classes <code>C</code> and <code>D</code> and a nonvirtual base class to classes <code>X</code> and <code>Y</code>. Furthermore, suppose class <code>M</code> is derived from <code>C, D, X</code>, and <code>Y</code>. In this case, class <code>M</code> contains one class <code>B</code> subobject for all the virtually derived ancestors (that is, classes <code>C</code> and <code>D</code>) and a separate class <code>B</code> subobject for each nonvirtual ancestor (that is, classes <code>X</code> and <code>Y</code>). So, all told, it would contain three class <code>B</code> subobjects.</p><h4 id=virtual-base-classes-and-dominance>Virtual Base Classes and Dominance<a hidden class=anchor aria-hidden=true href=#virtual-base-classes-and-dominance>#</a></h4><p>With nonvirtual base classes, if a class inherits two or more members (data or methods) with the same name from different classes, using that name without qualifying it with a class name is ambiguous. If virtual base classes are involved, however, such a use may or may not be ambiguous. In this case, if one name dominates all others, it can be used unambiguously without a qualifier.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>B</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>short</span> <span class=n>q</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>C</span> <span class=o>:</span> <span class=k>virtual</span> <span class=k>public</span> <span class=n>B</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>long</span> <span class=n>q</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=nf>omg</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>D</span> <span class=o>:</span> <span class=k>public</span> <span class=n>C</span> <span class=p>{};</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>E</span> <span class=o>:</span> <span class=k>virtual</span> <span class=k>public</span> <span class=n>B</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>omg</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>F</span><span class=o>:</span> <span class=k>public</span> <span class=n>D</span><span class=p>,</span> <span class=k>public</span> <span class=n>E</span> <span class=p>{};</span>
</span></span></code></pre></div><p>The <code>q()</code> from class <code>C</code> dominates the definition in class <code>B</code>, thus, methods in <code>F</code> can use <code>q()</code> to denote <code>C::q()</code>. Neither definition of <code>omg()</code> dominates the other, therefore, we must add qualifier.</p><p>The virtual ambiguity rules pay no attention to access rules. That is, even if <code>E::omg()</code> is private, using <code>omg()</code> is ambiguous. Even if <code>C::q()</code> is private, <code>q()</code> would still refer to inaccessible <code>C::q()</code>.</p><h3 id=class-templates>Class Templates<a hidden class=anchor aria-hidden=true href=#class-templates>#</a></h3><p>Let&rsquo;s just see a template example.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// stacktp.h -- a stack template
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#ifndef STACKTP_H_
</span></span></span><span class=line><span class=cl><span class=cp>#define STACKTP_H_
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>Type</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Stack</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>enum</span> <span class=p>{</span><span class=n>MAX</span> <span class=o>=</span> <span class=mi>10</span><span class=p>};</span> <span class=c1>// constant specific to class
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Type</span> <span class=n>items</span><span class=p>[</span><span class=n>MAX</span><span class=p>];</span> <span class=c1>// holds stack items
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=n>top</span><span class=p>;</span> <span class=c1>// index for top stack item
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Stack</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=nf>isempty</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=nf>isfull</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=nf>push</span><span class=p>(</span><span class=k>const</span> <span class=n>Type</span> <span class=o>&amp;</span> <span class=n>item</span><span class=p>);</span> <span class=c1>// add item to stack
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>bool</span> <span class=nf>pop</span><span class=p>(</span><span class=n>Type</span> <span class=o>&amp;</span> <span class=n>item</span><span class=p>);</span> <span class=c1>// pop top into item
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>Type</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=n>Stack</span><span class=o>&lt;</span><span class=n>Type</span><span class=o>&gt;::</span><span class=n>Stack</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>top</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>Type</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=n>Stack</span><span class=o>&lt;</span><span class=n>Type</span><span class=o>&gt;::</span><span class=n>isempty</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>top</span> <span class=o>==</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>Type</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=n>Stack</span><span class=o>&lt;</span><span class=n>Type</span><span class=o>&gt;::</span><span class=n>isfull</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>top</span> <span class=o>==</span> <span class=n>MAX</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>Type</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=n>Stack</span><span class=o>&lt;</span><span class=n>Type</span><span class=o>&gt;::</span><span class=n>push</span><span class=p>(</span><span class=k>const</span> <span class=n>Type</span> <span class=o>&amp;</span> <span class=n>item</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>top</span> <span class=o>&lt;</span> <span class=n>MAX</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>items</span><span class=p>[</span><span class=n>top</span><span class=o>++</span><span class=p>]</span> <span class=o>=</span> <span class=n>item</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>Type</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=n>Stack</span><span class=o>&lt;</span><span class=n>Type</span><span class=o>&gt;::</span><span class=n>pop</span><span class=p>(</span><span class=n>Type</span> <span class=o>&amp;</span> <span class=n>item</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>top</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>item</span> <span class=o>=</span> <span class=n>items</span><span class=p>[</span><span class=o>--</span><span class=n>top</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span></code></pre></div><p>Notice that we have to put class declaration and definition in the same file, since class templates are not class, they are just instructions to the compiler about how to generate class (same as funciton templates).</p><h4 id=an-array-template-example-and-non-type-arguments>An Array Template Example and Non-Type Arguments<a hidden class=anchor aria-hidden=true href=#an-array-template-example-and-non-type-arguments>#</a></h4><p>Let&rsquo;s begin with a simple array template that lets you specify an array size. One is to use a dynamic array and a constructor argument to provide the number of elements.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=n>Stack</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>Stack</span><span class=p>(</span><span class=kt>int</span> <span class=n>ss</span><span class=p>)</span><span class=o>:</span> <span class=n>stacksize</span><span class=p>(</span><span class=n>ss</span><span class=p>),</span> <span class=n>top</span><span class=p>(</span><span class=mi>0</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=n>items</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Type</span> <span class=p>[</span><span class=n>stacksize</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Another approach is to use a template argument to provide the number of elements. This is what <code>std::array</code> does.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=p>,</span> <span class=kt>int</span> <span class=n>n</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>ArrayTP</span><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>T</span> <span class=n>ar</span><span class=p>[</span><span class=n>n</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><code>T</code> is a type parameter, or type argument. <code>n</code> is called a non-type, or expression argument.</p><p>Expression arguments can be an integer type, an enumerration type, a reference, or a pointer. Also the template code can&rsquo;t alter the value of the arument or take its address. Also when instantiating a template, the expression argument should be a constant expression.</p><p>The constructor approach (the <code>Stack</code> example) uses heap memory, whereas the expressoin argument approach uses memory stack. This provides faster execution time, particularly if we have a lot of small arrays.</p><p>However, the drawback is that different array sizes generate different templates. Also, the constructor approach is more versatile, since you can resize the array.</p><h4 id=template-versatility>Template Versatility<a hidden class=anchor aria-hidden=true href=#template-versatility>#</a></h4><h5 id=using-more-than-one-type-parameter>Using More Than One Type Parameter<a hidden class=anchor aria-hidden=true href=#using-more-than-one-type-parameter>#</a></h5><p>We can also write this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>T1</span><span class=p>,</span> <span class=k>class</span> <span class=nc>T2</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Pair</span><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>T1</span> <span class=n>a</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>T2</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h5 id=default-type-template-parameters>Default Type Template Parameters<a hidden class=anchor aria-hidden=true href=#default-type-template-parameters>#</a></h5><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>T1</span><span class=p>,</span> <span class=k>class</span> <span class=nc>T2</span> <span class=o>=</span> <span class=kt>int</span><span class=o>&gt;</span> <span class=k>class</span> <span class=nc>Topo</span> <span class=p>{...};</span>
</span></span><span class=line><span class=cl><span class=n>Topo</span><span class=o>&lt;</span><span class=kt>double</span><span class=p>,</span> <span class=kt>double</span><span class=o>&gt;</span> <span class=n>m1</span><span class=p>;</span> <span class=c1>// T1 is double, T2 is double
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>Topo</span><span class=o>&lt;</span><span class=kt>double</span><span class=o>&gt;</span> <span class=n>m2</span><span class=p>;</span> <span class=c1>// T1 is double, T2 is int
</span></span></span></code></pre></div><h4 id=template-specializations>Template Specializations<a hidden class=anchor aria-hidden=true href=#template-specializations>#</a></h4><p>It is similar to function templates.</p><h5 id=implicit-instantiations>Implicit Instantiations<a hidden class=anchor aria-hidden=true href=#implicit-instantiations>#</a></h5><p>The compiler doesn&rsquo;t generate an implicit instantiation of the class until it needs an object:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>ArrayTP</span><span class=o>&lt;</span><span class=kt>double</span><span class=p>,</span> <span class=mi>30</span><span class=o>&gt;</span> <span class=o>*</span> <span class=n>pt</span><span class=p>;</span> <span class=c1>// a pointer, no object needed yet
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>pt</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ArrayTP</span><span class=o>&lt;</span><span class=kt>double</span><span class=p>,</span> <span class=mi>30</span><span class=o>&gt;</span><span class=p>;</span> <span class=c1>// now an object is needed
</span></span></span></code></pre></div><h5 id=explicit-instantiations>Explicit Instantiations<a hidden class=anchor aria-hidden=true href=#explicit-instantiations>#</a></h5><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span> <span class=k>class</span> <span class=nc>ArrayTP</span><span class=o>&lt;</span><span class=n>string</span><span class=p>,</span> <span class=mi>100</span><span class=o>&gt;</span><span class=p>;</span> <span class=c1>// generate ArrayTP&lt;string, 100&gt; class
</span></span></span></code></pre></div><p>The compiler generates the class definition, including method definitions, even though no object of the class has yet been created or mentioned.</p><h5 id=explicit-specializations-1>Explicit Specializations<a hidden class=anchor aria-hidden=true href=#explicit-specializations-1>#</a></h5><p>Tells the compiler to generate the template in a particular way.</p><p>Let&rsquo;s say we have a template, and we want to specialize it when the type is <code>const char *</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>SortedArray</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span><span class=c1>// details omitted
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// specialization
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>template</span> <span class=o>&lt;&gt;</span> <span class=k>class</span> <span class=nc>SortedArray</span><span class=o>&lt;</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*&gt;</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=p>...</span><span class=c1>// details omitted
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span></code></pre></div><h5 id=partial-specializations>Partial Specializations<a hidden class=anchor aria-hidden=true href=#partial-specializations>#</a></h5><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// general template
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>T1</span><span class=p>,</span> <span class=k>class</span> <span class=nc>T2</span><span class=o>&gt;</span> <span class=k>class</span> <span class=nc>Pair</span> <span class=p>{...};</span>
</span></span><span class=line><span class=cl><span class=c1>// specialization with T2 set to int
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>T1</span><span class=o>&gt;</span> <span class=k>class</span> <span class=nc>Pair</span><span class=o>&lt;</span><span class=n>T1</span><span class=p>,</span> <span class=kt>int</span><span class=o>&gt;</span> <span class=p>{...};</span>
</span></span><span class=line><span class=cl><span class=c1>// specialization with T1 and T2 set to int
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>template</span> <span class=o>&lt;&gt;</span> <span class=k>class</span> <span class=nc>Pair</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>,</span> <span class=kt>int</span><span class=o>&gt;</span> <span class=p>{...};</span>
</span></span><span class=line><span class=cl><span class=n>Pair</span><span class=o>&lt;</span><span class=kt>double</span><span class=p>,</span> <span class=kt>double</span><span class=o>&gt;</span> <span class=n>p1</span><span class=p>;</span> <span class=c1>// use general Pair template
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>Pair</span><span class=o>&lt;</span><span class=kt>double</span><span class=p>,</span> <span class=kt>int</span><span class=o>&gt;</span> <span class=n>p2</span><span class=p>;</span> <span class=c1>// use Pair&lt;T1, int&gt; partial specialization
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>Pair</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>,</span> <span class=kt>int</span><span class=o>&gt;</span> <span class=n>p3</span><span class=p>;</span> <span class=c1>// use Pair&lt;int, int&gt; explicit specialization
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span> <span class=k>class</span> <span class=nc>Feeb</span> <span class=p>{</span> <span class=p>...</span> <span class=p>};</span><span class=c1>// general version
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>template</span><span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>*&gt;</span> <span class=k>class</span> <span class=nc>Feeb</span> <span class=p>{</span> <span class=p>...</span> <span class=p>};</span><span class=c1>// pointer partial specialization
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>Feeb</span><span class=o>&lt;</span><span class=kt>char</span><span class=o>&gt;</span> <span class=n>fb1</span><span class=p>;</span> <span class=c1>// use general Feeb template, T is char
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>Feeb</span><span class=o>&lt;</span><span class=kt>char</span> <span class=o>*&gt;</span> <span class=n>fb2</span><span class=p>;</span> <span class=c1>// use Feeb T* specialization, T is char
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// general template
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>T1</span><span class=p>,</span> <span class=k>class</span> <span class=nc>T2</span><span class=p>,</span> <span class=k>class</span> <span class=nc>T3</span><span class=o>&gt;</span> <span class=k>class</span> <span class=nc>Trio</span><span class=p>{...};</span>
</span></span><span class=line><span class=cl><span class=c1>// specialization with T3 set to T2
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>T1</span><span class=p>,</span> <span class=k>class</span> <span class=nc>T2</span><span class=o>&gt;</span> <span class=k>class</span> <span class=nc>Trio</span><span class=o>&lt;</span><span class=n>T1</span><span class=p>,</span> <span class=n>T2</span><span class=p>,</span> <span class=n>T2</span><span class=o>&gt;</span> <span class=p>{...};</span>
</span></span><span class=line><span class=cl><span class=c1>// specialization with T3 and T2 set to T1*
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>T1</span><span class=o>&gt;</span> <span class=k>class</span> <span class=nc>Trio</span><span class=o>&lt;</span><span class=n>T1</span><span class=p>,</span> <span class=n>T1</span><span class=o>*</span><span class=p>,</span> <span class=n>T1</span><span class=o>*&gt;</span> <span class=p>{...};</span>
</span></span><span class=line><span class=cl><span class=n>Trio</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>,</span> <span class=kt>short</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*&gt;</span> <span class=n>t1</span><span class=p>;</span> <span class=c1>// use general template
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>Trio</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>,</span> <span class=kt>short</span><span class=o>&gt;</span> <span class=n>t2</span><span class=p>;</span> <span class=c1>// use Trio&lt;T1, T2, T2&gt;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>Trio</span><span class=o>&lt;</span><span class=kt>char</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*&gt;</span> <span class=n>t3</span><span class=p>;</span> <span class=n>use</span> <span class=n>Trio</span><span class=o>&lt;</span><span class=n>T1</span><span class=p>,</span> <span class=n>T1</span><span class=o>*</span><span class=p>,</span> <span class=n>T1</span><span class=o>*&gt;</span>
</span></span></code></pre></div><h4 id=member-templates>Member Templates<a hidden class=anchor aria-hidden=true href=#member-templates>#</a></h4><p>A template can be a member of a structure, class, or template class.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>beta</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>V</span><span class=o>&gt;</span> <span class=c1>// nested template class member
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>class</span> <span class=nc>hold</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=n>V</span> <span class=n>val</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=n>hold</span><span class=p>(</span><span class=n>V</span> <span class=n>v</span> <span class=o>=</span> <span class=mi>0</span><span class=p>)</span> <span class=o>:</span> <span class=n>val</span><span class=p>(</span><span class=n>v</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>        <span class=kt>void</span> <span class=nf>show</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span> <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>val</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=n>V</span> <span class=nf>Value</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=n>val</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=n>hold</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=n>q</span><span class=p>;</span> <span class=c1>// template object
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>hold</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>n</span><span class=p>;</span> <span class=c1>// template object
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>beta</span><span class=p>(</span> <span class=n>T</span> <span class=n>t</span><span class=p>,</span> <span class=kt>int</span> <span class=n>i</span><span class=p>)</span> <span class=o>:</span> <span class=n>q</span><span class=p>(</span><span class=n>t</span><span class=p>),</span> <span class=n>n</span><span class=p>(</span><span class=n>i</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>    <span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>U</span><span class=o>&gt;</span> <span class=c1>// template method
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>U</span> <span class=n>blab</span><span class=p>(</span><span class=n>U</span> <span class=n>u</span><span class=p>,</span> <span class=n>T</span> <span class=n>t</span><span class=p>)</span> <span class=p>{</span> <span class=k>return</span> <span class=p>(</span><span class=n>n</span><span class=p>.</span><span class=n>Value</span><span class=p>()</span> <span class=o>+</span> <span class=n>q</span><span class=p>.</span><span class=n>Value</span><span class=p>())</span> <span class=o>*</span> <span class=n>u</span> <span class=o>/</span> <span class=n>t</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>Show</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span> <span class=n>q</span><span class=p>.</span><span class=n>show</span><span class=p>();</span> <span class=n>n</span><span class=p>.</span><span class=n>show</span><span class=p>();}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>We can also write the definition outside the class template, but it depends on the compiler. Some compilers don&rsquo;t support.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>beta</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>V</span><span class=o>&gt;</span> <span class=c1>// declaration
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>class</span> <span class=nc>hold</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>hold</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=n>q</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>hold</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>n</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>beta</span><span class=p>(</span> <span class=n>T</span> <span class=n>t</span><span class=p>,</span> <span class=kt>int</span> <span class=n>i</span><span class=p>)</span> <span class=o>:</span> <span class=n>q</span><span class=p>(</span><span class=n>t</span><span class=p>),</span> <span class=n>n</span><span class=p>(</span><span class=n>i</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>    <span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>U</span><span class=o>&gt;</span> <span class=c1>// declaration
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>U</span> <span class=n>blab</span><span class=p>(</span><span class=n>U</span> <span class=n>u</span><span class=p>,</span> <span class=n>T</span> <span class=n>t</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>Show</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span> <span class=n>q</span><span class=p>.</span><span class=n>show</span><span class=p>();</span> <span class=n>n</span><span class=p>.</span><span class=n>show</span><span class=p>();}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=c1>// member definition
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>V</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>        <span class=k>class</span> <span class=nc>beta</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>hold</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>            <span class=n>V</span> <span class=n>val</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>            <span class=n>hold</span><span class=p>(</span><span class=n>V</span> <span class=n>v</span> <span class=o>=</span> <span class=mi>0</span><span class=p>)</span> <span class=o>:</span> <span class=n>val</span><span class=p>(</span><span class=n>v</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>            <span class=kt>void</span> <span class=nf>show</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span> <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>val</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=n>V</span> <span class=nf>Value</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=n>val</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=c1>// member definition
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>U</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>        <span class=n>U</span> <span class=n>beta</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>blab</span><span class=p>(</span><span class=n>U</span> <span class=n>u</span><span class=p>,</span> <span class=n>T</span> <span class=n>t</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=p>(</span><span class=n>n</span><span class=p>.</span><span class=n>Value</span><span class=p>()</span> <span class=o>+</span> <span class=n>q</span><span class=p>.</span><span class=n>Value</span><span class=p>())</span> <span class=o>*</span> <span class=n>u</span> <span class=o>/</span> <span class=n>t</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span></code></pre></div><h4 id=templates-as-parameters>Templates As Parameters<a hidden class=anchor aria-hidden=true href=#templates-as-parameters>#</a></h4><p>We can write:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span> <span class=k>class</span> <span class=nc>Thing</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Crab</span>
</span></span></code></pre></div><p>Here <code>template &lt;typename T> class</code> is the type, and <code>Thing</code> is the parameter. Suppose we have this declaration <code>Crab&lt;King> legs;</code>. Then the template argument <code>King</code> must be a template class whose declaration look like this：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>King</span> <span class=p>{...};</span>
</span></span></code></pre></div><p>For example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span> <span class=k>class</span> <span class=nc>Thing</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Crab</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Thing</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>s1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Thing</span><span class=o>&lt;</span><span class=kt>double</span><span class=o>&gt;</span> <span class=n>s2</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Crab</span><span class=p>()</span> <span class=p>{};</span>
</span></span><span class=line><span class=cl>    <span class=c1>// assumes the thing class has push() and pop() members
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>bool</span> <span class=nf>push</span><span class=p>(</span><span class=kt>int</span> <span class=n>a</span><span class=p>,</span> <span class=kt>double</span> <span class=n>x</span><span class=p>)</span> <span class=p>{</span> <span class=k>return</span> <span class=n>s1</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=n>a</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=n>s2</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=n>x</span><span class=p>);</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=nf>pop</span><span class=p>(</span><span class=kt>int</span> <span class=o>&amp;</span> <span class=n>a</span><span class=p>,</span> <span class=kt>double</span> <span class=o>&amp;</span> <span class=n>x</span><span class=p>){</span> <span class=k>return</span> <span class=n>s1</span><span class=p>.</span><span class=n>pop</span><span class=p>(</span><span class=n>a</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=n>s2</span><span class=p>.</span><span class=n>pop</span><span class=p>(</span><span class=n>x</span><span class=p>);</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// create object
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>Crab</span><span class=o>&lt;</span><span class=n>Stack</span><span class=o>&gt;</span> <span class=n>nebula</span><span class=p>;</span>
</span></span></code></pre></div><p>We can also mix template parameters with regular parameters.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span> <span class=k>class</span> <span class=nc>Thing</span><span class=p>,</span> <span class=k>typename</span> <span class=n>U</span><span class=p>,</span> <span class=k>typename</span> <span class=n>V</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Crab</span><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Thing</span><span class=o>&lt;</span><span class=n>U</span><span class=o>&gt;</span> <span class=n>s1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Thing</span><span class=o>&lt;</span><span class=n>V</span><span class=o>&gt;</span> <span class=n>s2</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>Crab</span><span class=o>&lt;</span><span class=n>Stack</span><span class=p>,</span> <span class=kt>int</span><span class=p>,</span> <span class=kt>double</span><span class=o>&gt;</span> <span class=n>nebula</span><span class=p>;</span> <span class=c1>// T=Stack, U=int, V=double
</span></span></span></code></pre></div><h4 id=template-classes-and-friends>Template Classes and Friends<a hidden class=anchor aria-hidden=true href=#template-classes-and-friends>#</a></h4><p>Template class declarations can have friends, too. There are three categories of templates&rsquo; friend:</p><ul><li>Non-template friends</li><li>Bound template friends, meaning the type of the friend is determined by the type of the class when a class is instantiated</li><li>Unbound template friends, meaning that all specializations of the friend are friends to each specialization of the class</li></ul><h5 id=non-template-friend-functions-to-template-classes>Non-Template Friend Functions to Template Classes<a hidden class=anchor aria-hidden=true href=#non-template-friend-functions-to-template-classes>#</a></h5><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>HasFriend</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>friend</span> <span class=kt>void</span> <span class=n>counts</span><span class=p>();</span> <span class=c1>// friend to all HasFriend instantiations
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>This declaration makes the <code>counts()</code> function a friend to all instantiations of the template. But the problem is, how do this function access a <code>HasFriend</code> object without having any parameter?</p><p>It could access a global object; it could access nonglobal objects by using a global pointer; it could create its own objects; and it could access static data members of a template class, which exist separately from an object.</p><p>What if we want to pass an object as a parameter? Can we write:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>friend</span> <span class=kt>void</span> <span class=nf>report</span><span class=p>(</span><span class=n>HasFriend</span> <span class=o>&amp;</span><span class=p>);</span>
</span></span></code></pre></div><p>The answer is no. The reason is that <code>HasFriend</code> is not a object. We need to indicate a specialization. For example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>HasFriend</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>friend</span> <span class=kt>void</span> <span class=n>report</span><span class=p>(</span><span class=n>HasFriend</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=p>);</span>  <span class=c1>// bound template friend
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>Notice that <code>report()</code> is not a template function; it just has a parameter that is a template. This means that you have to define explicit specializations for the friends you plan to use:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>void</span> <span class=nf>report</span><span class=p>(</span><span class=n>HasFriend</span><span class=o>&lt;</span><span class=kt>short</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=p>)</span> <span class=p>{...};</span> <span class=c1>// explicit specialization for short
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>report</span><span class=p>(</span><span class=n>HasFriend</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=p>)</span> <span class=p>{...};</span> <span class=c1>// explicit specialization for int
</span></span></span></code></pre></div><h5 id=bound-template-friend-functions-to-template-classes>Bound Template Friend Functions to Template Classes<a hidden class=anchor aria-hidden=true href=#bound-template-friend-functions-to-template-classes>#</a></h5><p>We can make friend functions a template and bound them with each specialization.</p><p>First, declare each template function before the class definition.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span> <span class=kt>void</span> <span class=n>counts</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span> <span class=kt>void</span> <span class=n>report</span><span class=p>(</span><span class=n>T</span> <span class=o>&amp;</span><span class=p>);</span>
</span></span></code></pre></div><p>Then declare the templates as friends inside the function:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>TT</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>HasFriendT</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=k>friend</span> <span class=kt>void</span> <span class=n>counts</span><span class=o>&lt;</span><span class=n>TT</span><span class=o>&gt;</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>friend</span> <span class=kt>void</span> <span class=n>report</span><span class=o>&lt;&gt;</span><span class=p>(</span><span class=n>HasFriendT</span><span class=o>&lt;</span><span class=n>TT</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=p>);</span> <span class=c1>// same as report&lt;HasFriendT&lt;TT&gt;&gt;(HasFriendT&lt;TT&gt; &amp;)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span></code></pre></div><p>In the <code>report()</code> function, we omit the template specialization in <code>&lt;></code> , since the argument can be deduced from the function argument.</p><p>The last thing is that we must provide template definitions for the friends.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// template friend functions definitions
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>counts</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;template size: &#34;</span> <span class=o>&lt;&lt;</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>HasFriendT</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;; &#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;template counts(): &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>HasFriendT</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>ct</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>report</span><span class=p>(</span><span class=n>T</span> <span class=o>&amp;</span> <span class=n>hf</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>hf</span><span class=p>.</span><span class=n>item</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h5 id=unbound-template-friend-functions-to-template-classes>Unbound Template Friend Functions to Template Classes<a hidden class=anchor aria-hidden=true href=#unbound-template-friend-functions-to-template-classes>#</a></h5><p>The bound template friend functions in the preceding section are template specializations of a template declared outside a class. An int class specialization gets an int function specialization, and so on.</p><p>By declaring a template inside a class, you can create unbound friend functions for which every function specialization is a friend to every class specialization.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>ManyFriend</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>T</span> <span class=n>item</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>ManyFriend</span><span class=p>(</span><span class=k>const</span> <span class=n>T</span> <span class=o>&amp;</span> <span class=n>i</span><span class=p>)</span> <span class=o>:</span> <span class=n>item</span><span class=p>(</span><span class=n>i</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>    <span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>C</span><span class=p>,</span> <span class=k>typename</span> <span class=n>D</span><span class=o>&gt;</span> <span class=k>friend</span> <span class=kt>void</span> <span class=n>show2</span><span class=p>(</span><span class=n>C</span> <span class=o>&amp;</span><span class=p>,</span> <span class=n>D</span> <span class=o>&amp;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>C</span><span class=p>,</span> <span class=k>typename</span> <span class=n>D</span><span class=o>&gt;</span> <span class=kt>void</span> <span class=n>show2</span><span class=p>(</span><span class=n>C</span> <span class=o>&amp;</span> <span class=n>c</span><span class=p>,</span> <span class=n>D</span> <span class=o>&amp;</span> <span class=n>d</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>c</span><span class=p>.</span><span class=n>item</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;, &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>d</span><span class=p>.</span><span class=n>item</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>ManyFriend</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>hfi1</span><span class=p>(</span><span class=mi>10</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>ManyFriend</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>hfi2</span><span class=p>(</span><span class=mi>20</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>ManyFriend</span><span class=o>&lt;</span><span class=kt>double</span><span class=o>&gt;</span> <span class=n>hfdb</span><span class=p>(</span><span class=mf>10.5</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;hfi1, hfi2: &#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>show2</span><span class=p>(</span><span class=n>hfi1</span><span class=p>,</span> <span class=n>hfi2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;hfdb, hfi2: &#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>show2</span><span class=p>(</span><span class=n>hfdb</span><span class=p>,</span> <span class=n>hfi2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h4 id=template-aliases-c11>Template Aliases (C++11)<a hidden class=anchor aria-hidden=true href=#template-aliases-c11>#</a></h4><p>If you write code like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// define three typedef aliases
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>typedef</span> <span class=n>std</span><span class=o>::</span><span class=n>array</span><span class=o>&lt;</span><span class=kt>double</span><span class=p>,</span> <span class=mi>12</span><span class=o>&gt;</span> <span class=n>arrd</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=n>std</span><span class=o>::</span><span class=n>array</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>,</span> <span class=mi>12</span><span class=o>&gt;</span> <span class=n>arri</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=n>std</span><span class=o>::</span><span class=n>array</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=p>,</span> <span class=mi>12</span><span class=o>&gt;</span> <span class=n>arrst</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>arrd</span> <span class=n>gallons</span><span class=p>;</span> <span class=c1>// gallons is type std::array&lt;double, 12&gt;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>arri</span> <span class=n>days</span><span class=p>;</span> <span class=c1>// days is type std::array&lt;int, 12&gt;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>arrst</span> <span class=n>months</span><span class=p>;</span> <span class=c1>// months is type std::array&lt;std::string, 12&gt;
</span></span></span></code></pre></div><p>You can create template aliases:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>using</span> <span class=n>arrtype</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>array</span><span class=o>&lt;</span><span class=n>T</span><span class=p>,</span><span class=mi>12</span><span class=o>&gt;</span><span class=p>;</span> <span class=c1>// template to create multiple aliases
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=n>arrtype</span><span class=o>&lt;</span><span class=kt>double</span><span class=o>&gt;</span> <span class=n>gallons</span><span class=p>;</span> <span class=c1>// gallons is type std::array&lt;double, 12&gt;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>arrtype</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>days</span><span class=p>;</span> <span class=c1>// days is type std::array&lt;int, 12&gt;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>arrtype</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&gt;</span> <span class=n>months</span><span class=p>;</span> <span class=c1>// months is type std::array&lt;std::string, 12&gt;
</span></span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=http://localhost:1313/blog/posts/why_is_the_heap_so_slow/><span class=title>« Prev</span><br><span>Why is the heap so slow?</span>
</a><a class=next href=http://localhost:1313/blog/posts/c++-notes/><span class=title>Next »</span><br><span>C++ notes</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=http://localhost:1313/blog/>cwHsueh</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>